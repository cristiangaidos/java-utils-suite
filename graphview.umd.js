(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.QPSCoreGraphView = {}));
})(this, (function (exports) { 'use strict';

  function _defineProperty$h(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function filterList(list, value, missingIsFalse) {
    if (list === "*") {
      return true;
    }
    return list.length > 0 ? list.indexOf(value) !== -1 : !missingIsFalse;
  }
  function extend(o1, o2, keys) {
    var i;
    o1 = o1 || {};
    o2 = o2 || {};
    var _o1 = o1,
        _o2 = o2;
    if (keys) {
      for (i = 0; i < keys.length; i++) {
        _o1[keys[i]] = _o2[keys[i]];
      }
    } else {
      for (i in _o2) {
        _o1[i] = _o2[i];
      }
    }
    return o1;
  }
  function isNumber(n) {
    return Object.prototype.toString.call(n) === "[object Number]";
  }
  function isString(s) {
    return typeof s === "string";
  }
  function isBoolean(s) {
    return typeof s === "boolean";
  }
  function isObject(o) {
    return o == null ? false : Object.prototype.toString.call(o) === "[object Object]";
  }
  function isDate(o) {
    return Object.prototype.toString.call(o) === "[object Date]";
  }
  function isFunction(o) {
    return Object.prototype.toString.call(o) === "[object Function]";
  }
  function isEmpty(o) {
    for (var i in o) {
      if (o.hasOwnProperty(i)) {
        return false;
      }
    }
    return true;
  }
  function clone(a) {
    if (isString(a)) {
      return "" + a;
    } else if (isBoolean(a)) {
      return !!a;
    } else if (isDate(a)) {
      return new Date(a.getTime());
    } else if (isFunction(a)) {
      return a;
    } else if (Array.isArray(a)) {
      var _b = [];
      for (var i = 0; i < a.length; i++) {
        _b.push(clone(a[i]));
      }
      return _b;
    } else if (isObject(a)) {
      var c = {};
      for (var j in a) {
        c[j] = clone(a[j]);
      }
      return c;
    } else {
      return a;
    }
  }
  function filterNull(obj) {
    var o = {};
    for (var k in obj) {
      if (obj[k] != null) {
        o[k] = obj[k];
      }
    }
    return o;
  }
  function merge(a, b, collations, overwrites) {
    var cMap = {},
        ar,
        i,
        oMap = {};
    collations = collations || [];
    overwrites = overwrites || [];
    for (i = 0; i < collations.length; i++) {
      cMap[collations[i]] = true;
    }
    for (i = 0; i < overwrites.length; i++) {
      oMap[overwrites[i]] = true;
    }
    var c = clone(a);
    for (i in b) {
      if (c[i] == null || oMap[i]) {
        c[i] = b[i];
      } else if (cMap[i]) {
        ar = [];
        ar.push.apply(ar, Array.isArray(c[i]) ? c[i] : [c[i]]);
        ar.push(b[i]);
        c[i] = ar;
      } else if (isString(b[i]) || isBoolean(b[i]) || isFunction(b[i]) || isNumber(b[i])) {
        c[i] = b[i];
      } else {
        if (Array.isArray(b[i])) {
          ar = [];
          if (Array.isArray(c[i])) {
            ar.push.apply(ar, c[i]);
          }
          ar.push.apply(ar, b[i]);
          c[i] = ar;
        } else if (isObject(b[i])) {
          if (!isObject(c[i])) {
            c[i] = {};
          }
          for (var j in b[i]) {
            c[i][j] = b[i][j];
          }
        }
      }
    }
    return c;
  }
  function _areEqual(a, b) {
    if (a != null && b == null) {
      return false;
    } else {
      if ((a == null || isString(a) || isBoolean(a) || isNumber(a)) && a !== b) {
        return false;
      } else {
        if (Array.isArray(a)) {
          if (!Array.isArray(b)) {
            return false;
          } else {
            if (!arraysEqual(a, b)) {
              return false;
            }
          }
        } else if (isObject(a)) {
          if (!isObject(a)) {
            return false;
          } else {
            if (!objectsEqual(a, b)) {
              return false;
            }
          }
        }
      }
    }
    return true;
  }
  function arraysEqual(a, b) {
    if (a == null && b == null) {
      return true;
    } else if (a == null && b != null) {
      return false;
    } else if (a != null && b == null) {
      return false;
    }
    if (a.length !== b.length) {
      return false;
    } else {
      for (var i = 0; i < a.length; i++) {
        if (!_areEqual(a[i], b[i])) {
          return false;
        }
      }
    }
    return true;
  }
  function objectsEqual(a, b) {
    if (a == null && b == null) {
      return true;
    } else if (a == null && b != null) {
      return false;
    } else if (a != null && b == null) {
      return false;
    }
    for (var key in a) {
      var va = a[key],
          vb = b[key];
      if (!_areEqual(va, vb)) {
        return false;
      }
    }
    return true;
  }
  function replace(inObj, path, value) {
    if (inObj == null) {
      return;
    }
    var q = inObj,
        t = q;
    path.replace(/([^\.])+/g, function (term, lc, pos, str) {
      var array = term.match(/([^\[0-9]+){1}(\[)([0-9+])/),
          last = pos + term.length >= str.length,
          _getArray = function _getArray() {
        return t[array[1]] || function () {
          t[array[1]] = [];
          return t[array[1]];
        }();
      };
      if (last) {
        if (array) {
          _getArray()[array[3]] = value;
        } else {
          t[term] = value;
        }
      } else {
        if (array) {
          var _a2 = _getArray();
          t = _a2[array[3]] || function () {
            _a2[array[3]] = {};
            return _a2[array[3]];
          }();
        } else {
          t = t[term] || function () {
            t[term] = {};
            return t[term];
          }();
        }
      }
      return "";
    });
    return inObj;
  }
  function functionChain(successValue, failValue, fns) {
    for (var i = 0; i < fns.length; i++) {
      var o = fns[i][0][fns[i][1]].apply(fns[i][0], fns[i][2]);
      if (o === failValue) {
        return o;
      }
    }
    return successValue;
  }
  function populate(model, values, functionPrefix, doNotExpandFunctions) {
    var getValue = function getValue(fromString) {
      var matches = fromString.match(/(\${.*?})/g);
      if (matches != null) {
        for (var i = 0; i < matches.length; i++) {
          var val = values[matches[i].substring(2, matches[i].length - 1)] || "";
          if (val != null) {
            fromString = fromString.replace(matches[i], val);
          }
        }
      }
      return fromString;
    };
    var _one = function _one(d) {
      if (d != null) {
        if (isString(d)) {
          return getValue(d);
        } else if (isFunction(d) && !doNotExpandFunctions && (functionPrefix == null || (d.name || "").indexOf(functionPrefix) === 0)) {
          return d(values);
        } else if (Array.isArray(d)) {
          var r = [];
          for (var i = 0; i < d.length; i++) {
            r.push(_one(d[i]));
          }
          return r;
        } else if (isObject(d)) {
          var s = {};
          for (var j in d) {
            s[j] = _one(d[j]);
          }
          return s;
        } else {
          return d;
        }
      }
    };
    return _one(model);
  }
  function forEach(a, f) {
    if (a) {
      for (var i = 0; i < a.length; i++) {
        f(a[i]);
      }
    } else {
      return null;
    }
  }
  function findWithFunction(a, f) {
    if (a) {
      for (var i = 0; i < a.length; i++) {
        if (f(a[i])) {
          return i;
        }
      }
    }
    return -1;
  }
  function findAllWithFunction(a, predicate) {
    var o = [];
    if (a) {
      for (var i = 0; i < a.length; i++) {
        if (predicate(a[i])) {
          o.push(i);
        }
      }
    }
    return o;
  }
  function getWithFunction(a, f) {
    var idx = findWithFunction(a, f);
    return idx === -1 ? null : a[idx];
  }
  function getAllWithFunction(a, f) {
    var indexes = findAllWithFunction(a, f);
    return indexes.map(function (i) {
      return a[i];
    });
  }
  function getFromSetWithFunction(s, f) {
    var out = null;
    s.forEach(function (t) {
      if (f(t)) {
        out = t;
      }
    });
    return out;
  }
  function setToArray(s) {
    var a = [];
    s.forEach(function (t) {
      a.push(t);
    });
    return a;
  }
  function removeWithFunction(a, f) {
    var idx = findWithFunction(a, f);
    if (idx > -1) {
      a.splice(idx, 1);
    }
    return idx !== -1;
  }
  function fromArray(a) {
    if (Array.fromArray != null) {
      return Array.from(a);
    } else {
      var arr = [];
      Array.prototype.push.apply(arr, a);
      return arr;
    }
  }
  function remove(l, v) {
    var idx = l.indexOf(v);
    if (idx > -1) {
      l.splice(idx, 1);
    }
    return idx !== -1;
  }
  function addToDictionary(map, key, value, insertAtStart) {
    var l = map[key];
    if (l == null) {
      l = [];
      map[key] = l;
    }
    l[insertAtStart ? "unshift" : "push"](value);
    return l;
  }
  function suggest(list, item, insertAtHead) {
    if (list.indexOf(item) === -1) {
      if (insertAtHead) {
        list.unshift(item);
      } else {
        list.push(item);
      }
      return true;
    }
    return false;
  }
  var lut = [];
  for (var i = 0; i < 256; i++) {
    lut[i] = (i < 16 ? '0' : '') + i.toString(16);
  }
  function uuid() {
    var d0 = Math.random() * 0xffffffff | 0;
    var d1 = Math.random() * 0xffffffff | 0;
    var d2 = Math.random() * 0xffffffff | 0;
    var d3 = Math.random() * 0xffffffff | 0;
    return lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff] + '-' + lut[d1 & 0xff] + lut[d1 >> 8 & 0xff] + '-' + lut[d1 >> 16 & 0x0f | 0x40] + lut[d1 >> 24 & 0xff] + '-' + lut[d2 & 0x3f | 0x80] + lut[d2 >> 8 & 0xff] + '-' + lut[d2 >> 16 & 0xff] + lut[d2 >> 24 & 0xff] + lut[d3 & 0xff] + lut[d3 >> 8 & 0xff] + lut[d3 >> 16 & 0xff] + lut[d3 >> 24 & 0xff];
  }
  function rotatePoint(point, center, rotation) {
    var radial = {
      x: point.x - center.x,
      y: point.y - center.y
    },
        cr = Math.cos(rotation / 360 * Math.PI * 2),
        sr = Math.sin(rotation / 360 * Math.PI * 2);
    return {
      x: radial.x * cr - radial.y * sr + center.x,
      y: radial.y * cr + radial.x * sr + center.y,
      cr: cr,
      sr: sr
    };
  }
  function rotateAnchorOrientation(orientation, rotation) {
    var r = rotatePoint({
      x: orientation[0],
      y: orientation[1]
    }, {
      x: 0,
      y: 0
    }, rotation);
    return [Math.round(r.x), Math.round(r.y)];
  }
  function fastTrim(s) {
    if (s == null) {
      return null;
    }
    var str = s.replace(/^\s\s*/, ''),
        ws = /\s/,
        i = str.length;
    while (ws.test(str.charAt(--i))) {}
    return str.slice(0, i + 1);
  }
  function each(obj, fn) {
    obj = obj.length == null || typeof obj === "string" ? [obj] : obj;
    for (var _i = 0; _i < obj.length; _i++) {
      fn(obj[_i]);
    }
  }
  function map(obj, fn) {
    var o = [];
    for (var _i2 = 0; _i2 < obj.length; _i2++) {
      o.push(fn(obj[_i2]));
    }
    return o;
  }
  function log() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (typeof console !== "undefined") {
      try {
        var msg = arguments[arguments.length - 1];
        console.log(msg);
      } catch (e) {}
    }
  }
  function sgn(x) {
    return x < 0 ? -1 : x > 0 ? 1 : 0;
  }
  function wrap(wrappedFunction, newFunction, returnOnThisValue) {
    return function () {
      var r = null;
      try {
        if (newFunction != null) {
          r = newFunction.apply(this, arguments);
        }
      } catch (e) {
        log("jsPlumb function failed : " + e);
      }
      if (wrappedFunction != null && (returnOnThisValue == null || r !== returnOnThisValue)) {
        try {
          r = wrappedFunction.apply(this, arguments);
        } catch (e) {
          log("wrapped function failed : " + e);
        }
      }
      return r;
    };
  }
  function getsert(map, key, valueGenerator) {
    if (!map.has(key)) {
      map.set(key, valueGenerator());
    }
    return map.get(key);
  }
  function isAssignableFrom(object, cls) {
    var proto = object.__proto__;
    while (proto != null) {
      if (proto instanceof cls) {
        return true;
      } else {
        proto = proto.__proto__;
      }
    }
    return false;
  }
  function insertSorted(value, array, comparator, sortDescending) {
    if (array.length === 0) {
      array.push(value);
    } else {
      var flip = sortDescending ? -1 : 1;
      var min = 0;
      var max = array.length;
      var index = Math.floor((min + max) / 2);
      while (max > min) {
        var c = comparator(value, array[index]) * flip;
        if (c < 0) {
          max = index;
        } else {
          min = index + 1;
        }
        index = Math.floor((min + max) / 2);
      }
      array.splice(index, 0, value);
    }
  }

  function _classCallCheck$h(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$h(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$h(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$h(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$h(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty$g(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _inherits$b(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf$b(subClass, superClass);
  }

  function _getPrototypeOf$b(o) {
    _getPrototypeOf$b = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$b(o);
  }

  function _setPrototypeOf$b(o, p) {
    _setPrototypeOf$b = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$b(o, p);
  }

  function _isNativeReflectConstruct$b() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _assertThisInitialized$b(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn$b(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized$b(self);
  }

  function _createSuper$b(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$b();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf$b(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$b(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn$b(this, result);
    };
  }

  var EventGenerator = function () {
    function EventGenerator() {
      _classCallCheck$h(this, EventGenerator);
      _defineProperty$g(this, "_listeners", {});
      _defineProperty$g(this, "eventsSuspended", false);
      _defineProperty$g(this, "tick", false);
      _defineProperty$g(this, "eventsToDieOn", {
        "ready": true
      });
      _defineProperty$g(this, "queue", []);
    }
    _createClass$h(EventGenerator, [{
      key: "fire",
      value: function fire(event, value, originalEvent) {
        var ret = null;
        if (!this.tick) {
          this.tick = true;
          if (!this.eventsSuspended && this._listeners[event]) {
            var l = this._listeners[event].length,
                i = 0,
                _gone = false;
            if (!this.shouldFireEvent || this.shouldFireEvent(event, value, originalEvent)) {
              while (!_gone && i < l && ret !== false) {
                if (this.eventsToDieOn[event]) {
                  this._listeners[event][i].apply(this, [value, originalEvent]);
                } else {
                  try {
                    ret = this._listeners[event][i].apply(this, [value, originalEvent]);
                  } catch (e) {
                    log("jsPlumb: fire failed for event " + event + " : " + (e.message || e));
                  }
                }
                i++;
                if (this._listeners == null || this._listeners[event] == null) {
                  _gone = true;
                }
              }
            }
          }
          this.tick = false;
          this._drain();
        } else {
          this.queue.unshift(arguments);
        }
        return ret;
      }
    }, {
      key: "_drain",
      value: function _drain() {
        var n = this.queue.pop();
        if (n) {
          this.fire.apply(this, n);
        }
      }
    }, {
      key: "unbind",
      value: function unbind(eventOrListener, listener) {
        if (arguments.length === 0) {
          this._listeners = {};
        } else if (arguments.length === 1) {
          if (typeof eventOrListener === "string") {
            delete this._listeners[eventOrListener];
          } else if (eventOrListener.__jsPlumb) {
            var evt;
            for (var i in eventOrListener.__jsPlumb) {
              evt = eventOrListener.__jsPlumb[i];
              remove(this._listeners[evt] || [], eventOrListener);
            }
          }
        } else if (arguments.length === 2) {
          remove(this._listeners[eventOrListener] || [], listener);
        }
        return this;
      }
    }, {
      key: "getListener",
      value: function getListener(forEvent) {
        return this._listeners[forEvent] || [];
      }
    }, {
      key: "isSuspendEvents",
      value: function isSuspendEvents() {
        return this.eventsSuspended;
      }
    }, {
      key: "setSuspendEvents",
      value: function setSuspendEvents(val) {
        this.eventsSuspended = val;
      }
    }, {
      key: "bind",
      value: function bind(event, listener, insertAtStart) {
        var _this = this;
        var _one = function _one(evt) {
          addToDictionary(_this._listeners, evt, listener, insertAtStart);
          listener.__jsPlumb = listener.__jsPlumb || {};
          listener.__jsPlumb[uuid()] = evt;
        };
        if (typeof event === "string") {
          _one(event);
        } else if (event.length != null) {
          for (var i = 0; i < event.length; i++) {
            _one(event[i]);
          }
        }
        return this;
      }
    }, {
      key: "silently",
      value: function silently(fn) {
        this.setSuspendEvents(true);
        try {
          fn();
        } catch (e) {
          log("Cannot execute silent function " + e);
        }
        this.setSuspendEvents(false);
      }
    }]);
    return EventGenerator;
  }();
  var OptimisticEventGenerator = function (_EventGenerator) {
    _inherits$b(OptimisticEventGenerator, _EventGenerator);
    var _super = _createSuper$b(OptimisticEventGenerator);
    function OptimisticEventGenerator() {
      _classCallCheck$h(this, OptimisticEventGenerator);
      return _super.apply(this, arguments);
    }
    _createClass$h(OptimisticEventGenerator, [{
      key: "shouldFireEvent",
      value: function shouldFireEvent(event, value, originalEvent) {
        return true;
      }
    }]);
    return OptimisticEventGenerator;
  }(EventGenerator);

  var segmentMultipliers = [null, [1, -1], [1, 1], [-1, 1], [-1, -1]];
  var inverseSegmentMultipliers = [null, [-1, -1], [-1, 1], [1, 1], [1, -1]];
  var TWO_PI = 2 * Math.PI;
  function add(p1, p2) {
    return {
      x: p1.x + p2.x,
      y: p1.y + p2.y
    };
  }
  function subtract(p1, p2) {
    return {
      x: p1.x - p2.x,
      y: p1.y - p2.y
    };
  }
  function gradient(p1, p2) {
    if (p2.x === p1.x) return p2.y > p1.y ? Infinity : -Infinity;else if (p2.y === p1.y) return p2.x > p1.x ? 0 : -0;else return (p2.y - p1.y) / (p2.x - p1.x);
  }
  function normal(p1, p2) {
    return -1 / gradient(p1, p2);
  }
  function lineLength(p1, p2) {
    return Math.sqrt(Math.pow(p2.y - p1.y, 2) + Math.pow(p2.x - p1.x, 2));
  }
  function quadrant(p1, p2) {
    if (p2.x > p1.x) {
      return p2.y > p1.y ? 2 : 1;
    } else if (p2.x == p1.x) {
      return p2.y > p1.y ? 2 : 1;
    } else {
      return p2.y > p1.y ? 3 : 4;
    }
  }
  function theta(p1, p2) {
    var m = gradient(p1, p2),
        t = Math.atan(m),
        s = quadrant(p1, p2);
    if (s == 4 || s == 3) t += Math.PI;
    if (t < 0) t += 2 * Math.PI;
    return t;
  }
  function intersects(r1, r2) {
    var x1 = r1.x,
        x2 = r1.x + r1.w,
        y1 = r1.y,
        y2 = r1.y + r1.h,
        a1 = r2.x,
        a2 = r2.x + r2.w,
        b1 = r2.y,
        b2 = r2.y + r2.h;
    return x1 <= a1 && a1 <= x2 && y1 <= b1 && b1 <= y2 || x1 <= a2 && a2 <= x2 && y1 <= b1 && b1 <= y2 || x1 <= a1 && a1 <= x2 && y1 <= b2 && b2 <= y2 || x1 <= a2 && a1 <= x2 && y1 <= b2 && b2 <= y2 || a1 <= x1 && x1 <= a2 && b1 <= y1 && y1 <= b2 || a1 <= x2 && x2 <= a2 && b1 <= y1 && y1 <= b2 || a1 <= x1 && x1 <= a2 && b1 <= y2 && y2 <= b2 || a1 <= x2 && x1 <= a2 && b1 <= y2 && y2 <= b2;
  }
  function toABC(line) {
    var A = line[1].y - line[0].y;
    var B = line[0].x - line[1].x;
    return {
      A: A,
      B: B,
      C: A * line[0].x + B * line[0].y
    };
  }
  function lineIntersection(l1, l2) {
    var abc1 = toABC(l1),
        abc2 = toABC(l2),
        det = abc1.A * abc2.B - abc2.A * abc1.B;
    if (det == 0) {
      return null;
    } else {
      var candidate = {
        x: (abc2.B * abc1.C - abc1.B * abc2.C) / det,
        y: (abc1.A * abc2.C - abc2.A * abc1.C) / det
      },
          l1xmin = Math.min(l1[0].x, l1[1].x),
          l1xmax = Math.max(l1[0].x, l1[1].x),
          l1ymin = Math.min(l1[0].y, l1[1].y),
          l1ymax = Math.max(l1[0].y, l1[1].y),
          l2xmin = Math.min(l2[0].x, l2[1].x),
          l2xmax = Math.max(l2[0].x, l2[1].x),
          l2ymin = Math.min(l2[0].y, l2[1].y),
          l2ymax = Math.max(l2[0].y, l2[1].y);
      if (candidate.x >= l1xmin && candidate.x <= l1xmax && candidate.y >= l1ymin && candidate.y <= l1ymax && candidate.x >= l2xmin && candidate.x <= l2xmax && candidate.y >= l2ymin && candidate.y <= l2ymax) {
        return candidate;
      } else {
        return null;
      }
    }
  }
  function lineRectangleIntersection(line, r) {
    var out = [],
        rectangleLines = [[{
      x: r.x,
      y: r.y
    }, {
      x: r.x + r.w,
      y: r.y
    }], [{
      x: r.x + r.w,
      y: r.y
    }, {
      x: r.x + r.w,
      y: r.y + r.h
    }], [{
      x: r.x,
      y: r.y
    }, {
      x: r.x,
      y: r.y + r.h
    }], [{
      x: r.x,
      y: r.y + r.h
    }, {
      x: r.x + r.w,
      y: r.y + r.h
    }]];
    forEach(rectangleLines, function (rLine) {
      var intersection = lineIntersection(line, rLine);
      if (intersection != null) {
        out.push(intersection);
      }
    });
    return out;
  }
  function encloses(r1, r2, allowSharedEdges) {
    var x1 = r1.x,
        x2 = r1.x + r1.w,
        y1 = r1.y,
        y2 = r1.y + r1.h,
        a1 = r2.x,
        a2 = r2.x + r2.w,
        b1 = r2.y,
        b2 = r2.y + r2.h,
        c = function c(v1, v2, v3, v4) {
      return allowSharedEdges ? v1 <= v2 && v3 >= v4 : v1 < v2 && v3 > v4;
    };
    return c(x1, a1, x2, a2) && c(y1, b1, y2, b2);
  }
  function pointOnLine(fromPoint, toPoint, distance) {
    var m = gradient(fromPoint, toPoint),
        s = quadrant(fromPoint, toPoint),
        segmentMultiplier = distance > 0 ? segmentMultipliers[s] : inverseSegmentMultipliers[s],
        theta = Math.atan(m),
        y = Math.abs(distance * Math.sin(theta)) * segmentMultiplier[1],
        x = Math.abs(distance * Math.cos(theta)) * segmentMultiplier[0];
    return {
      x: fromPoint.x + x,
      y: fromPoint.y + y
    };
  }
  function perpendicularLineTo(fromPoint, toPoint, length) {
    var m = gradient(fromPoint, toPoint),
        theta2 = Math.atan(-1 / m),
        y = length / 2 * Math.sin(theta2),
        x = length / 2 * Math.cos(theta2);
    return [{
      x: toPoint.x + x,
      y: toPoint.y + y
    }, {
      x: toPoint.x - x,
      y: toPoint.y - y
    }];
  }
  function snapToGrid(pos, grid, thresholdX, thresholdY) {
    thresholdX = thresholdX == null ? grid.thresholdX == null ? grid.w / 2 : grid.thresholdX : thresholdX;
    thresholdY = thresholdY == null ? grid.thresholdY == null ? grid.h / 2 : grid.thresholdY : thresholdY;
    var _dx = Math.floor(pos.x / grid.w),
        _dxl = grid.w * _dx,
        _dxt = _dxl + grid.w,
        x = Math.abs(pos.x - _dxl) <= thresholdX ? _dxl : Math.abs(_dxt - pos.x) <= thresholdX ? _dxt : pos.x;
    var _dy = Math.floor(pos.y / grid.h),
        _dyl = grid.h * _dy,
        _dyt = _dyl + grid.h,
        y = Math.abs(pos.y - _dyl) <= thresholdY ? _dyl : Math.abs(_dyt - pos.y) <= thresholdY ? _dyt : pos.y;
    return {
      x: x,
      y: y
    };
  }

  var PerimeterAnchorShapes;
  (function (PerimeterAnchorShapes) {
    PerimeterAnchorShapes["Circle"] = "Circle";
    PerimeterAnchorShapes["Ellipse"] = "Ellipse";
    PerimeterAnchorShapes["Triangle"] = "Triangle";
    PerimeterAnchorShapes["Diamond"] = "Diamond";
    PerimeterAnchorShapes["Rectangle"] = "Rectangle";
    PerimeterAnchorShapes["Square"] = "Square";
  })(PerimeterAnchorShapes || (PerimeterAnchorShapes = {}));
  var AnchorLocations;
  (function (AnchorLocations) {
    AnchorLocations["Assign"] = "Assign";
    AnchorLocations["AutoDefault"] = "AutoDefault";
    AnchorLocations["Bottom"] = "Bottom";
    AnchorLocations["BottomLeft"] = "BottomLeft";
    AnchorLocations["BottomRight"] = "BottomRight";
    AnchorLocations["Center"] = "Center";
    AnchorLocations["Continuous"] = "Continuous";
    AnchorLocations["ContinuousBottom"] = "ContinuousBottom";
    AnchorLocations["ContinuousLeft"] = "ContinuousLeft";
    AnchorLocations["ContinuousRight"] = "ContinuousRight";
    AnchorLocations["ContinuousTop"] = "ContinuousTop";
    AnchorLocations["ContinuousLeftRight"] = "ContinuousLeftRight";
    AnchorLocations["ContinuousTopBottom"] = "ContinuousTopBottom";
    AnchorLocations["Left"] = "Left";
    AnchorLocations["Perimeter"] = "Perimeter";
    AnchorLocations["Right"] = "Right";
    AnchorLocations["Top"] = "Top";
    AnchorLocations["TopLeft"] = "TopLeft";
    AnchorLocations["TopRight"] = "TopRight";
  })(AnchorLocations || (AnchorLocations = {}));

  function _classCallCheck$g(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$g(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$g(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$g(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$g(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty$f(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function noSuchPoint() {
    return {
      d: Infinity,
      x: null,
      y: null,
      l: null,
      x1: null,
      y1: null,
      x2: null,
      y2: null
    };
  }
  function EMPTY_BOUNDS() {
    return {
      xmin: Infinity,
      xmax: -Infinity,
      ymin: Infinity,
      ymax: -Infinity
    };
  }
  var AbstractSegment = function () {
    function AbstractSegment(params) {
      _classCallCheck$g(this, AbstractSegment);
      this.params = params;
      _defineProperty$f(this, "x1", void 0);
      _defineProperty$f(this, "x2", void 0);
      _defineProperty$f(this, "y1", void 0);
      _defineProperty$f(this, "y2", void 0);
      _defineProperty$f(this, "extents", EMPTY_BOUNDS());
      _defineProperty$f(this, "type", void 0);
      this.x1 = params.x1;
      this.y1 = params.y1;
      this.x2 = params.x2;
      this.y2 = params.y2;
    }
    _createClass$g(AbstractSegment, [{
      key: "findClosestPointOnPath",
      value: function findClosestPointOnPath(x, y) {
        return noSuchPoint();
      }
    }, {
      key: "lineIntersection",
      value: function lineIntersection(x1, y1, x2, y2) {
        return [];
      }
    }, {
      key: "boxIntersection",
      value: function boxIntersection(x, y, w, h) {
        var a = [];
        a.push.apply(a, this.lineIntersection(x, y, x + w, y));
        a.push.apply(a, this.lineIntersection(x + w, y, x + w, y + h));
        a.push.apply(a, this.lineIntersection(x + w, y + h, x, y + h));
        a.push.apply(a, this.lineIntersection(x, y + h, x, y));
        return a;
      }
    }, {
      key: "boundingBoxIntersection",
      value: function boundingBoxIntersection(box) {
        return this.boxIntersection(box.x, box.y, box.w, box.h);
      }
    }]);
    return AbstractSegment;
  }();

  var UNDEFINED = "undefined";
  var DEFAULT$1 = "default";
  var TRUE$1 = "true";
  var FALSE$1 = "false";
  var WILDCARD = "*";

  function _classCallCheck$f(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$f(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$f(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$f(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$f(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty$e(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _inherits$a(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf$a(subClass, superClass);
  }

  function _getPrototypeOf$a(o) {
    _getPrototypeOf$a = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$a(o);
  }

  function _setPrototypeOf$a(o, p) {
    _setPrototypeOf$a = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$a(o, p);
  }

  function _isNativeReflectConstruct$a() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _assertThisInitialized$a(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn$a(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized$a(self);
  }

  function _createSuper$a(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$a();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf$a(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$a(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn$a(this, result);
    };
  }

  function _superPropBase$4(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf$a(object);
      if (object === null) break;
    }

    return object;
  }

  function _get$4(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get$4 = Reflect.get;
    } else {
      _get$4 = function _get(target, property, receiver) {
        var base = _superPropBase$4(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };
    }

    return _get$4(target, property, receiver || target);
  }

  function _slicedToArray$4(arr, i) {
    return _arrayWithHoles$4(arr) || _iterableToArrayLimit$4(arr, i) || _unsupportedIterableToArray$4(arr, i) || _nonIterableRest$4();
  }

  function _toConsumableArray$2(arr) {
    return _arrayWithoutHoles$2(arr) || _iterableToArray$2(arr) || _unsupportedIterableToArray$4(arr) || _nonIterableSpread$2();
  }

  function _arrayWithoutHoles$2(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray$4(arr);
  }

  function _arrayWithHoles$4(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray$2(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }

  function _iterableToArrayLimit$4(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;

    var _s, _e;

    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray$4(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray$4(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(o, minLen);
  }

  function _arrayLikeToArray$4(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread$2() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _nonIterableRest$4() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var endpointMap$1 = {};
  var endpointComputers = {};
  var handlers = {};
  var EndpointFactory = {
    get: function get(ep, name, params) {
      var e = endpointMap$1[name];
      if (!e) {
        throw {
          message: "jsPlumb: unknown endpoint type '" + name + "'"
        };
      } else {
        return new e(ep, params);
      }
    },
    clone: function clone(epr) {
      var handler = handlers[epr.type];
      return EndpointFactory.get(epr.endpoint, epr.type, handler.getParams(epr));
    },
    compute: function compute(endpoint, anchorPoint, orientation, endpointStyle) {
      var c = endpointComputers[endpoint.type];
      if (c != null) {
        return c(endpoint, anchorPoint, orientation, endpointStyle);
      } else {
        log("jsPlumb: cannot find endpoint calculator for endpoint of type ", endpoint.type);
      }
    },
    registerHandler: function registerHandler(eph) {
      handlers[eph.type] = eph;
      endpointMap$1[eph.type] = eph.cls;
      endpointComputers[eph.type] = eph.compute;
    }
  };

  var EndpointRepresentation = function () {
    function EndpointRepresentation(endpoint, params) {
      _classCallCheck$f(this, EndpointRepresentation);
      this.endpoint = endpoint;
      _defineProperty$e(this, "typeId", void 0);
      _defineProperty$e(this, "x", void 0);
      _defineProperty$e(this, "y", void 0);
      _defineProperty$e(this, "w", void 0);
      _defineProperty$e(this, "h", void 0);
      _defineProperty$e(this, "computedValue", void 0);
      _defineProperty$e(this, "bounds", EMPTY_BOUNDS());
      _defineProperty$e(this, "classes", []);
      _defineProperty$e(this, "instance", void 0);
      _defineProperty$e(this, "type", void 0);
      params = params || {};
      this.instance = endpoint.instance;
      if (endpoint.cssClass) {
        this.classes.push(endpoint.cssClass);
      }
      if (params.cssClass) {
        this.classes.push(params.cssClass);
      }
    }
    _createClass$f(EndpointRepresentation, [{
      key: "addClass",
      value: function addClass(c) {
        this.classes.push(c);
        this.instance.addEndpointClass(this.endpoint, c);
      }
    }, {
      key: "removeClass",
      value: function removeClass(c) {
        this.classes = this.classes.filter(function (_c) {
          return _c !== c;
        });
        this.instance.removeEndpointClass(this.endpoint, c);
      }
    }, {
      key: "compute",
      value: function compute(anchorPoint, orientation, endpointStyle) {
        this.computedValue = EndpointFactory.compute(this, anchorPoint, orientation, endpointStyle);
        this.bounds.xmin = this.x;
        this.bounds.ymin = this.y;
        this.bounds.xmax = this.x + this.w;
        this.bounds.ymax = this.y + this.h;
      }
    }, {
      key: "setVisible",
      value: function setVisible(v) {
        this.instance.setEndpointVisible(this.endpoint, v);
      }
    }]);
    return EndpointRepresentation;
  }();

  var DotEndpoint = function (_EndpointRepresentati) {
    _inherits$a(DotEndpoint, _EndpointRepresentati);
    var _super = _createSuper$a(DotEndpoint);
    function DotEndpoint(endpoint, params) {
      var _this;
      _classCallCheck$f(this, DotEndpoint);
      _this = _super.call(this, endpoint, params);
      _defineProperty$e(_assertThisInitialized$a(_this), "radius", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "defaultOffset", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "defaultInnerRadius", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "type", DotEndpoint.type);
      params = params || {};
      _this.radius = params.radius || 5;
      _this.defaultOffset = 0.5 * _this.radius;
      _this.defaultInnerRadius = _this.radius / 3;
      return _this;
    }
    return DotEndpoint;
  }(EndpointRepresentation);
  _defineProperty$e(DotEndpoint, "type", "Dot");
  var DotEndpointHandler = {
    type: DotEndpoint.type,
    cls: DotEndpoint,
    compute: function compute(ep, anchorPoint, orientation, endpointStyle) {
      var x = anchorPoint.curX - ep.radius,
          y = anchorPoint.curY - ep.radius,
          w = ep.radius * 2,
          h = ep.radius * 2;
      if (endpointStyle && endpointStyle.stroke) {
        var lw = endpointStyle.strokeWidth || 1;
        x -= lw;
        y -= lw;
        w += lw * 2;
        h += lw * 2;
      }
      ep.x = x;
      ep.y = y;
      ep.w = w;
      ep.h = h;
      return [x, y, w, h, ep.radius];
    },
    getParams: function getParams(ep) {
      return {
        radius: ep.radius
      };
    }
  };

  var BlankEndpoint = function (_EndpointRepresentati) {
    _inherits$a(BlankEndpoint, _EndpointRepresentati);
    var _super = _createSuper$a(BlankEndpoint);
    function BlankEndpoint(endpoint, params) {
      var _this;
      _classCallCheck$f(this, BlankEndpoint);
      _this = _super.call(this, endpoint, params);
      _defineProperty$e(_assertThisInitialized$a(_this), "type", BlankEndpoint.type);
      return _this;
    }
    return BlankEndpoint;
  }(EndpointRepresentation);
  _defineProperty$e(BlankEndpoint, "type", "Blank");
  var BlankEndpointHandler = {
    type: BlankEndpoint.type,
    cls: BlankEndpoint,
    compute: function compute(ep, anchorPoint, orientation, endpointStyle) {
      ep.x = anchorPoint.curX;
      ep.y = anchorPoint.curY;
      ep.w = 10;
      ep.h = 0;
      return [anchorPoint.curX, anchorPoint.curY, 10, 0];
    },
    getParams: function getParams(ep) {
      return {};
    }
  };

  var RectangleEndpoint = function (_EndpointRepresentati) {
    _inherits$a(RectangleEndpoint, _EndpointRepresentati);
    var _super = _createSuper$a(RectangleEndpoint);
    function RectangleEndpoint(endpoint, params) {
      var _this;
      _classCallCheck$f(this, RectangleEndpoint);
      _this = _super.call(this, endpoint, params);
      _defineProperty$e(_assertThisInitialized$a(_this), "width", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "height", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "type", RectangleEndpoint.type);
      params = params || {};
      _this.width = params.width || 10;
      _this.height = params.height || 10;
      return _this;
    }
    _createClass$f(RectangleEndpoint, null, [{
      key: "_getParams",
      value: function _getParams(ep) {
        return {
          width: ep.width,
          height: ep.height
        };
      }
    }]);
    return RectangleEndpoint;
  }(EndpointRepresentation);
  _defineProperty$e(RectangleEndpoint, "type", "Rectangle");
  var RectangleEndpointHandler = {
    type: RectangleEndpoint.type,
    cls: RectangleEndpoint,
    compute: function compute(ep, anchorPoint, orientation, endpointStyle) {
      var width = endpointStyle.width || ep.width,
          height = endpointStyle.height || ep.height,
          x = anchorPoint.curX - width / 2,
          y = anchorPoint.curY - height / 2;
      ep.x = x;
      ep.y = y;
      ep.w = width;
      ep.h = height;
      return [x, y, width, height];
    },
    getParams: function getParams(ep) {
      return {
        width: ep.width,
        height: ep.height
      };
    }
  };

  var AbstractConnector = function () {
    function AbstractConnector(connection, params) {
      _classCallCheck$f(this, AbstractConnector);
      this.connection = connection;
      _defineProperty$e(this, "type", void 0);
      _defineProperty$e(this, "edited", false);
      _defineProperty$e(this, "stub", void 0);
      _defineProperty$e(this, "sourceStub", void 0);
      _defineProperty$e(this, "targetStub", void 0);
      _defineProperty$e(this, "maxStub", void 0);
      _defineProperty$e(this, "typeId", void 0);
      _defineProperty$e(this, "gap", void 0);
      _defineProperty$e(this, "sourceGap", void 0);
      _defineProperty$e(this, "targetGap", void 0);
      _defineProperty$e(this, "segments", []);
      _defineProperty$e(this, "totalLength", 0);
      _defineProperty$e(this, "segmentProportions", []);
      _defineProperty$e(this, "segmentProportionalLengths", []);
      _defineProperty$e(this, "paintInfo", null);
      _defineProperty$e(this, "strokeWidth", void 0);
      _defineProperty$e(this, "x", void 0);
      _defineProperty$e(this, "y", void 0);
      _defineProperty$e(this, "w", void 0);
      _defineProperty$e(this, "h", void 0);
      _defineProperty$e(this, "segment", void 0);
      _defineProperty$e(this, "bounds", EMPTY_BOUNDS());
      _defineProperty$e(this, "cssClass", void 0);
      _defineProperty$e(this, "hoverClass", void 0);
      _defineProperty$e(this, "geometry", void 0);
      this.stub = params.stub || this.getDefaultStubs();
      this.sourceStub = Array.isArray(this.stub) ? this.stub[0] : this.stub;
      this.targetStub = Array.isArray(this.stub) ? this.stub[1] : this.stub;
      this.gap = params.gap || 0;
      this.sourceGap = Array.isArray(this.gap) ? this.gap[0] : this.gap;
      this.targetGap = Array.isArray(this.gap) ? this.gap[1] : this.gap;
      this.maxStub = Math.max(this.sourceStub, this.targetStub);
      this.cssClass = params.cssClass || "";
      this.hoverClass = params.hoverClass || "";
    }
    _createClass$f(AbstractConnector, [{
      key: "getTypeDescriptor",
      value: function getTypeDescriptor() {
        return "connector";
      }
    }, {
      key: "getIdPrefix",
      value: function getIdPrefix() {
        return "_jsplumb_connector";
      }
    }, {
      key: "setGeometry",
      value: function setGeometry(g, internal) {
        this.geometry = g;
        this.edited = g != null && !internal;
      }
    }, {
      key: "exportGeometry",
      value: function exportGeometry() {
        return this.geometry;
      }
    }, {
      key: "importGeometry",
      value: function importGeometry(g) {
        this.geometry = g;
        return true;
      }
    }, {
      key: "resetGeometry",
      value: function resetGeometry() {
        this.geometry = null;
        this.edited = false;
      }
    }, {
      key: "transformAnchorPlacement",
      value:
      function transformAnchorPlacement(a, dx, dy) {
        return {
          x: a.x,
          y: a.y,
          ox: a.ox,
          oy: a.oy,
          curX: a.curX + dx,
          curY: a.curY + dy
        };
      }
    }, {
      key: "resetBounds",
      value: function resetBounds() {
        this.bounds = EMPTY_BOUNDS();
      }
    }, {
      key: "findSegmentForPoint",
      value: function findSegmentForPoint(x, y) {
        var out = {
          d: Infinity,
          s: null,
          x: null,
          y: null,
          l: null,
          x1: null,
          y1: null,
          x2: null,
          y2: null,
          index: null,
          connectorLocation: null
        };
        for (var i = 0; i < this.segments.length; i++) {
          var _s = this.segments[i].findClosestPointOnPath(x, y);
          if (_s.d < out.d) {
            out.d = _s.d;
            out.l = _s.l;
            out.x = _s.x;
            out.y = _s.y;
            out.s = this.segments[i];
            out.x1 = _s.x1;
            out.x2 = _s.x2;
            out.y1 = _s.y1;
            out.y2 = _s.y2;
            out.index = i;
            out.connectorLocation = this.segmentProportions[i][0] + _s.l * (this.segmentProportions[i][1] - this.segmentProportions[i][0]);
          }
        }
        return out;
      }
    }, {
      key: "lineIntersection",
      value: function lineIntersection(x1, y1, x2, y2) {
        var out = [];
        for (var i = 0; i < this.segments.length; i++) {
          out.push.apply(out, this.segments[i].lineIntersection(x1, y1, x2, y2));
        }
        return out;
      }
    }, {
      key: "boxIntersection",
      value: function boxIntersection(x, y, w, h) {
        var out = [];
        for (var i = 0; i < this.segments.length; i++) {
          out.push.apply(out, this.segments[i].boxIntersection(x, y, w, h));
        }
        return out;
      }
    }, {
      key: "boundingBoxIntersection",
      value: function boundingBoxIntersection(box) {
        var out = [];
        for (var i = 0; i < this.segments.length; i++) {
          out.push.apply(out, this.segments[i].boundingBoxIntersection(box));
        }
        return out;
      }
    }, {
      key: "_updateSegmentProportions",
      value: function _updateSegmentProportions() {
        var curLoc = 0;
        for (var i = 0; i < this.segments.length; i++) {
          var sl = this.segments[i].getLength();
          this.segmentProportionalLengths[i] = sl / this.totalLength;
          this.segmentProportions[i] = [curLoc, curLoc += sl / this.totalLength];
        }
      }
    }, {
      key: "_findSegmentForLocation",
      value: function _findSegmentForLocation(location, absolute) {
        var idx, i, inSegmentProportion;
        if (absolute) {
          location = location > 0 ? location / this.totalLength : (this.totalLength + location) / this.totalLength;
        }
        if (location === 1) {
          idx = this.segments.length - 1;
          inSegmentProportion = 1;
        } else if (location === 0) {
          inSegmentProportion = 0;
          idx = 0;
        } else {
          if (location >= 0.5) {
            idx = 0;
            inSegmentProportion = 0;
            for (i = this.segmentProportions.length - 1; i > -1; i--) {
              if (this.segmentProportions[i][1] >= location && this.segmentProportions[i][0] <= location) {
                idx = i;
                inSegmentProportion = (location - this.segmentProportions[i][0]) / this.segmentProportionalLengths[i];
                break;
              }
            }
          } else {
            idx = this.segmentProportions.length - 1;
            inSegmentProportion = 1;
            for (i = 0; i < this.segmentProportions.length; i++) {
              if (this.segmentProportions[i][1] >= location) {
                idx = i;
                inSegmentProportion = (location - this.segmentProportions[i][0]) / this.segmentProportionalLengths[i];
                break;
              }
            }
          }
        }
        return {
          segment: this.segments[idx],
          proportion: inSegmentProportion,
          index: idx
        };
      }
    }, {
      key: "_addSegment",
      value: function _addSegment(clazz, params) {
        if (params.x1 === params.x2 && params.y1 === params.y2) {
          return;
        }
        var s = new clazz(params);
        this.segments.push(s);
        this.totalLength += s.getLength();
        this.updateBounds(s);
      }
    }, {
      key: "_clearSegments",
      value: function _clearSegments() {
        this.totalLength = 0;
        this.segments.length = 0;
        this.segmentProportions.length = 0;
        this.segmentProportionalLengths.length = 0;
      }
    }, {
      key: "getLength",
      value: function getLength() {
        return this.totalLength;
      }
    }, {
      key: "_prepareCompute",
      value: function _prepareCompute(params) {
        this.strokeWidth = params.strokeWidth;
        var x1 = params.sourcePos.curX,
            x2 = params.targetPos.curX,
            y1 = params.sourcePos.curY,
            y2 = params.targetPos.curY,
            segment = quadrant({
          x: x1,
          y: y1
        }, {
          x: x2,
          y: y2
        }),
            swapX = x2 < x1,
            swapY = y2 < y1,
            so = [params.sourcePos.ox, params.sourcePos.oy],
            to = [params.targetPos.ox, params.targetPos.oy],
            x = swapX ? x2 : x1,
            y = swapY ? y2 : y1,
            w = Math.abs(x2 - x1),
            h = Math.abs(y2 - y1);
        var noSourceOrientation = so[0] === 0 && so[1] === 0;
        var noTargetOrientation = to[0] === 0 && to[1] === 0;
        if (noSourceOrientation || noTargetOrientation) {
          var index = w > h ? 0 : 1,
              oIndex = [1, 0][index],
              v1 = index === 0 ? x1 : y1,
              v2 = index === 0 ? x2 : y2;
          if (noSourceOrientation) {
            so[index] = v1 > v2 ? -1 : 1;
            so[oIndex] = 0;
          }
          if (noTargetOrientation) {
            to[index] = v1 > v2 ? 1 : -1;
            to[oIndex] = 0;
          }
        }
        var sx = swapX ? w + this.sourceGap * so[0] : this.sourceGap * so[0],
            sy = swapY ? h + this.sourceGap * so[1] : this.sourceGap * so[1],
            tx = swapX ? this.targetGap * to[0] : w + this.targetGap * to[0],
            ty = swapY ? this.targetGap * to[1] : h + this.targetGap * to[1],
            oProduct = so[0] * to[0] + so[1] * to[1];
        var result = {
          sx: sx,
          sy: sy,
          tx: tx,
          ty: ty,
          xSpan: Math.abs(tx - sx),
          ySpan: Math.abs(ty - sy),
          mx: (sx + tx) / 2,
          my: (sy + ty) / 2,
          so: so,
          to: to,
          x: x,
          y: y,
          w: w,
          h: h,
          segment: segment,
          startStubX: sx + so[0] * this.sourceStub,
          startStubY: sy + so[1] * this.sourceStub,
          endStubX: tx + to[0] * this.targetStub,
          endStubY: ty + to[1] * this.targetStub,
          isXGreaterThanStubTimes2: Math.abs(sx - tx) > this.sourceStub + this.targetStub,
          isYGreaterThanStubTimes2: Math.abs(sy - ty) > this.sourceStub + this.targetStub,
          opposite: oProduct === -1,
          perpendicular: oProduct === 0,
          orthogonal: oProduct === 1,
          sourceAxis: so[0] === 0 ? "y" : "x",
          points: [x, y, w, h, sx, sy, tx, ty],
          stubs: [this.sourceStub, this.targetStub]
        };
        result.anchorOrientation = result.opposite ? "opposite" : result.orthogonal ? "orthogonal" : "perpendicular";
        return result;
      }
    }, {
      key: "updateBounds",
      value: function updateBounds(segment) {
        var segBounds = segment.extents;
        this.bounds.xmin = Math.min(this.bounds.xmin, segBounds.xmin);
        this.bounds.xmax = Math.max(this.bounds.xmax, segBounds.xmax);
        this.bounds.ymin = Math.min(this.bounds.ymin, segBounds.ymin);
        this.bounds.ymax = Math.max(this.bounds.ymax, segBounds.ymax);
      }
    }, {
      key: "dumpSegmentsToConsole",
      value: function dumpSegmentsToConsole() {
        log("SEGMENTS:");
        for (var i = 0; i < this.segments.length; i++) {
          log(this.segments[i].type, "" + this.segments[i].getLength(), "" + this.segmentProportions[i]);
        }
      }
    }, {
      key: "pointOnPath",
      value: function pointOnPath(location, absolute) {
        var seg = this._findSegmentForLocation(location, absolute);
        return seg.segment && seg.segment.pointOnPath(seg.proportion, false) || {
          x: 0,
          y: 0
        };
      }
    }, {
      key: "gradientAtPoint",
      value: function gradientAtPoint(location, absolute) {
        var seg = this._findSegmentForLocation(location, absolute);
        return seg.segment && seg.segment.gradientAtPoint(seg.proportion, false) || 0;
      }
    }, {
      key: "pointAlongPathFrom",
      value: function pointAlongPathFrom(location, distance, absolute) {
        var seg = this._findSegmentForLocation(location, absolute);
        return seg.segment && seg.segment.pointAlongPathFrom(seg.proportion, distance, false) || {
          x: 0,
          y: 0
        };
      }
    }, {
      key: "compute",
      value: function compute(params) {
        this.paintInfo = this._prepareCompute(params);
        this._clearSegments();
        this._compute(this.paintInfo, params);
        this.x = this.paintInfo.points[0];
        this.y = this.paintInfo.points[1];
        this.w = this.paintInfo.points[2];
        this.h = this.paintInfo.points[3];
        this.segment = this.paintInfo.segment;
        this._updateSegmentProportions();
      }
    }, {
      key: "setAnchorOrientation",
      value: function setAnchorOrientation(idx, orientation) {}
    }]);
    return AbstractConnector;
  }();

  var StraightSegment = function (_AbstractSegment) {
    _inherits$a(StraightSegment, _AbstractSegment);
    var _super = _createSuper$a(StraightSegment);
    function StraightSegment(params) {
      var _this;
      _classCallCheck$f(this, StraightSegment);
      _this = _super.call(this, params);
      _defineProperty$e(_assertThisInitialized$a(_this), "length", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "m", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "m2", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "type", StraightSegment.segmentType);
      _this._setCoordinates({
        x1: params.x1,
        y1: params.y1,
        x2: params.x2,
        y2: params.y2
      });
      return _this;
    }
    _createClass$f(StraightSegment, [{
      key: "getPath",
      value: function getPath(isFirstSegment) {
        return (isFirstSegment ? "M " + this.x1 + " " + this.y1 + " " : "") + "L " + this.x2 + " " + this.y2;
      }
    }, {
      key: "_recalc",
      value: function _recalc() {
        this.length = Math.sqrt(Math.pow(this.x2 - this.x1, 2) + Math.pow(this.y2 - this.y1, 2));
        this.m = gradient({
          x: this.x1,
          y: this.y1
        }, {
          x: this.x2,
          y: this.y2
        });
        this.m2 = -1 / this.m;
        this.extents = {
          xmin: Math.min(this.x1, this.x2),
          ymin: Math.min(this.y1, this.y2),
          xmax: Math.max(this.x1, this.x2),
          ymax: Math.max(this.y1, this.y2)
        };
      }
    }, {
      key: "getLength",
      value: function getLength() {
        return this.length;
      }
    }, {
      key: "getGradient",
      value: function getGradient() {
        return this.m;
      }
    }, {
      key: "_setCoordinates",
      value: function _setCoordinates(coords) {
        this.x1 = coords.x1;
        this.y1 = coords.y1;
        this.x2 = coords.x2;
        this.y2 = coords.y2;
        this._recalc();
      }
    }, {
      key: "pointOnPath",
      value: function pointOnPath(location, absolute) {
        if (location === 0 && !absolute) {
          return {
            x: this.x1,
            y: this.y1
          };
        } else if (location === 1 && !absolute) {
          return {
            x: this.x2,
            y: this.y2
          };
        } else {
          var l = absolute ? location > 0 ? location : this.length + location : location * this.length;
          return pointOnLine({
            x: this.x1,
            y: this.y1
          }, {
            x: this.x2,
            y: this.y2
          }, l);
        }
      }
    }, {
      key: "gradientAtPoint",
      value: function gradientAtPoint(location, absolute) {
        return this.m;
      }
    }, {
      key: "pointAlongPathFrom",
      value: function pointAlongPathFrom(location, distance, absolute) {
        var p = this.pointOnPath(location, absolute),
            farAwayPoint = distance <= 0 ? {
          x: this.x1,
          y: this.y1
        } : {
          x: this.x2,
          y: this.y2
        };
        if (distance <= 0 && Math.abs(distance) > 1) {
          distance *= -1;
        }
        return pointOnLine(p, farAwayPoint, distance);
      }
    }, {
      key: "within",
      value: function within(a, b, c) {
        return c >= Math.min(a, b) && c <= Math.max(a, b);
      }
    }, {
      key: "closest",
      value: function closest(a, b, c) {
        return Math.abs(c - a) < Math.abs(c - b) ? a : b;
      }
    }, {
      key: "findClosestPointOnPath",
      value: function findClosestPointOnPath(x, y) {
        var out = {
          d: Infinity,
          x: null,
          y: null,
          l: null,
          x1: this.x1,
          x2: this.x2,
          y1: this.y1,
          y2: this.y2
        };
        if (this.m === 0) {
          out.y = this.y1;
          out.x = this.within(this.x1, this.x2, x) ? x : this.closest(this.x1, this.x2, x);
        } else if (this.m === Infinity || this.m === -Infinity) {
          out.x = this.x1;
          out.y = this.within(this.y1, this.y2, y) ? y : this.closest(this.y1, this.y2, y);
        } else {
          var b = this.y1 - this.m * this.x1,
              b2 = y - this.m2 * x,
          _x1 = (b2 - b) / (this.m - this.m2),
              _y1 = this.m * _x1 + b;
          out.x = this.within(this.x1, this.x2, _x1) ? _x1 : this.closest(this.x1, this.x2, _x1);
          out.y = this.within(this.y1, this.y2, _y1) ? _y1 : this.closest(this.y1, this.y2, _y1);
        }
        var fractionInSegment = lineLength({
          x: out.x,
          y: out.y
        }, {
          x: this.x1,
          y: this.y1
        });
        out.d = lineLength({
          x: x,
          y: y
        }, out);
        out.l = fractionInSegment / length;
        return out;
      }
    }, {
      key: "_pointLiesBetween",
      value: function _pointLiesBetween(q, p1, p2) {
        return p2 > p1 ? p1 <= q && q <= p2 : p1 >= q && q >= p2;
      }
    }, {
      key: "lineIntersection",
      value: function lineIntersection(_x1, _y1, _x2, _y2) {
        var m2 = Math.abs(gradient({
          x: _x1,
          y: _y1
        }, {
          x: _x2,
          y: _y2
        })),
            m1 = Math.abs(this.m),
            b = m1 === Infinity ? this.x1 : this.y1 - m1 * this.x1,
            out = [],
            b2 = m2 === Infinity ? _x1 : _y1 - m2 * _x1;
        if (m2 !== m1) {
          if (m2 === Infinity && m1 === 0) {
            if (this._pointLiesBetween(_x1, this.x1, this.x2) && this._pointLiesBetween(this.y1, _y1, _y2)) {
              out.push({
                x: _x1,
                y: this.y1
              });
            }
          } else if (m2 === 0 && m1 === Infinity) {
            if (this._pointLiesBetween(_y1, this.y1, this.y2) && this._pointLiesBetween(this.x1, _x1, _x2)) {
              out.push({
                x: this.x1,
                y: _y1
              });
            }
          } else {
            var X, Y;
            if (m2 === Infinity) {
              X = _x1;
              if (this._pointLiesBetween(X, this.x1, this.x2)) {
                Y = m1 * _x1 + b;
                if (this._pointLiesBetween(Y, _y1, _y2)) {
                  out.push({
                    x: X,
                    y: Y
                  });
                }
              }
            } else if (m2 === 0) {
              Y = _y1;
              if (this._pointLiesBetween(Y, this.y1, this.y2)) {
                X = (_y1 - b) / m1;
                if (this._pointLiesBetween(X, _x1, _x2)) {
                  out.push({
                    x: X,
                    y: Y
                  });
                }
              }
            } else {
              X = (b2 - b) / (m1 - m2);
              Y = m1 * X + b;
              if (this._pointLiesBetween(X, this.x1, this.x2) && this._pointLiesBetween(Y, this.y1, this.y2)) {
                out.push({
                  x: X,
                  y: Y
                });
              }
            }
          }
        }
        return out;
      }
    }, {
      key: "boxIntersection",
      value: function boxIntersection(x, y, w, h) {
        var a = [];
        a.push.apply(a, this.lineIntersection(x, y, x + w, y));
        a.push.apply(a, this.lineIntersection(x + w, y, x + w, y + h));
        a.push.apply(a, this.lineIntersection(x + w, y + h, x, y + h));
        a.push.apply(a, this.lineIntersection(x, y + h, x, y));
        return a;
      }
    }]);
    return StraightSegment;
  }(AbstractSegment);
  _defineProperty$e(StraightSegment, "segmentType", "Straight");

  var StraightConnector = function (_AbstractConnector) {
    _inherits$a(StraightConnector, _AbstractConnector);
    var _super = _createSuper$a(StraightConnector);
    function StraightConnector() {
      var _this;
      _classCallCheck$f(this, StraightConnector);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty$e(_assertThisInitialized$a(_this), "type", StraightConnector.type);
      return _this;
    }
    _createClass$f(StraightConnector, [{
      key: "getDefaultStubs",
      value: function getDefaultStubs() {
        return [0, 0];
      }
    }, {
      key: "_compute",
      value: function _compute(paintInfo, p) {
        this._addSegment(StraightSegment, {
          x1: paintInfo.sx,
          y1: paintInfo.sy,
          x2: paintInfo.startStubX,
          y2: paintInfo.startStubY
        });
        this._addSegment(StraightSegment, {
          x1: paintInfo.startStubX,
          y1: paintInfo.startStubY,
          x2: paintInfo.endStubX,
          y2: paintInfo.endStubY
        });
        this._addSegment(StraightSegment, {
          x1: paintInfo.endStubX,
          y1: paintInfo.endStubY,
          x2: paintInfo.tx,
          y2: paintInfo.ty
        });
        this.geometry = {
          source: p.sourcePos,
          target: p.targetPos
        };
      }
    }, {
      key: "transformGeometry",
      value: function transformGeometry(g, dx, dy) {
        return {
          source: this.transformAnchorPlacement(g.source, dx, dy),
          target: this.transformAnchorPlacement(g.target, dx, dy)
        };
      }
    }]);
    return StraightConnector;
  }(AbstractConnector);
  _defineProperty$e(StraightConnector, "type", "Straight");

  var connectorMap = {};
  var Connectors = {
    get: function get(connection, name, params) {
      var c = connectorMap[name];
      if (!c) {
        throw {
          message: "jsPlumb: unknown connector type '" + name + "'"
        };
      } else {
        return new c(connection, params);
      }
    },
    register: function register(name, conn) {
      connectorMap[name] = conn;
    }
  };

  function cls() {
    for (var _len = arguments.length, className = new Array(_len), _key = 0; _key < _len; _key++) {
      className[_key] = arguments[_key];
    }
    return className.map(function (cn) {
      return "." + cn;
    }).join(",");
  }
  function classList() {
    for (var _len2 = arguments.length, className = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      className[_key2] = arguments[_key2];
    }
    return className.join(" ");
  }
  function att() {
    for (var _len3 = arguments.length, attName = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      attName[_key3] = arguments[_key3];
    }
    return attName.map(function (an) {
      return "[" + an + "]";
    }).join(",");
  }
  var SOURCE$1 = "source";
  var TARGET$1 = "target";
  var BLOCK = "block";
  var NONE$1 = "none";
  var ABSOLUTE$1 = "absolute";
  var FIXED = "fixed";
  var STATIC = "static";
  var ATTRIBUTE_GROUP = "data-jtk-group";
  var ATTRIBUTE_MANAGED = "data-jtk-managed";
  var ATTRIBUTE_NOT_DRAGGABLE = "data-jtk-not-draggable";
  var ATTRIBUTE_TABINDEX = "tabindex";
  var ATTRIBUTE_SCOPE = "data-jtk-scope";
  var ATTRIBUTE_SCOPE_PREFIX = ATTRIBUTE_SCOPE + "-";
  var CHECK_CONDITION = "checkCondition";
  var CHECK_DROP_ALLOWED = "checkDropAllowed";
  var CLASS_CONNECTOR = "jtk-connector";
  var CLASS_CONNECTOR_OUTLINE = "jtk-connector-outline";
  var CLASS_CONNECTED = "jtk-connected";
  var CLASS_ENDPOINT = "jtk-endpoint";
  var CLASS_ENDPOINT_CONNECTED = "jtk-endpoint-connected";
  var CLASS_ENDPOINT_FULL = "jtk-endpoint-full";
  var CLASS_ENDPOINT_DROP_ALLOWED = "jtk-endpoint-drop-allowed";
  var CLASS_ENDPOINT_DROP_FORBIDDEN = "jtk-endpoint-drop-forbidden";
  var CLASS_ENDPOINT_ANCHOR_PREFIX = "jtk-endpoint-anchor";
  var CLASS_GROUP_COLLAPSED = "jtk-group-collapsed";
  var CLASS_GROUP_EXPANDED = "jtk-group-expanded";
  var CLASS_OVERLAY = "jtk-overlay";
  var EVENT_ANCHOR_CHANGED = "anchor:changed";
  var EVENT_CONNECTION = "connection";
  var EVENT_INTERNAL_CONNECTION = "internal.connection";
  var EVENT_CONNECTION_DETACHED = "connection:detach";
  var EVENT_CONNECTION_MOVED = "connection:move";
  var EVENT_CONTAINER_CHANGE = "container:change";
  var EVENT_ENDPOINT_REPLACED = "endpoint:replaced";
  var EVENT_INTERNAL_ENDPOINT_UNREGISTERED = "internal.endpoint:unregistered";
  var EVENT_INTERNAL_CONNECTION_DETACHED = "internal.connection:detached";
  var EVENT_MANAGE_ELEMENT = "element:manage";
  var EVENT_GROUP_ADDED$1 = "group:added";
  var EVENT_GROUP_COLLAPSE = "group:collapse";
  var EVENT_GROUP_EXPAND = "group:expand";
  var EVENT_GROUP_MEMBER_ADDED$1 = "group:member:added";
  var EVENT_GROUP_MEMBER_REMOVED$1 = "group:member:removed";
  var EVENT_GROUP_REMOVED$1 = "group:removed";
  var EVENT_MAX_CONNECTIONS = "maxConnections";
  var EVENT_NESTED_GROUP_ADDED = "group:nested:added";
  var EVENT_NESTED_GROUP_REMOVED = "group:nested:removed";
  var EVENT_UNMANAGE_ELEMENT = "element:unmanage";
  var EVENT_ZOOM = "zoom";
  var IS_DETACH_ALLOWED = "isDetachAllowed";
  var INTERCEPT_BEFORE_DRAG = "beforeDrag";
  var INTERCEPT_BEFORE_DROP = "beforeDrop";
  var INTERCEPT_BEFORE_DETACH = "beforeDetach";
  var INTERCEPT_BEFORE_START_DETACH = "beforeStartDetach";
  var SELECTOR_MANAGED_ELEMENT = att(ATTRIBUTE_MANAGED);
  var ERROR_SOURCE_ENDPOINT_FULL = "Cannot establish connection: source endpoint is full";
  var ERROR_TARGET_ENDPOINT_FULL = "Cannot establish connection: target endpoint is full";
  var ERROR_SOURCE_DOES_NOT_EXIST = "Cannot establish connection: source does not exist";
  var ERROR_TARGET_DOES_NOT_EXIST = "Cannot establish connection: target does not exist";
  var KEY_CONNECTION_OVERLAYS = "connectionOverlays";

  function isFullOverlaySpec(o) {
    return o.type != null && o.options != null;
  }
  function convertToFullOverlaySpec(spec) {
    var o = null;
    if (isString(spec)) {
      o = {
        type: spec,
        options: {}
      };
    } else {
      o = spec;
    }
    o.options.id = o.options.id || uuid();
    return o;
  }
  var Overlay = function (_EventGenerator) {
    _inherits$a(Overlay, _EventGenerator);
    var _super = _createSuper$a(Overlay);
    function Overlay(instance, component, p) {
      var _this;
      _classCallCheck$f(this, Overlay);
      _this = _super.call(this);
      _this.instance = instance;
      _this.component = component;
      _defineProperty$e(_assertThisInitialized$a(_this), "id", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "type", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "cssClass", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "visible", true);
      _defineProperty$e(_assertThisInitialized$a(_this), "location", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "events", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "attributes", void 0);
      p = p || {};
      _this.id = p.id || uuid();
      _this.cssClass = p.cssClass || "";
      _this.location = p.location || 0.5;
      _this.events = p.events || {};
      _this.attributes = p.attributes || {};
      for (var _event in _this.events) {
        _this.bind(_event, _this.events[_event]);
      }
      return _this;
    }
    _createClass$f(Overlay, [{
      key: "shouldFireEvent",
      value: function shouldFireEvent(event, value, originalEvent) {
        return true;
      }
    }, {
      key: "setVisible",
      value: function setVisible(v) {
        this.visible = v;
        this.instance.setOverlayVisible(this, v);
      }
    }, {
      key: "isVisible",
      value: function isVisible() {
        return this.visible;
      }
    }]);
    return Overlay;
  }(EventGenerator);

  var overlayMap = {};
  var OverlayFactory = {
    get: function get(instance, name, component, params) {
      var c = overlayMap[name];
      if (!c) {
        throw {
          message: "jsPlumb: unknown overlay type '" + name + "'"
        };
      } else {
        return new c(instance, component, params);
      }
    },
    register: function register(name, overlay) {
      overlayMap[name] = overlay;
    }
  };

  var LabelOverlay = function (_Overlay) {
    _inherits$a(LabelOverlay, _Overlay);
    var _super = _createSuper$a(LabelOverlay);
    function LabelOverlay(instance, component, p) {
      var _this;
      _classCallCheck$f(this, LabelOverlay);
      _this = _super.call(this, instance, component, p);
      _this.instance = instance;
      _this.component = component;
      _defineProperty$e(_assertThisInitialized$a(_this), "label", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "labelText", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "type", LabelOverlay.type);
      _defineProperty$e(_assertThisInitialized$a(_this), "cachedDimensions", void 0);
      p = p || {
        label: ""
      };
      _this.setLabel(p.label);
      return _this;
    }
    _createClass$f(LabelOverlay, [{
      key: "getLabel",
      value: function getLabel() {
        if (isFunction(this.label)) {
          return this.label(this);
        } else {
          return this.labelText;
        }
      }
    }, {
      key: "setLabel",
      value: function setLabel(l) {
        this.label = l;
        this.labelText = null;
        this.instance.updateLabel(this);
      }
    }, {
      key: "getDimensions",
      value: function getDimensions() {
        return {
          w: 1,
          h: 1
        };
      }
    }, {
      key: "updateFrom",
      value: function updateFrom(d) {
        if (d.label != null) {
          this.setLabel(d.label);
        }
      }
    }]);
    return LabelOverlay;
  }(Overlay);
  _defineProperty$e(LabelOverlay, "type", "Label");
  function isLabelOverlay(o) {
    return o.type === LabelOverlay.type;
  }
  OverlayFactory.register("Label", LabelOverlay);

  function _splitType(t) {
    return t == null ? null : t.split(" ");
  }
  function _mapType(map, obj, typeId) {
    for (var i in obj) {
      map[i] = typeId;
    }
  }
  var CONNECTOR = "connector";
  var MERGE_STRATEGY_OVERRIDE = "override";
  var CSS_CLASS = "cssClass";
  var DEFAULT_TYPE_KEY = "__default";
  var ANCHOR = "anchor";
  var ANCHORS = "anchors";
  var _internalLabelOverlayId = "__label";
  var TYPE_ITEM_OVERLAY = "overlay";
  var LOCATION_ATTRIBUTE = "labelLocation";
  var ACTION_ADD = "add";
  var ACTION_REMOVE = "remove";
  function _applyTypes(component, params) {
    if (component.getDefaultType) {
      var td = component.getTypeDescriptor(),
          map = {};
      var defType = component.getDefaultType();
      var o = extend({}, defType);
      _mapType(map, defType, DEFAULT_TYPE_KEY);
      for (var i = 0, j = component._types.length; i < j; i++) {
        var tid = component._types[i];
        if (tid !== DEFAULT_TYPE_KEY) {
          var _t = component.instance.getType(tid, td);
          if (_t != null) {
            var overrides = new Set([CONNECTOR, ANCHOR, ANCHORS]);
            if (_t.mergeStrategy === MERGE_STRATEGY_OVERRIDE) {
              for (var k in _t) {
                overrides.add(k);
              }
            }
            o = merge(o, _t, [CSS_CLASS], setToArray(overrides));
            _mapType(map, _t, tid);
          }
        }
      }
      if (params) {
        o = populate(o, params, "_");
      }
      component.applyType(o, map);
    }
  }
  function _removeTypeCssHelper(component, typeIndex) {
    var typeId = component._types[typeIndex],
        type = component.instance.getType(typeId, component.getTypeDescriptor());
    if (type != null && type.cssClass) {
      component.removeClass(type.cssClass);
    }
  }
  function _updateHoverStyle(component) {
    if (component.paintStyle && component.hoverPaintStyle) {
      var mergedHoverStyle = {};
      extend(mergedHoverStyle, component.paintStyle);
      extend(mergedHoverStyle, component.hoverPaintStyle);
      component.hoverPaintStyle = mergedHoverStyle;
    }
  }
  function _makeLabelOverlay(component, params) {
    var _params = {
      cssClass: params.cssClass,
      id: _internalLabelOverlayId,
      component: component
    },
        mergedParams = extend(_params, params);
    return new LabelOverlay(component.instance, component, mergedParams);
  }
  function _processOverlay(component, o) {
    var _newOverlay = null;
    if (isString(o)) {
      _newOverlay = OverlayFactory.get(component.instance, o, component, {});
    } else if (o.type != null && o.options != null) {
      var oa = o;
      var p = extend({}, oa.options);
      _newOverlay = OverlayFactory.get(component.instance, oa.type, component, p);
    } else {
      _newOverlay = o;
    }
    _newOverlay.id = _newOverlay.id || uuid();
    component.cacheTypeItem(TYPE_ITEM_OVERLAY, _newOverlay, _newOverlay.id);
    component.overlays[_newOverlay.id] = _newOverlay;
    return _newOverlay;
  }
  var Component = function (_EventGenerator) {
    _inherits$a(Component, _EventGenerator);
    var _super = _createSuper$a(Component);
    function Component(instance, params) {
      var _this;
      _classCallCheck$f(this, Component);
      _this = _super.call(this);
      _this.instance = instance;
      _defineProperty$e(_assertThisInitialized$a(_this), "defaultLabelLocation", 0.5);
      _defineProperty$e(_assertThisInitialized$a(_this), "overlays", {});
      _defineProperty$e(_assertThisInitialized$a(_this), "overlayPositions", {});
      _defineProperty$e(_assertThisInitialized$a(_this), "overlayPlacements", {});
      _defineProperty$e(_assertThisInitialized$a(_this), "clone", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "deleted", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "segment", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "x", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "y", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "w", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "h", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "id", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "visible", true);
      _defineProperty$e(_assertThisInitialized$a(_this), "typeId", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "params", {});
      _defineProperty$e(_assertThisInitialized$a(_this), "paintStyle", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "hoverPaintStyle", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "paintStyleInUse", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "_hover", false);
      _defineProperty$e(_assertThisInitialized$a(_this), "lastPaintedAt", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "data", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "_defaultType", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "events", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "parameters", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "_types", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "_typeCache", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "cssClass", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "hoverClass", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "beforeDetach", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "beforeDrop", void 0);
      params = params || {};
      _this.cssClass = params.cssClass || "";
      _this.hoverClass = params.hoverClass || instance.defaults.hoverClass;
      _this.beforeDetach = params.beforeDetach;
      _this.beforeDrop = params.beforeDrop;
      _this._types = [];
      _this._typeCache = {};
      _this.parameters = clone(params.parameters || {});
      _this.id = params.id || _this.getIdPrefix() + new Date().getTime();
      _this._defaultType = {
        parameters: _this.parameters,
        scope: params.scope || _this.instance.defaultScope,
        overlays: {}
      };
      if (params.events) {
        for (var evtName in params.events) {
          _this.bind(evtName, params.events[evtName]);
        }
      }
      _this.clone = function () {
        var o = Object.create(_this.constructor.prototype);
        _this.constructor.apply(o, [instance, params]);
        return o;
      };
      _this.overlays = {};
      _this.overlayPositions = {};
      var o = params.overlays || [],
          oo = {};
      var defaultOverlayKey = _this.getDefaultOverlayKey();
      if (defaultOverlayKey) {
        var defaultOverlays = _this.instance.defaults[defaultOverlayKey];
        if (defaultOverlays) {
          o.push.apply(o, _toConsumableArray$2(defaultOverlays));
        }
        for (var i = 0; i < o.length; i++) {
          var fo = convertToFullOverlaySpec(o[i]);
          oo[fo.options.id] = fo;
        }
      }
      _this._defaultType.overlays = oo;
      if (params.label) {
        _this.getDefaultType().overlays[_internalLabelOverlayId] = {
          type: LabelOverlay.type,
          options: {
            label: params.label,
            location: params.labelLocation || _this.defaultLabelLocation,
            id: _internalLabelOverlayId
          }
        };
      }
      return _this;
    }
    _createClass$f(Component, [{
      key: "isDetachAllowed",
      value: function isDetachAllowed(connection) {
        var r = true;
        if (this.beforeDetach) {
          try {
            r = this.beforeDetach(connection);
          } catch (e) {
            log("jsPlumb: beforeDetach callback failed", e);
          }
        }
        return r;
      }
    }, {
      key: "isDropAllowed",
      value: function isDropAllowed(sourceId, targetId, scope, connection, dropEndpoint) {
        var r;
        var payload = {
          sourceId: sourceId,
          targetId: targetId,
          scope: scope,
          connection: connection,
          dropEndpoint: dropEndpoint
        };
        if (this.beforeDrop) {
          try {
            r = this.beforeDrop(payload);
          } catch (e) {
            log("jsPlumb: beforeDrop callback failed", e);
          }
        } else {
          r = this.instance.checkCondition(INTERCEPT_BEFORE_DROP, payload);
        }
        return r;
      }
    }, {
      key: "getDefaultType",
      value: function getDefaultType() {
        return this._defaultType;
      }
    }, {
      key: "appendToDefaultType",
      value: function appendToDefaultType(obj) {
        for (var i in obj) {
          this._defaultType[i] = obj[i];
        }
      }
    }, {
      key: "getId",
      value: function getId() {
        return this.id;
      }
    }, {
      key: "cacheTypeItem",
      value: function cacheTypeItem(key, item, typeId) {
        this._typeCache[typeId] = this._typeCache[typeId] || {};
        this._typeCache[typeId][key] = item;
      }
    }, {
      key: "getCachedTypeItem",
      value: function getCachedTypeItem(key, typeId) {
        return this._typeCache[typeId] ? this._typeCache[typeId][key] : null;
      }
    }, {
      key: "setType",
      value: function setType(typeId, params) {
        this.clearTypes();
        this._types = _splitType(typeId) || [];
        _applyTypes(this, params);
      }
    }, {
      key: "getType",
      value: function getType() {
        return this._types;
      }
    }, {
      key: "reapplyTypes",
      value: function reapplyTypes(params) {
        _applyTypes(this, params);
      }
    }, {
      key: "hasType",
      value: function hasType(typeId) {
        return this._types.indexOf(typeId) !== -1;
      }
    }, {
      key: "addType",
      value: function addType(typeId, params) {
        var t = _splitType(typeId),
            _somethingAdded = false;
        if (t != null) {
          for (var i = 0, j = t.length; i < j; i++) {
            if (!this.hasType(t[i])) {
              this._types.push(t[i]);
              _somethingAdded = true;
            }
          }
          if (_somethingAdded) {
            _applyTypes(this, params);
          }
        }
      }
    }, {
      key: "removeType",
      value: function removeType(typeId, params) {
        var _this2 = this;
        var t = _splitType(typeId),
            _cont = false,
            _one = function _one(tt) {
          var idx = _this2._types.indexOf(tt);
          if (idx !== -1) {
            _removeTypeCssHelper(_this2, idx);
            _this2._types.splice(idx, 1);
            return true;
          }
          return false;
        };
        if (t != null) {
          for (var i = 0, j = t.length; i < j; i++) {
            _cont = _one(t[i]) || _cont;
          }
          if (_cont) {
            _applyTypes(this, params);
          }
        }
      }
    }, {
      key: "clearTypes",
      value: function clearTypes(params, doNotRepaint) {
        var i = this._types.length;
        for (var j = 0; j < i; j++) {
          _removeTypeCssHelper(this, 0);
          this._types.splice(0, 1);
        }
        _applyTypes(this, params);
      }
    }, {
      key: "toggleType",
      value: function toggleType(typeId, params) {
        var t = _splitType(typeId);
        if (t != null) {
          for (var i = 0, j = t.length; i < j; i++) {
            var idx = this._types.indexOf(t[i]);
            if (idx !== -1) {
              _removeTypeCssHelper(this, idx);
              this._types.splice(idx, 1);
            } else {
              this._types.push(t[i]);
            }
          }
          _applyTypes(this, params);
        }
      }
    }, {
      key: "applyType",
      value: function applyType(t, params) {
        this.setPaintStyle(t.paintStyle);
        this.setHoverPaintStyle(t.hoverPaintStyle);
        this.mergeParameters(t.parameters);
        this.paintStyleInUse = this.getPaintStyle();
        if (t.overlays) {
          var keep = {},
              i;
          for (i in t.overlays) {
            var existing = this.overlays[t.overlays[i].options.id];
            if (existing) {
              existing.updateFrom(t.overlays[i].options);
              keep[t.overlays[i].options.id] = true;
              this.instance.reattachOverlay(existing, this);
            } else {
              var _c = this.getCachedTypeItem("overlay", t.overlays[i].options.id);
              if (_c != null) {
                this.instance.reattachOverlay(_c, this);
                _c.setVisible(true);
                _c.updateFrom(t.overlays[i].options);
                this.overlays[_c.id] = _c;
              } else {
                _c = this.addOverlay(t.overlays[i]);
              }
              keep[_c.id] = true;
            }
          }
          for (i in this.overlays) {
            if (keep[this.overlays[i].id] == null) {
              this.removeOverlay(this.overlays[i].id, true);
            }
          }
        }
      }
    }, {
      key: "setPaintStyle",
      value: function setPaintStyle(style) {
        this.paintStyle = style;
        this.paintStyleInUse = this.paintStyle;
        _updateHoverStyle(this);
      }
    }, {
      key: "getPaintStyle",
      value: function getPaintStyle() {
        return this.paintStyle;
      }
    }, {
      key: "setHoverPaintStyle",
      value: function setHoverPaintStyle(style) {
        this.hoverPaintStyle = style;
        _updateHoverStyle(this);
      }
    }, {
      key: "getHoverPaintStyle",
      value: function getHoverPaintStyle() {
        return this.hoverPaintStyle;
      }
    }, {
      key: "destroy",
      value: function destroy() {
        for (var i in this.overlays) {
          this.instance.destroyOverlay(this.overlays[i]);
        }
        this.overlays = {};
        this.overlayPositions = {};
        this.unbind();
        this.clone = null;
      }
    }, {
      key: "isHover",
      value: function isHover() {
        return this._hover;
      }
    }, {
      key: "mergeParameters",
      value: function mergeParameters(p) {
        if (p != null) {
          extend(this.parameters, p);
        }
      }
    }, {
      key: "setVisible",
      value: function setVisible(v) {
        this.visible = v;
        if (v) {
          this.showOverlays();
        } else {
          this.hideOverlays();
        }
      }
    }, {
      key: "isVisible",
      value: function isVisible() {
        return this.visible;
      }
    }, {
      key: "setAbsoluteOverlayPosition",
      value: function setAbsoluteOverlayPosition(overlay, xy) {
        this.overlayPositions[overlay.id] = xy;
      }
    }, {
      key: "getAbsoluteOverlayPosition",
      value: function getAbsoluteOverlayPosition(overlay) {
        return this.overlayPositions ? this.overlayPositions[overlay.id] : null;
      }
    }, {
      key: "_clazzManip",
      value: function _clazzManip(action, clazz) {
        for (var i in this.overlays) {
          if (action === ACTION_ADD) {
            this.instance.addOverlayClass(this.overlays[i], clazz);
          } else if (action === ACTION_REMOVE) {
            this.instance.removeOverlayClass(this.overlays[i], clazz);
          }
        }
      }
    }, {
      key: "addClass",
      value: function addClass(clazz, cascade) {
        var parts = (this.cssClass || "").split(" ");
        parts.push(clazz);
        this.cssClass = parts.join(" ");
        this._clazzManip(ACTION_ADD, clazz);
      }
    }, {
      key: "removeClass",
      value: function removeClass(clazz, cascade) {
        var parts = (this.cssClass || "").split(" ");
        this.cssClass = parts.filter(function (p) {
          return p !== clazz;
        }).join(" ");
        this._clazzManip(ACTION_REMOVE, clazz);
      }
    }, {
      key: "getClass",
      value: function getClass() {
        return this.cssClass;
      }
    }, {
      key: "shouldFireEvent",
      value: function shouldFireEvent(event, value, originalEvent) {
        return true;
      }
    }, {
      key: "getData",
      value: function getData() {
        return this.data;
      }
    }, {
      key: "setData",
      value: function setData(d) {
        this.data = d || {};
      }
    }, {
      key: "mergeData",
      value: function mergeData(d) {
        this.data = extend(this.data, d);
      }
    }, {
      key: "addOverlay",
      value: function addOverlay(overlay) {
        var o = _processOverlay(this, overlay);
        if (this.getData && o.type === LabelOverlay.type && !isString(overlay)) {
          var d = this.getData(),
              p = overlay.options;
          if (d) {
            var locationAttribute = p.labelLocationAttribute || LOCATION_ATTRIBUTE;
            var loc = d[locationAttribute];
            if (loc) {
              o.location = loc;
            }
          }
        }
        return o;
      }
    }, {
      key: "getOverlay",
      value: function getOverlay(id) {
        return this.overlays[id];
      }
    }, {
      key: "getOverlays",
      value: function getOverlays() {
        return this.overlays;
      }
    }, {
      key: "hideOverlay",
      value: function hideOverlay(id) {
        var o = this.getOverlay(id);
        if (o) {
          o.setVisible(false);
        }
      }
    }, {
      key: "hideOverlays",
      value: function hideOverlays() {
        for (var _len = arguments.length, ids = new Array(_len), _key = 0; _key < _len; _key++) {
          ids[_key] = arguments[_key];
        }
        ids = ids || [];
        for (var i in this.overlays) {
          if (ids.length === 0 || ids.indexOf(i) !== -1) {
            this.overlays[i].setVisible(false);
          }
        }
      }
    }, {
      key: "showOverlay",
      value: function showOverlay(id) {
        var o = this.getOverlay(id);
        if (o) {
          o.setVisible(true);
        }
      }
    }, {
      key: "showOverlays",
      value: function showOverlays() {
        for (var _len2 = arguments.length, ids = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          ids[_key2] = arguments[_key2];
        }
        ids = ids || [];
        for (var i in this.overlays) {
          if (ids.length === 0 || ids.indexOf(i) !== -1) {
            this.overlays[i].setVisible(true);
          }
        }
      }
    }, {
      key: "removeAllOverlays",
      value: function removeAllOverlays() {
        for (var i in this.overlays) {
          this.instance.destroyOverlay(this.overlays[i]);
        }
        this.overlays = {};
        this.overlayPositions = null;
        this.overlayPlacements = {};
      }
    }, {
      key: "removeOverlay",
      value: function removeOverlay(overlayId, dontCleanup) {
        var o = this.overlays[overlayId];
        if (o) {
          o.setVisible(false);
          if (!dontCleanup) {
            this.instance.destroyOverlay(o);
          }
          delete this.overlays[overlayId];
          if (this.overlayPositions) {
            delete this.overlayPositions[overlayId];
          }
          if (this.overlayPlacements) {
            delete this.overlayPlacements[overlayId];
          }
        }
      }
    }, {
      key: "removeOverlays",
      value: function removeOverlays() {
        for (var _len3 = arguments.length, overlays = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          overlays[_key3] = arguments[_key3];
        }
        for (var i = 0, j = overlays.length; i < j; i++) {
          this.removeOverlay(arguments[i]);
        }
      }
    }, {
      key: "getLabel",
      value: function getLabel() {
        var lo = this.getLabelOverlay();
        return lo != null ? lo.getLabel() : null;
      }
    }, {
      key: "getLabelOverlay",
      value: function getLabelOverlay() {
        return this.getOverlay(_internalLabelOverlayId);
      }
    }, {
      key: "setLabel",
      value: function setLabel(l) {
        var lo = this.getLabelOverlay();
        if (!lo) {
          var _params2 = isString(l) || isFunction(l) ? {
            label: l
          } : l;
          lo = _makeLabelOverlay(this, _params2);
          this.overlays[_internalLabelOverlayId] = lo;
        } else {
          if (isString(l) || isFunction(l)) {
            lo.setLabel(l);
          } else {
            var ll = l;
            if (ll.label) {
              lo.setLabel(ll.label);
            }
            if (ll.location) {
              lo.location = ll.location;
            }
          }
        }
      }
    }]);
    return Component;
  }(EventGenerator);

  var _opposites, _clockwiseOptions, _antiClockwiseOptions;
  var FaceValues;
  (function (FaceValues) {
    FaceValues["top"] = "top";
    FaceValues["left"] = "left";
    FaceValues["right"] = "right";
    FaceValues["bottom"] = "bottom";
  })(FaceValues || (FaceValues = {}));
  var TOP$2 = FaceValues.top;
  var LEFT$2 = FaceValues.left;
  var RIGHT$1 = FaceValues.right;
  var BOTTOM$1 = FaceValues.bottom;
  var X_AXIS_FACES = [LEFT$2, RIGHT$1];
  var Y_AXIS_FACES = [TOP$2, BOTTOM$1];
  var LightweightFloatingAnchor = function () {
    function LightweightFloatingAnchor(instance, element) {
      _classCallCheck$f(this, LightweightFloatingAnchor);
      this.instance = instance;
      this.element = element;
      _defineProperty$e(this, "isFloating", true);
      _defineProperty$e(this, "isContinuous", void 0);
      _defineProperty$e(this, "isDynamic", void 0);
      _defineProperty$e(this, "locations", []);
      _defineProperty$e(this, "currentLocation", 0);
      _defineProperty$e(this, "locked", false);
      _defineProperty$e(this, "cssClass", '');
      _defineProperty$e(this, "timestamp", null);
      _defineProperty$e(this, "type", "Floating");
      _defineProperty$e(this, "id", uuid());
      _defineProperty$e(this, "orientation", [0, 0]);
      _defineProperty$e(this, "size", void 0);
      this.size = instance.getSize(element);
      this.locations.push({
        x: 0.5,
        y: 0.5,
        ox: this.orientation[0],
        oy: this.orientation[1],
        offx: 0,
        offy: 0,
        iox: this.orientation[0],
        ioy: this.orientation[1],
        cls: ''
      });
    }
    _createClass$f(LightweightFloatingAnchor, [{
      key: "_updateOrientationInRouter",
      value: function _updateOrientationInRouter() {
        this.instance.router.setAnchorOrientation(this, [this.locations[0].ox, this.locations[0].oy]);
      }
    }, {
      key: "over",
      value: function over(endpoint) {
        this.orientation = this.instance.router.getEndpointOrientation(endpoint);
        this.locations[0].ox = this.orientation[0];
        this.locations[0].oy = this.orientation[1];
        this._updateOrientationInRouter();
      }
    }, {
      key: "out",
      value: function out() {
        this.orientation = null;
        this.locations[0].ox = this.locations[0].iox;
        this.locations[0].oy = this.locations[0].ioy;
        this._updateOrientationInRouter();
      }
    }]);
    return LightweightFloatingAnchor;
  }();
  var opposites = (_opposites = {}, _defineProperty$e(_opposites, TOP$2, BOTTOM$1), _defineProperty$e(_opposites, RIGHT$1, LEFT$2), _defineProperty$e(_opposites, LEFT$2, RIGHT$1), _defineProperty$e(_opposites, BOTTOM$1, TOP$2), _opposites);
  var clockwiseOptions = (_clockwiseOptions = {}, _defineProperty$e(_clockwiseOptions, TOP$2, RIGHT$1), _defineProperty$e(_clockwiseOptions, RIGHT$1, BOTTOM$1), _defineProperty$e(_clockwiseOptions, LEFT$2, TOP$2), _defineProperty$e(_clockwiseOptions, BOTTOM$1, LEFT$2), _clockwiseOptions);
  var antiClockwiseOptions = (_antiClockwiseOptions = {}, _defineProperty$e(_antiClockwiseOptions, TOP$2, LEFT$2), _defineProperty$e(_antiClockwiseOptions, RIGHT$1, TOP$2), _defineProperty$e(_antiClockwiseOptions, LEFT$2, BOTTOM$1), _defineProperty$e(_antiClockwiseOptions, BOTTOM$1, RIGHT$1), _antiClockwiseOptions);
  function getDefaultFace(a) {
    return a.faces.length === 0 ? TOP$2 : a.faces[0];
  }
  function _isFaceAvailable(a, face) {
    return a.faces.indexOf(face) !== -1;
  }
  function _secondBest(a, edge) {
    return (a.clockwise ? clockwiseOptions : antiClockwiseOptions)[edge];
  }
  function _lastChoice(a, edge) {
    return (a.clockwise ? antiClockwiseOptions : clockwiseOptions)[edge];
  }
  function isEdgeSupported(a, edge) {
    return a.lockedAxis == null ? a.lockedFace == null ? _isFaceAvailable(a, edge) === true : a.lockedFace === edge : a.lockedAxis.indexOf(edge) !== -1;
  }
  function verifyFace(a, edge) {
    if (_isFaceAvailable(a, edge)) {
      return edge;
    } else if (_isFaceAvailable(a, opposites[edge])) {
      return opposites[edge];
    } else {
      var secondBest = _secondBest(a, edge);
      if (_isFaceAvailable(a, secondBest)) {
        return secondBest;
      } else {
        var lastChoice = _lastChoice(a, edge);
        if (_isFaceAvailable(a, lastChoice)) {
          return lastChoice;
        }
      }
    }
    return edge;
  }
  var _top = {
    x: 0.5,
    y: 0,
    ox: 0,
    oy: -1,
    offx: 0,
    offy: 0
  },
      _bottom = {
    x: 0.5,
    y: 1,
    ox: 0,
    oy: 1,
    offx: 0,
    offy: 0
  },
      _left = {
    x: 0,
    y: 0.5,
    ox: -1,
    oy: 0,
    offx: 0,
    offy: 0
  },
      _right = {
    x: 1,
    y: 0.5,
    ox: 1,
    oy: 0,
    offx: 0,
    offy: 0
  },
      _topLeft = {
    x: 0,
    y: 0,
    ox: 0,
    oy: -1,
    offx: 0,
    offy: 0
  },
      _topRight = {
    x: 1,
    y: 0,
    ox: 1,
    oy: -1,
    offx: 0,
    offy: 0
  },
      _bottomLeft = {
    x: 0,
    y: 1,
    ox: 0,
    oy: 1,
    offx: 0,
    offy: 0
  },
      _bottomRight = {
    x: 1,
    y: 1,
    ox: 0,
    oy: 1,
    offx: 0,
    offy: 0
  },
      _center = {
    x: 0.5,
    y: 0.5,
    ox: 0,
    oy: 0,
    offx: 0,
    offy: 0
  };
  var namedValues = {
    "Top": [_top],
    "Bottom": [_bottom],
    "Left": [_left],
    "Right": [_right],
    "TopLeft": [_topLeft],
    "TopRight": [_topRight],
    "BottomLeft": [_bottomLeft],
    "BottomRight": [_bottomRight],
    "Center": [_center],
    "AutoDefault": [_top, _left, _bottom, _right]
  };
  var namedContinuousValues = {
    "Continuous": {
      faces: [TOP$2, LEFT$2, BOTTOM$1, RIGHT$1]
    },
    "ContinuousTop": {
      faces: [TOP$2]
    },
    "ContinuousRight": {
      faces: [RIGHT$1]
    },
    "ContinuousBottom": {
      faces: [BOTTOM$1]
    },
    "ContinuousLeft": {
      faces: [LEFT$2]
    },
    "ContinuousLeftRight": {
      faces: [LEFT$2, RIGHT$1]
    },
    "ContinuousTopBottom": {
      faces: [TOP$2, BOTTOM$1]
    }
  };
  function getNamedAnchor(name, params) {
    params = params || {};
    if (name === AnchorLocations.Perimeter) {
      return _createPerimeterAnchor(params);
    }
    var a = namedValues[name];
    if (a != null) {
      return _createAnchor(name, map(a, function (_a) {
        return extend({
          iox: _a.ox,
          ioy: _a.oy
        }, _a);
      }), params);
    }
    a = namedContinuousValues[name];
    if (a != null) {
      return _createContinuousAnchor(name, a.faces, params);
    }
    throw {
      message: "jsPlumb: unknown anchor type '" + name + "'"
    };
  }
  function _createAnchor(type, locations, params) {
    return {
      type: type,
      locations: locations,
      currentLocation: 0,
      locked: false,
      id: uuid(),
      isFloating: false,
      isContinuous: false,
      isDynamic: locations.length > 1,
      timestamp: null,
      cssClass: params.cssClass || ""
    };
  }
  function createFloatingAnchor(instance, element) {
    return new LightweightFloatingAnchor(instance, element);
  }
  var PROPERTY_CURRENT_FACE = "currentFace";
  function _createContinuousAnchor(type, faces, params) {
    var ca = {
      type: type,
      locations: [],
      currentLocation: 0,
      locked: false,
      id: uuid(),
      cssClass: params.cssClass || "",
      isFloating: false,
      isContinuous: true,
      timestamp: null,
      faces: params.faces || faces,
      lockedFace: null,
      lockedAxis: null,
      clockwise: !(params.clockwise === false),
      __currentFace: null
    };
    Object.defineProperty(ca, PROPERTY_CURRENT_FACE, {
      get: function get() {
        return this.__currentFace;
      },
      set: function set(f) {
        this.__currentFace = verifyFace(this, f);
      }
    });
    return ca;
  }
  function isPrimitiveAnchorSpec(sa) {
    return sa.length < 7 && sa.every(isNumber) || sa.length === 7 && sa.slice(0, 5).every(isNumber) && isString(sa[6]);
  }
  function makeLightweightAnchorFromSpec(spec) {
    if (isString(spec)) {
      return getNamedAnchor(spec, null);
    } else if (Array.isArray(spec)) {
      if (isPrimitiveAnchorSpec(spec)) {
        var _spec = spec;
        return _createAnchor(null, [{
          x: _spec[0],
          y: _spec[1],
          ox: _spec[2],
          oy: _spec[3],
          offx: _spec[4] == null ? 0 : _spec[4],
          offy: _spec[5] == null ? 0 : _spec[5],
          iox: _spec[2],
          ioy: _spec[3],
          cls: _spec[6] || ""
        }], {
          cssClass: _spec[6] || ""
        });
      } else {
        var locations = map(spec, function (aSpec) {
          if (isString(aSpec)) {
            var a = namedValues[aSpec];
            return a != null ? extend({
              iox: a[0].ox,
              ioy: a[0].oy,
              cls: ""
            }, a[0]) : null;
          } else if (isPrimitiveAnchorSpec(aSpec)) {
            return {
              x: aSpec[0],
              y: aSpec[1],
              ox: aSpec[2],
              oy: aSpec[3],
              offx: aSpec[4] == null ? 0 : aSpec[4],
              offy: aSpec[5] == null ? 0 : aSpec[5],
              iox: aSpec[2],
              ioy: aSpec[3],
              cls: aSpec[6] || ""
            };
          }
        }).filter(function (ar) {
          return ar != null;
        });
        return _createAnchor("Dynamic", locations, {});
      }
    } else {
      var sa = spec;
      return getNamedAnchor(sa.type, sa.options);
    }
  }
  function circleGenerator(anchorCount) {
    var r = 0.5,
        step = Math.PI * 2 / anchorCount,
        a = [];
    var current = 0;
    for (var i = 0; i < anchorCount; i++) {
      var x = r + r * Math.sin(current),
          y = r + r * Math.cos(current);
      a.push({
        x: x,
        y: y,
        ox: 0,
        oy: 0,
        offx: 0,
        offy: 0,
        iox: 0,
        ioy: 0,
        cls: ''
      });
      current += step;
    }
    return a;
  }
  function _path(segments, anchorCount) {
    var anchorsPerFace = anchorCount / segments.length,
        a = [],
        _computeFace = function _computeFace(x1, y1, x2, y2, fractionalLength, ox, oy) {
      anchorsPerFace = anchorCount * fractionalLength;
      var dx = (x2 - x1) / anchorsPerFace,
          dy = (y2 - y1) / anchorsPerFace;
      for (var i = 0; i < anchorsPerFace; i++) {
        a.push({
          x: x1 + dx * i,
          y: y1 + dy * i,
          ox: ox == null ? 0 : ox,
          oy: oy == null ? 0 : oy,
          offx: 0,
          offy: 0,
          iox: 0,
          ioy: 0,
          cls: ''
        });
      }
    };
    for (var i = 0; i < segments.length; i++) {
      _computeFace.apply(null, segments[i]);
    }
    return a;
  }
  function shapeGenerator(faces, anchorCount) {
    var s = [];
    for (var i = 0; i < faces.length; i++) {
      s.push([faces[i][0], faces[i][1], faces[i][2], faces[i][3], 1 / faces.length, faces[i][4], faces[i][5]]);
    }
    return _path(s, anchorCount);
  }
  function rectangleGenerator(anchorCount) {
    return shapeGenerator([[0, 0, 1, 0, 0, -1], [1, 0, 1, 1, 1, 0], [1, 1, 0, 1, 0, 1], [0, 1, 0, 0, -1, 0]], anchorCount);
  }
  function diamondGenerator(anchorCount) {
    return shapeGenerator([[0.5, 0, 1, 0.5], [1, 0.5, 0.5, 1], [0.5, 1, 0, 0.5], [0, 0.5, 0.5, 0]], anchorCount);
  }
  function triangleGenerator(anchorCount) {
    return shapeGenerator([[0.5, 0, 1, 1], [1, 1, 0, 1], [0, 1, 0.5, 0]], anchorCount);
  }
  function rotate$1(points, amountInDegrees) {
    var o = [],
        theta = amountInDegrees / 180 * Math.PI;
    for (var i = 0; i < points.length; i++) {
      var _x = points[i].x - 0.5,
          _y = points[i].y - 0.5;
      o.push({
        x: 0.5 + (_x * Math.cos(theta) - _y * Math.sin(theta)),
        y: 0.5 + (_x * Math.sin(theta) + _y * Math.cos(theta)),
        ox: points[i].ox,
        oy: points[i].oy,
        offx: 0,
        offy: 0,
        iox: 0,
        ioy: 0,
        cls: ''
      });
    }
    return o;
  }
  var anchorGenerators = new Map();
  anchorGenerators.set(PerimeterAnchorShapes.Circle, circleGenerator);
  anchorGenerators.set(PerimeterAnchorShapes.Ellipse, circleGenerator);
  anchorGenerators.set(PerimeterAnchorShapes.Rectangle, rectangleGenerator);
  anchorGenerators.set(PerimeterAnchorShapes.Square, rectangleGenerator);
  anchorGenerators.set(PerimeterAnchorShapes.Diamond, diamondGenerator);
  anchorGenerators.set(PerimeterAnchorShapes.Triangle, triangleGenerator);
  function _createPerimeterAnchor(params) {
    params = params || {};
    var anchorCount = params.anchorCount || 60,
        shape = params.shape;
    if (!shape) {
      throw new Error("no shape supplied to Perimeter Anchor type");
    }
    if (!anchorGenerators.has(shape)) {
      throw new Error("Shape [" + shape + "] is unknown by Perimeter Anchor type");
    }
    var da = anchorGenerators.get(shape)(anchorCount);
    if (params.rotation) {
      da = rotate$1(da, params.rotation);
    }
    var a = _createAnchor(AnchorLocations.Perimeter, da, params);
    var aa = extend(a, {
      shape: shape
    });
    return aa;
  }

  var TYPE_ITEM_ANCHORS = "anchors";
  var TYPE_ITEM_CONNECTOR = "connector";
  function prepareEndpoint(conn, existing, index, anchor, element, elementId, endpoint) {
    var e;
    if (existing) {
      conn.endpoints[index] = existing;
      existing.addConnection(conn);
    } else {
      var ep = endpoint || conn.endpointSpec || conn.endpointsSpec[index] || conn.instance.defaults.endpoints[index] || conn.instance.defaults.endpoint;
      var es = conn.endpointStyles[index] || conn.endpointStyle || conn.instance.defaults.endpointStyles[index] || conn.instance.defaults.endpointStyle;
      if (es.fill == null && conn.paintStyle != null) {
        es.fill = conn.paintStyle.stroke;
      }
      if (es.outlineStroke == null && conn.paintStyle != null) {
        es.outlineStroke = conn.paintStyle.outlineStroke;
      }
      if (es.outlineWidth == null && conn.paintStyle != null) {
        es.outlineWidth = conn.paintStyle.outlineWidth;
      }
      var ehs = conn.endpointHoverStyles[index] || conn.endpointHoverStyle || conn.endpointHoverStyle || conn.instance.defaults.endpointHoverStyles[index] || conn.instance.defaults.endpointHoverStyle;
      if (conn.hoverPaintStyle != null) {
        if (ehs == null) {
          ehs = {};
        }
        if (ehs.fill == null) {
          ehs.fill = conn.hoverPaintStyle.stroke;
        }
      }
      var u = conn.uuids ? conn.uuids[index] : null;
      anchor = anchor != null ? anchor : conn.instance.defaults.anchors != null ? conn.instance.defaults.anchors[index] : conn.instance.defaults.anchor;
      e = conn.instance._internal_newEndpoint({
        paintStyle: es,
        hoverPaintStyle: ehs,
        endpoint: ep,
        connections: [conn],
        uuid: u,
        element: element,
        scope: conn.scope,
        anchor: anchor,
        reattachConnections: conn.reattach || conn.instance.defaults.reattachConnections,
        connectionsDetachable: conn.detachable || conn.instance.defaults.connectionsDetachable
      });
      if (existing == null) {
        e.deleteOnEmpty = true;
      }
      conn.endpoints[index] = e;
    }
    return e;
  }
  var Connection = function (_Component) {
    _inherits$a(Connection, _Component);
    var _super = _createSuper$a(Connection);
    function Connection(instance, params) {
      var _this;
      _classCallCheck$f(this, Connection);
      _this = _super.call(this, instance, params);
      _this.instance = instance;
      _defineProperty$e(_assertThisInitialized$a(_this), "connector", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "defaultLabelLocation", 0.5);
      _defineProperty$e(_assertThisInitialized$a(_this), "scope", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "typeId", "_jsplumb_connection");
      _defineProperty$e(_assertThisInitialized$a(_this), "previousConnection", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "sourceId", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "targetId", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "source", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "target", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "detachable", true);
      _defineProperty$e(_assertThisInitialized$a(_this), "reattach", false);
      _defineProperty$e(_assertThisInitialized$a(_this), "uuids", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "cost", 1);
      _defineProperty$e(_assertThisInitialized$a(_this), "directed", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "endpoints", [null, null]);
      _defineProperty$e(_assertThisInitialized$a(_this), "endpointStyles", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "endpointSpec", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "endpointsSpec", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "endpointStyle", {});
      _defineProperty$e(_assertThisInitialized$a(_this), "endpointHoverStyle", {});
      _defineProperty$e(_assertThisInitialized$a(_this), "endpointHoverStyles", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "suspendedEndpoint", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "suspendedIndex", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "suspendedElement", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "suspendedElementId", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "suspendedElementType", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "_forceReattach", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "_forceDetach", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "proxies", []);
      _defineProperty$e(_assertThisInitialized$a(_this), "pending", false);
      _this.id = params.id;
      _this.previousConnection = params.previousConnection;
      _this.source = params.source;
      _this.target = params.target;
      if (params.sourceEndpoint) {
        _this.source = params.sourceEndpoint.element;
        _this.sourceId = params.sourceEndpoint.elementId;
      } else {
        _this.sourceId = instance.getId(_this.source);
      }
      if (params.targetEndpoint) {
        _this.target = params.targetEndpoint.element;
        _this.targetId = params.targetEndpoint.elementId;
      } else {
        _this.targetId = instance.getId(_this.target);
      }
      _this.scope = params.scope;
      var sourceAnchor = params.anchors ? params.anchors[0] : params.anchor;
      var targetAnchor = params.anchors ? params.anchors[1] : params.anchor;
      instance.manage(_this.source);
      instance.manage(_this.target);
      _this.visible = true;
      _this.params = {
        cssClass: params.cssClass,
        hoverClass: params.hoverClass,
        "pointer-events": params["pointer-events"],
        overlays: params.overlays
      };
      _this.lastPaintedAt = null;
      if (params.type) {
        params.endpoints = params.endpoints || _this.instance._deriveEndpointAndAnchorSpec(params.type).endpoints;
      }
      _this.endpointSpec = params.endpoint;
      _this.endpointsSpec = params.endpoints || [null, null];
      _this.endpointStyle = params.endpointStyle;
      _this.endpointHoverStyle = params.endpointHoverStyle;
      _this.endpointStyles = params.endpointStyles || [null, null];
      _this.endpointHoverStyles = params.endpointHoverStyles || [null, null];
      _this.paintStyle = params.paintStyle;
      _this.hoverPaintStyle = params.hoverPaintStyle;
      _this.uuids = params.uuids;
      _this.makeEndpoint(true, _this.source, _this.sourceId, sourceAnchor, params.sourceEndpoint);
      _this.makeEndpoint(false, _this.target, _this.targetId, targetAnchor, params.targetEndpoint);
      if (!_this.scope) {
        _this.scope = _this.endpoints[0].scope;
      }
      if (params.deleteEndpointsOnEmpty != null) {
        _this.endpoints[0].deleteOnEmpty = params.deleteEndpointsOnEmpty;
        _this.endpoints[1].deleteOnEmpty = params.deleteEndpointsOnEmpty;
      }
      var _detachable = _this.instance.defaults.connectionsDetachable;
      if (params.detachable === false) {
        _detachable = false;
      }
      if (_this.endpoints[0].connectionsDetachable === false) {
        _detachable = false;
      }
      if (_this.endpoints[1].connectionsDetachable === false) {
        _detachable = false;
      }
      _this.endpointsSpec = params.endpoints || [null, null];
      _this.endpointSpec = params.endpoint || null;
      var _reattach = params.reattach || _this.endpoints[0].reattachConnections || _this.endpoints[1].reattachConnections || _this.instance.defaults.reattachConnections;
      _this.appendToDefaultType({
        detachable: _detachable,
        reattach: _reattach,
        paintStyle: _this.endpoints[0].connectorStyle || _this.endpoints[1].connectorStyle || params.paintStyle || _this.instance.defaults.paintStyle,
        hoverPaintStyle: _this.endpoints[0].connectorHoverStyle || _this.endpoints[1].connectorHoverStyle || params.hoverPaintStyle || _this.instance.defaults.hoverPaintStyle
      });
      if (!_this.instance._suspendDrawing) {
        var initialTimestamp = _this.instance._suspendedAt || uuid();
        _this.instance._paintEndpoint(_this.endpoints[0], {
          timestamp: initialTimestamp
        });
        _this.instance._paintEndpoint(_this.endpoints[1], {
          timestamp: initialTimestamp
        });
      }
      _this.cost = params.cost || _this.endpoints[0].connectionCost;
      _this.directed = params.directed;
      if (params.directed == null) {
        _this.directed = _this.endpoints[0].connectionsDirected;
      }
      var _p = extend({}, _this.endpoints[1].parameters);
      extend(_p, _this.endpoints[0].parameters);
      extend(_p, _this.parameters);
      _this.parameters = _p;
      _this.paintStyleInUse = _this.getPaintStyle() || {};
      _this.setConnector(_this.endpoints[0].connector || _this.endpoints[1].connector || params.connector || _this.instance.defaults.connector, true);
      var data = params.data == null || !isObject(params.data) ? {} : params.data;
      _this.setData(data);
      var _types = [DEFAULT$1, _this.endpoints[0].edgeType, _this.endpoints[1].edgeType, params.type].join(" ");
      if (/[^\s]/.test(_types)) {
        _this.addType(_types, params.data);
      }
      return _this;
    }
    _createClass$f(Connection, [{
      key: "getIdPrefix",
      value: function getIdPrefix() {
        return "_jsPlumb_c";
      }
    }, {
      key: "getDefaultOverlayKey",
      value: function getDefaultOverlayKey() {
        return KEY_CONNECTION_OVERLAYS;
      }
    }, {
      key: "getXY",
      value: function getXY() {
        return {
          x: this.connector.x,
          y: this.connector.y
        };
      }
    }, {
      key: "makeEndpoint",
      value: function makeEndpoint(isSource, el, elId, anchor, ep) {
        elId = elId || this.instance.getId(el);
        return prepareEndpoint(this, ep, isSource ? 0 : 1, anchor, el);
      }
    }, {
      key: "getTypeDescriptor",
      value: function getTypeDescriptor() {
        return Connection.type;
      }
    }, {
      key: "isDetachable",
      value: function isDetachable(ep) {
        return this.detachable === false ? false : ep != null ? ep.connectionsDetachable === true : this.detachable === true;
      }
    }, {
      key: "setDetachable",
      value: function setDetachable(detachable) {
        this.detachable = detachable === true;
      }
    }, {
      key: "isReattach",
      value: function isReattach() {
        return this.reattach === true || this.endpoints[0].reattachConnections === true || this.endpoints[1].reattachConnections === true;
      }
    }, {
      key: "setReattach",
      value: function setReattach(reattach) {
        this.reattach = reattach === true;
      }
    }, {
      key: "applyType",
      value: function applyType(t, typeMap) {
        var _connector = null;
        if (t.connector != null) {
          _connector = this.getCachedTypeItem(TYPE_ITEM_CONNECTOR, typeMap.connector);
          if (_connector == null) {
            _connector = this.prepareConnector(t.connector, typeMap.connector);
            this.cacheTypeItem(TYPE_ITEM_CONNECTOR, _connector, typeMap.connector);
          }
          this.setPreparedConnector(_connector);
        }
        _get$4(_getPrototypeOf$a(Connection.prototype), "applyType", this).call(this, t, typeMap);
        if (t.detachable != null) {
          this.setDetachable(t.detachable);
        }
        if (t.reattach != null) {
          this.setReattach(t.reattach);
        }
        if (t.scope) {
          this.scope = t.scope;
        }
        var _anchors = null;
        if (t.anchor) {
          _anchors = this.getCachedTypeItem(TYPE_ITEM_ANCHORS, typeMap.anchor);
          if (_anchors == null) {
            _anchors = [makeLightweightAnchorFromSpec(t.anchor), makeLightweightAnchorFromSpec(t.anchor)];
            this.cacheTypeItem(TYPE_ITEM_ANCHORS, _anchors, typeMap.anchor);
          }
        } else if (t.anchors) {
          _anchors = this.getCachedTypeItem(TYPE_ITEM_ANCHORS, typeMap.anchors);
          if (_anchors == null) {
            _anchors = [makeLightweightAnchorFromSpec(t.anchors[0]), makeLightweightAnchorFromSpec(t.anchors[1])];
            this.cacheTypeItem(TYPE_ITEM_ANCHORS, _anchors, typeMap.anchors);
          }
        }
        if (_anchors != null) {
          this.instance.router.setConnectionAnchors(this, _anchors);
          if (this.instance.router.isDynamicAnchor(this.endpoints[1])) {
            this.instance.repaint(this.endpoints[1].element);
          }
        }
        this.instance.applyConnectorType(this.connector, t);
      }
    }, {
      key: "addClass",
      value: function addClass(c, cascade) {
        _get$4(_getPrototypeOf$a(Connection.prototype), "addClass", this).call(this, c);
        if (cascade) {
          this.endpoints[0].addClass(c);
          this.endpoints[1].addClass(c);
          if (this.suspendedEndpoint) {
            this.suspendedEndpoint.addClass(c);
          }
        }
        if (this.connector) {
          this.instance.addConnectorClass(this.connector, c);
        }
      }
    }, {
      key: "removeClass",
      value: function removeClass(c, cascade) {
        _get$4(_getPrototypeOf$a(Connection.prototype), "removeClass", this).call(this, c);
        if (cascade) {
          this.endpoints[0].removeClass(c);
          this.endpoints[1].removeClass(c);
          if (this.suspendedEndpoint) {
            this.suspendedEndpoint.removeClass(c);
          }
        }
        if (this.connector) {
          this.instance.removeConnectorClass(this.connector, c);
        }
      }
    }, {
      key: "setVisible",
      value: function setVisible(v) {
        _get$4(_getPrototypeOf$a(Connection.prototype), "setVisible", this).call(this, v);
        if (this.connector) {
          this.instance.setConnectorVisible(this.connector, v);
        }
        this.instance._paintConnection(this);
      }
    }, {
      key: "destroy",
      value: function destroy() {
        _get$4(_getPrototypeOf$a(Connection.prototype), "destroy", this).call(this);
        this.endpoints = null;
        this.endpointStyles = null;
        this.source = null;
        this.target = null;
        this.instance.destroyConnector(this);
        this.connector = null;
        this.deleted = true;
      }
    }, {
      key: "getUuids",
      value: function getUuids() {
        return [this.endpoints[0].getUuid(), this.endpoints[1].getUuid()];
      }
    }, {
      key: "prepareConnector",
      value: function prepareConnector(connectorSpec, typeId) {
        var connectorArgs = {
          cssClass: this.params.cssClass,
          hoverClass: this.params.hoverClass,
          "pointer-events": this.params["pointer-events"]
        },
            connector;
        if (isString(connectorSpec)) {
          connector = this.instance._makeConnector(this, connectorSpec, connectorArgs);
        } else {
          var co = connectorSpec;
          connector = this.instance._makeConnector(this, co.type, merge(co.options, connectorArgs));
        }
        if (typeId != null) {
          connector.typeId = typeId;
        }
        return connector;
      }
    }, {
      key: "setPreparedConnector",
      value: function setPreparedConnector(connector, doNotRepaint, doNotChangeListenerComponent, typeId) {
        if (this.connector !== connector) {
          var previous,
              previousClasses = "";
          if (this.connector != null) {
            previous = this.connector;
            previousClasses = this.instance.getConnectorClass(this.connector);
            this.instance.destroyConnector(this);
          }
          this.connector = connector;
          if (typeId) {
            this.cacheTypeItem(TYPE_ITEM_CONNECTOR, connector, typeId);
          }
          this.addClass(previousClasses);
          if (previous != null) {
            var o = this.getOverlays();
            for (var i in o) {
              this.instance.reattachOverlay(o[i], this);
            }
          }
          if (!doNotRepaint) {
            this.instance._paintConnection(this);
          }
        }
      }
    }, {
      key: "setConnector",
      value: function setConnector(connectorSpec, doNotRepaint, doNotChangeListenerComponent, typeId) {
        var connector = this.prepareConnector(connectorSpec, typeId);
        this.setPreparedConnector(connector, doNotRepaint, doNotChangeListenerComponent, typeId);
      }
    }, {
      key: "replaceEndpoint",
      value: function replaceEndpoint(idx, endpointDef) {
        var current = this.endpoints[idx],
            elId = current.elementId,
            ebe = this.instance.getEndpoints(current.element),
            _idx = ebe.indexOf(current),
            _new = prepareEndpoint(this, null, idx, null, current.element, elId, endpointDef);
        this.endpoints[idx] = _new;
        ebe.splice(_idx, 1, _new);
        current.detachFromConnection(this);
        this.instance.deleteEndpoint(current);
        this.instance.fire(EVENT_ENDPOINT_REPLACED, {
          previous: current,
          current: _new
        });
      }
    }]);
    return Connection;
  }(Component);
  _defineProperty$e(Connection, "type", "connection");

  var typeParameters = ["connectorStyle", "connectorHoverStyle", "connectorOverlays", "connector", "connectionType", "connectorClass", "connectorHoverClass"];
  var Endpoint = function (_Component) {
    _inherits$a(Endpoint, _Component);
    var _super = _createSuper$a(Endpoint);
    function Endpoint(instance, params) {
      var _this;
      _classCallCheck$f(this, Endpoint);
      _this = _super.call(this, instance, params);
      _this.instance = instance;
      _defineProperty$e(_assertThisInitialized$a(_this), "connections", []);
      _defineProperty$e(_assertThisInitialized$a(_this), "endpoint", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "element", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "elementId", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "dragAllowedWhenFull", true);
      _defineProperty$e(_assertThisInitialized$a(_this), "timestamp", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "portId", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "maxConnections", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "proxiedBy", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "connectorClass", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "connectorHoverClass", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "finalEndpoint", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "enabled", true);
      _defineProperty$e(_assertThisInitialized$a(_this), "isSource", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "isTarget", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "isTemporarySource", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "connectionCost", 1);
      _defineProperty$e(_assertThisInitialized$a(_this), "connectionsDirected", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "connectionsDetachable", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "reattachConnections", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "currentAnchorClass", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "referenceEndpoint", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "edgeType", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "connector", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "connectorOverlays", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "connectorStyle", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "connectorHoverStyle", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "deleteOnEmpty", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "uuid", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "scope", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "_anchor", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "defaultLabelLocation", [0.5, 0.5]);
      _this.appendToDefaultType({
        edgeType: params.edgeType,
        maxConnections: params.maxConnections == null ? _this.instance.defaults.maxConnections : params.maxConnections,
        paintStyle: params.paintStyle || _this.instance.defaults.endpointStyle,
        hoverPaintStyle: params.hoverPaintStyle || _this.instance.defaults.endpointHoverStyle,
        connectorStyle: params.connectorStyle,
        connectorHoverStyle: params.connectorHoverStyle,
        connectorClass: params.connectorClass,
        connectorHoverClass: params.connectorHoverClass,
        connectorOverlays: params.connectorOverlays,
        connector: params.connector
      });
      _this.enabled = !(params.enabled === false);
      _this.visible = true;
      _this.element = params.element;
      _this.uuid = params.uuid;
      _this.portId = params.portId;
      _this.elementId = params.elementId;
      _this.connectionCost = params.connectionCost == null ? 1 : params.connectionCost;
      _this.connectionsDirected = params.connectionsDirected;
      _this.currentAnchorClass = "";
      _this.events = {};
      _this.connectorOverlays = params.connectorOverlays;
      _this.connectorStyle = params.connectorStyle;
      _this.connectorHoverStyle = params.connectorHoverStyle;
      _this.connector = params.connector;
      _this.edgeType = params.edgeType;
      _this.connectorClass = params.connectorClass;
      _this.connectorHoverClass = params.connectorHoverClass;
      _this.deleteOnEmpty = params.deleteOnEmpty === true;
      _this.isSource = params.source || false;
      _this.isTemporarySource = params.isTemporarySource || false;
      _this.isTarget = params.target || false;
      _this.connections = params.connections || [];
      _this.scope = params.scope || instance.defaultScope;
      _this.timestamp = null;
      _this.reattachConnections = params.reattachConnections || instance.defaults.reattachConnections;
      _this.connectionsDetachable = instance.defaults.connectionsDetachable;
      if (params.connectionsDetachable === false) {
        _this.connectionsDetachable = false;
      }
      _this.dragAllowedWhenFull = params.dragAllowedWhenFull !== false;
      if (params.onMaxConnections) {
        _this.bind(EVENT_MAX_CONNECTIONS, params.onMaxConnections);
      }
      var ep = params.endpoint || params.existingEndpoint || instance.defaults.endpoint;
      _this.setEndpoint(ep);
      if (params.preparedAnchor != null) {
        _this.setPreparedAnchor(params.preparedAnchor);
      } else {
        var anchorParamsToUse = params.anchor ? params.anchor : params.anchors ? params.anchors : instance.defaults.anchor || AnchorLocations.Top;
        _this.setAnchor(anchorParamsToUse);
      }
      var type = [DEFAULT$1, params.type || ""].join(" ");
      _this.addType(type, params.data);
      return _this;
    }
    _createClass$f(Endpoint, [{
      key: "getIdPrefix",
      value: function getIdPrefix() {
        return "_jsplumb_e";
      }
    }, {
      key: "getTypeDescriptor",
      value: function getTypeDescriptor() {
        return "endpoint";
      }
    }, {
      key: "getXY",
      value: function getXY() {
        return {
          x: this.endpoint.x,
          y: this.endpoint.y
        };
      }
    }, {
      key: "getDefaultOverlayKey",
      value: function getDefaultOverlayKey() {
        return "endpointOverlays";
      }
    }, {
      key: "_updateAnchorClass",
      value: function _updateAnchorClass() {
        var ac = this._anchor && this._anchor.cssClass;
        if (ac != null && ac.length > 0) {
          var oldAnchorClass = this.instance.endpointAnchorClassPrefix + "-" + this.currentAnchorClass;
          this.currentAnchorClass = ac;
          var anchorClass = this.instance.endpointAnchorClassPrefix + (this.currentAnchorClass ? "-" + this.currentAnchorClass : "");
          if (oldAnchorClass !== anchorClass) {
            this.removeClass(oldAnchorClass);
            this.addClass(anchorClass);
            this.instance.removeClass(this.element, oldAnchorClass);
            this.instance.addClass(this.element, anchorClass);
          }
        }
      }
    }, {
      key: "setPreparedAnchor",
      value: function setPreparedAnchor(anchor) {
        this.instance.router.setAnchor(this, anchor);
        this._updateAnchorClass();
        return this;
      }
    }, {
      key: "_anchorLocationChanged",
      value: function _anchorLocationChanged(currentAnchor) {
        this.fire(EVENT_ANCHOR_CHANGED, {
          endpoint: this,
          anchor: currentAnchor
        });
        this._updateAnchorClass();
      }
    }, {
      key: "setAnchor",
      value: function setAnchor(anchorParams) {
        var a = this.instance.router.prepareAnchor(anchorParams);
        this.setPreparedAnchor(a);
        return this;
      }
    }, {
      key: "addConnection",
      value: function addConnection(conn) {
        var wasFull = this.isFull();
        var wasEmpty = this.connections.length === 0;
        this.connections.push(conn);
        if (wasEmpty) {
          this.addClass(this.instance.endpointConnectedClass);
        }
        if (this.isFull()) {
          if (!wasFull) {
            this.addClass(this.instance.endpointFullClass);
          }
        } else if (wasFull) {
          this.removeClass(this.instance.endpointFullClass);
        }
      }
    }, {
      key: "detachFromConnection",
      value: function detachFromConnection(connection, idx, transientDetach) {
        idx = idx == null ? this.connections.indexOf(connection) : idx;
        if (idx >= 0) {
          this.connections.splice(idx, 1);
          this.instance._refreshEndpoint(this);
        }
        if (!transientDetach && this.deleteOnEmpty && this.connections.length === 0) {
          this.instance.deleteEndpoint(this);
        }
      }
    }, {
      key: "deleteEveryConnection",
      value: function deleteEveryConnection(params) {
        var c = this.connections.length;
        for (var i = 0; i < c; i++) {
          this.instance.deleteConnection(this.connections[0], params);
        }
      }
    }, {
      key: "detachFrom",
      value: function detachFrom(otherEndpoint) {
        var c = [];
        for (var i = 0; i < this.connections.length; i++) {
          if (this.connections[i].endpoints[1] === otherEndpoint || this.connections[i].endpoints[0] === otherEndpoint) {
            c.push(this.connections[i]);
          }
        }
        for (var j = 0, count = c.length; j < count; j++) {
          this.instance.deleteConnection(c[0]);
        }
        return this;
      }
    }, {
      key: "setVisible",
      value: function setVisible(v, doNotChangeConnections, doNotNotifyOtherEndpoint) {
        _get$4(_getPrototypeOf$a(Endpoint.prototype), "setVisible", this).call(this, v);
        this.endpoint.setVisible(v);
        if (v) {
          this.showOverlays();
        } else {
          this.hideOverlays();
        }
        if (!doNotChangeConnections) {
          for (var i = 0; i < this.connections.length; i++) {
            this.connections[i].setVisible(v);
            if (!doNotNotifyOtherEndpoint) {
              var oIdx = this === this.connections[i].endpoints[0] ? 1 : 0;
              if (this.connections[i].endpoints[oIdx].connections.length === 1) {
                this.connections[i].endpoints[oIdx].setVisible(v, true, true);
              }
            }
          }
        }
      }
    }, {
      key: "applyType",
      value: function applyType(t, typeMap) {
        _get$4(_getPrototypeOf$a(Endpoint.prototype), "applyType", this).call(this, t, typeMap);
        this.setPaintStyle(t.endpointStyle || t.paintStyle);
        this.setHoverPaintStyle(t.endpointHoverStyle || t.hoverPaintStyle);
        this.connectorStyle = t.connectorStyle;
        this.connectorHoverStyle = t.connectorHoverStyle;
        this.connector = t.connector;
        this.connectorOverlays = t.connectorOverlays;
        this.edgeType = t.edgeType;
        if (t.maxConnections != null) {
          this.maxConnections = t.maxConnections;
        }
        if (t.scope) {
          this.scope = t.scope;
        }
        extend(t, typeParameters);
        this.instance.applyEndpointType(this, t);
      }
    }, {
      key: "destroy",
      value: function destroy() {
        _get$4(_getPrototypeOf$a(Endpoint.prototype), "destroy", this).call(this);
        this.deleted = true;
        if (this.endpoint != null) {
          this.instance.destroyEndpoint(this);
        }
      }
    }, {
      key: "isFull",
      value: function isFull() {
        return this.maxConnections === 0 ? true : !(this.isFloating() || this.maxConnections < 0 || this.connections.length < this.maxConnections);
      }
    }, {
      key: "isFloating",
      value: function isFloating() {
        return this.instance.router.isFloating(this);
      }
    }, {
      key: "isConnectedTo",
      value: function isConnectedTo(otherEndpoint) {
        var found = false;
        if (otherEndpoint) {
          for (var i = 0; i < this.connections.length; i++) {
            if (this.connections[i].endpoints[1] === otherEndpoint || this.connections[i].endpoints[0] === otherEndpoint) {
              found = true;
              break;
            }
          }
        }
        return found;
      }
    }, {
      key: "setDragAllowedWhenFull",
      value: function setDragAllowedWhenFull(allowed) {
        this.dragAllowedWhenFull = allowed;
      }
    }, {
      key: "getUuid",
      value: function getUuid() {
        return this.uuid;
      }
    }, {
      key: "connectorSelector",
      value: function connectorSelector() {
        return this.connections[0];
      }
    }, {
      key: "prepareEndpoint",
      value: function prepareEndpoint(ep, typeId) {
        var endpointArgs = {
          cssClass: this.cssClass,
          endpoint: this
        };
        var endpoint;
        if (isAssignableFrom(ep, EndpointRepresentation)) {
          var epr = ep;
          endpoint = EndpointFactory.clone(epr);
        } else if (isString(ep)) {
          endpoint = EndpointFactory.get(this, ep, endpointArgs);
        } else {
          var fep = ep;
          extend(endpointArgs, fep.options || {});
          endpoint = EndpointFactory.get(this, fep.type, endpointArgs);
        }
        endpoint.typeId = typeId;
        return endpoint;
      }
    }, {
      key: "setEndpoint",
      value: function setEndpoint(ep) {
        var _ep = this.prepareEndpoint(ep);
        this.setPreparedEndpoint(_ep);
      }
    }, {
      key: "setPreparedEndpoint",
      value: function setPreparedEndpoint(ep) {
        if (this.endpoint != null) {
          this.instance.destroyEndpoint(this);
        }
        this.endpoint = ep;
      }
    }, {
      key: "addClass",
      value: function addClass(clazz, cascade) {
        _get$4(_getPrototypeOf$a(Endpoint.prototype), "addClass", this).call(this, clazz, cascade);
        if (this.endpoint != null) {
          this.endpoint.addClass(clazz);
        }
      }
    }, {
      key: "removeClass",
      value: function removeClass(clazz, cascade) {
        _get$4(_getPrototypeOf$a(Endpoint.prototype), "removeClass", this).call(this, clazz, cascade);
        if (this.endpoint != null) {
          this.endpoint.removeClass(clazz);
        }
      }
    }]);
    return Endpoint;
  }(Component);

  var UINode = function UINode(instance, el) {
    _classCallCheck$f(this, UINode);
    this.instance = instance;
    this.el = el;
    _defineProperty$e(this, "group", void 0);
  };
  var UIGroup = function (_UINode) {
    _inherits$a(UIGroup, _UINode);
    var _super = _createSuper$a(UIGroup);
    function UIGroup(instance, el, options) {
      var _this;
      _classCallCheck$f(this, UIGroup);
      _this = _super.call(this, instance, el);
      _this.instance = instance;
      _defineProperty$e(_assertThisInitialized$a(_this), "children", []);
      _defineProperty$e(_assertThisInitialized$a(_this), "collapsed", false);
      _defineProperty$e(_assertThisInitialized$a(_this), "droppable", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "enabled", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "orphan", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "constrain", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "proxied", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "ghost", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "revert", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "prune", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "dropOverride", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "anchor", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "endpoint", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "connections", {
        source: [],
        target: [],
        internal: []
      });
      _defineProperty$e(_assertThisInitialized$a(_this), "manager", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "id", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "elId", void 0);
      var jel = _this.el;
      jel._isJsPlumbGroup = true;
      jel._jsPlumbGroup = _assertThisInitialized$a(_this);
      _this.elId = instance.getId(el);
      _this.orphan = options.orphan === true;
      _this.revert = _this.orphan === true ? false : options.revert !== false;
      _this.droppable = options.droppable !== false;
      _this.ghost = options.ghost === true;
      _this.enabled = options.enabled !== false;
      _this.prune = _this.orphan !== true && options.prune === true;
      _this.constrain = _this.ghost || options.constrain === true;
      _this.proxied = options.proxied !== false;
      _this.id = options.id || uuid();
      _this.dropOverride = options.dropOverride === true;
      _this.anchor = options.anchor;
      _this.endpoint = options.endpoint;
      _this.anchor = options.anchor;
      instance.setAttribute(el, ATTRIBUTE_GROUP, "");
      return _this;
    }
    _createClass$f(UIGroup, [{
      key: "overrideDrop",
      value: function overrideDrop(el, targetGroup) {
        return this.dropOverride && (this.revert || this.prune || this.orphan);
      }
    }, {
      key: "getAnchor",
      value: function getAnchor(conn, endpointIndex) {
        return this.anchor || "Continuous";
      }
    }, {
      key: "getEndpoint",
      value: function getEndpoint(conn, endpointIndex) {
        return this.endpoint || {
          type: DotEndpoint.type,
          options: {
            radius: 10
          }
        };
      }
    }, {
      key: "add",
      value: function add(_el, doNotFireEvent) {
        var dragArea = this.instance.getGroupContentArea(this);
        var __el = _el;
        if (__el._jsPlumbParentGroup != null) {
          if (__el._jsPlumbParentGroup === this) {
            return;
          } else {
            __el._jsPlumbParentGroup.remove(_el, true, doNotFireEvent, false);
          }
        }
        __el._jsPlumbParentGroup = this;
        this.children.push(new UINode(this.instance, _el));
        this.instance._appendElement(__el, dragArea);
        this.manager._updateConnectionsForGroup(this);
      }
    }, {
      key: "resolveNode",
      value: function resolveNode(el) {
        return el == null ? null : getWithFunction(this.children, function (u) {
          return u.el === el;
        });
      }
    }, {
      key: "remove",
      value: function remove(el, manipulateDOM, doNotFireEvent, doNotUpdateConnections, targetGroup) {
        var uiNode = this.resolveNode(el);
        if (uiNode != null) {
          this._doRemove(uiNode, manipulateDOM, doNotFireEvent, doNotUpdateConnections, targetGroup);
        }
      }
    }, {
      key: "_doRemove",
      value: function _doRemove(child, manipulateDOM, doNotFireEvent, doNotUpdateConnections, targetGroup) {
        var __el = child.el;
        delete __el._jsPlumbParentGroup;
        removeWithFunction(this.children, function (e) {
          return e === child;
        });
        if (manipulateDOM) {
          try {
            this.instance.getGroupContentArea(this).removeChild(__el);
          } catch (e) {
            log("Could not remove element from Group " + e);
          }
        }
        if (!doNotFireEvent) {
          var p = {
            group: this,
            el: __el
          };
          if (targetGroup) {
            p.targetGroup = targetGroup;
          }
          this.instance.fire(EVENT_GROUP_MEMBER_REMOVED$1, p);
        }
        if (!doNotUpdateConnections) {
          this.manager._updateConnectionsForGroup(this);
        }
      }
    }, {
      key: "removeAll",
      value: function removeAll(manipulateDOM, doNotFireEvent) {
        for (var i = 0, l = this.children.length; i < l; i++) {
          var child = this.children[0];
          this._doRemove(child, manipulateDOM, doNotFireEvent, true);
          this.instance.unmanage(child.el, true);
        }
        this.children.length = 0;
        this.manager._updateConnectionsForGroup(this);
      }
    }, {
      key: "orphanAll",
      value: function orphanAll() {
        var orphanedPositions = {};
        for (var i = 0; i < this.children.length; i++) {
          var newPosition = this.manager.orphan(this.children[i].el, false);
          orphanedPositions[newPosition.id] = newPosition.pos;
        }
        this.children.length = 0;
        return orphanedPositions;
      }
    }, {
      key: "addGroup",
      value: function addGroup(group) {
        if (this.instance.allowNestedGroups && group !== this) {
          if (this.instance.groupManager.isAncestor(this, group)) {
            return false;
          }
          if (group.group != null) {
            group.group.removeGroup(group);
          }
          var groupElId = this.instance.getId(group.el);
          var entry = this.instance.getManagedElements()[groupElId];
          entry.group = this.elId;
          var elpos = this.instance.getOffsetRelativeToRoot(group.el);
          var cpos = this.collapsed ? this.instance.getOffsetRelativeToRoot(this.el) : this.instance.getOffsetRelativeToRoot(this.instance.getGroupContentArea(this));
          group.el._jsPlumbParentGroup = this;
          this.children.push(group);
          this.instance._appendElement(group.el, this.instance.getGroupContentArea(this));
          group.group = this;
          var newPosition = {
            x: elpos.x - cpos.x,
            y: elpos.y - cpos.y
          };
          this.instance.setPosition(group.el, newPosition);
          this.instance.fire(EVENT_NESTED_GROUP_ADDED, {
            parent: this,
            child: group
          });
          return true;
        } else {
          return false;
        }
      }
    }, {
      key: "removeGroup",
      value: function removeGroup(group) {
        if (group.group === this) {
          var jel = group.el;
          var d = this.instance.getGroupContentArea(this);
          if (d === jel.parentNode) {
            d.removeChild(group.el);
          }
          var groupElId = this.instance.getId(group.el);
          var entry = this.instance.getManagedElements()[groupElId];
          if (entry) {
            delete entry.group;
          }
          this.children = this.children.filter(function (cg) {
            return cg.id !== group.id;
          });
          delete group.group;
          delete jel._jsPlumbParentGroup;
          this.instance.fire(EVENT_NESTED_GROUP_REMOVED, {
            parent: this,
            child: group
          });
        }
      }
    }, {
      key: "getGroups",
      value: function getGroups() {
        return this.children.filter(function (cg) {
          return cg.constructor === UIGroup;
        });
      }
    }, {
      key: "getNodes",
      value: function getNodes() {
        return this.children.filter(function (cg) {
          return cg.constructor === UINode;
        });
      }
    }, {
      key: "collapseParent",
      get: function get() {
        var cg = null;
        if (this.group == null) {
          return null;
        } else {
          var g = this.group;
          while (g != null) {
            if (g.collapsed) {
              cg = g;
            }
            g = g.group;
          }
          return cg;
        }
      }
    }]);
    return UIGroup;
  }(UINode);

  var GroupManager = function () {
    function GroupManager(instance) {
      var _this = this;
      _classCallCheck$f(this, GroupManager);
      this.instance = instance;
      _defineProperty$e(this, "groupMap", {});
      _defineProperty$e(this, "_connectionSourceMap", {});
      _defineProperty$e(this, "_connectionTargetMap", {});
      instance.bind(EVENT_INTERNAL_CONNECTION, function (p) {
        var sourceGroup = _this.getGroupFor(p.source);
        var targetGroup = _this.getGroupFor(p.target);
        if (sourceGroup != null && targetGroup != null && sourceGroup === targetGroup) {
          _this._connectionSourceMap[p.connection.id] = sourceGroup;
          _this._connectionTargetMap[p.connection.id] = sourceGroup;
          suggest(sourceGroup.connections.internal, p.connection);
        } else {
          if (sourceGroup != null) {
            if (p.target._jsPlumbGroup === sourceGroup) {
              suggest(sourceGroup.connections.internal, p.connection);
            } else {
              suggest(sourceGroup.connections.source, p.connection);
            }
            _this._connectionSourceMap[p.connection.id] = sourceGroup;
          }
          if (targetGroup != null) {
            if (p.source._jsPlumbGroup === targetGroup) {
              suggest(targetGroup.connections.internal, p.connection);
            } else {
              suggest(targetGroup.connections.target, p.connection);
            }
            _this._connectionTargetMap[p.connection.id] = targetGroup;
          }
        }
      });
      instance.bind(EVENT_INTERNAL_CONNECTION_DETACHED, function (p) {
        _this._cleanupDetachedConnection(p.connection);
      });
      instance.bind(EVENT_CONNECTION_MOVED, function (p) {
        var originalElement = p.originalEndpoint.element,
            originalGroup = _this.getGroupFor(originalElement),
            newEndpoint = p.connection.endpoints[p.index],
            newElement = newEndpoint.element,
            newGroup = _this.getGroupFor(newElement),
            connMap = p.index === 0 ? _this._connectionSourceMap : _this._connectionTargetMap,
            otherConnMap = p.index === 0 ? _this._connectionTargetMap : _this._connectionSourceMap;
        if (newGroup != null) {
          connMap[p.connection.id] = newGroup;
          if (p.connection.source === p.connection.target) {
            otherConnMap[p.connection.id] = newGroup;
          }
        } else {
          delete connMap[p.connection.id];
          if (p.connection.source === p.connection.target) {
            delete otherConnMap[p.connection.id];
          }
        }
        if (originalGroup != null) {
          _this._updateConnectionsForGroup(originalGroup);
        }
        if (newGroup != null) {
          _this._updateConnectionsForGroup(newGroup);
        }
      });
    }
    _createClass$f(GroupManager, [{
      key: "_cleanupDetachedConnection",
      value: function _cleanupDetachedConnection(conn) {
        conn.proxies.length = 0;
        var group = this._connectionSourceMap[conn.id],
            f;
        if (group != null) {
          f = function f(c) {
            return c.id === conn.id;
          };
          removeWithFunction(group.connections.source, f);
          removeWithFunction(group.connections.target, f);
          removeWithFunction(group.connections.internal, f);
          delete this._connectionSourceMap[conn.id];
        }
        group = this._connectionTargetMap[conn.id];
        if (group != null) {
          f = function f(c) {
            return c.id === conn.id;
          };
          removeWithFunction(group.connections.source, f);
          removeWithFunction(group.connections.target, f);
          removeWithFunction(group.connections.internal, f);
          delete this._connectionTargetMap[conn.id];
        }
      }
    }, {
      key: "addGroup",
      value: function addGroup(params) {
        var jel = params.el;
        if (this.groupMap[params.id] != null) {
          throw new Error("cannot create Group [" + params.id + "]; a Group with that ID exists");
        }
        if (jel._isJsPlumbGroup != null) {
          throw new Error("cannot create Group [" + params.id + "]; the given element is already a Group");
        }
        var group = new UIGroup(this.instance, params.el, params);
        this.groupMap[group.id] = group;
        if (params.collapsed) {
          this.collapseGroup(group);
        }
        this.instance.manage(group.el);
        this.instance.addClass(group.el, CLASS_GROUP_EXPANDED);
        group.manager = this;
        this._updateConnectionsForGroup(group);
        this.instance.fire(EVENT_GROUP_ADDED$1, {
          group: group
        });
        return group;
      }
    }, {
      key: "getGroup",
      value: function getGroup(groupId) {
        var group = groupId;
        if (isString(groupId)) {
          group = this.groupMap[groupId];
          if (group == null) {
            throw new Error("No such group [" + groupId + "]");
          }
        }
        return group;
      }
    }, {
      key: "getGroupFor",
      value: function getGroupFor(el) {
        var jel = el;
        var c = this.instance.getContainer();
        var abort = false,
            g = null;
        while (!abort) {
          if (jel == null || jel === c) {
            abort = true;
          } else {
            if (jel._jsPlumbParentGroup) {
              g = jel._jsPlumbParentGroup;
              abort = true;
            } else {
              jel = jel.parentNode;
            }
          }
        }
        return g;
      }
    }, {
      key: "getGroups",
      value: function getGroups() {
        var g = [];
        for (var key in this.groupMap) {
          g.push(this.groupMap[key]);
        }
        return g;
      }
    }, {
      key: "removeGroup",
      value: function removeGroup(group, deleteMembers, manipulateView, doNotFireEvent) {
        var _this2 = this;
        var actualGroup = this.getGroup(group);
        this.expandGroup(actualGroup, true);
        var newPositions = {};
        forEach(actualGroup.children, function (uiNode) {
          var entry = _this2.instance.getManagedElements()[_this2.instance.getId(uiNode.el)];
          if (entry) {
            delete entry.group;
          }
        });
        if (deleteMembers) {
          forEach(actualGroup.getGroups(), function (cg) {
            return _this2.removeGroup(cg, deleteMembers, manipulateView);
          });
          actualGroup.removeAll(manipulateView, doNotFireEvent);
        } else {
          if (actualGroup.group) {
            forEach(actualGroup.children, function (c) {
              return actualGroup.group.add(c.el);
            });
          }
          newPositions = actualGroup.orphanAll();
        }
        if (actualGroup.group) {
          actualGroup.group.removeGroup(actualGroup);
        }
        this.instance.unmanage(actualGroup.el, true);
        delete this.groupMap[actualGroup.id];
        this.instance.fire(EVENT_GROUP_REMOVED$1, {
          group: actualGroup
        });
        return newPositions;
      }
    }, {
      key: "removeAllGroups",
      value: function removeAllGroups(deleteMembers, manipulateView, doNotFireEvent) {
        for (var _g in this.groupMap) {
          this.removeGroup(this.groupMap[_g], deleteMembers, manipulateView, doNotFireEvent);
        }
      }
    }, {
      key: "forEach",
      value: function forEach(f) {
        for (var key in this.groupMap) {
          f(this.groupMap[key]);
        }
      }
    }, {
      key: "orphan",
      value: function orphan(el, doNotTransferToAncestor) {
        var jel = el;
        if (jel._jsPlumbParentGroup) {
          var currentParent = jel._jsPlumbParentGroup;
          var positionRelativeToGroup = this.instance.getOffset(jel);
          var id = this.instance.getId(jel);
          var pos = this.instance.getOffset(el);
          jel.parentNode.removeChild(jel);
          if (doNotTransferToAncestor !== true && currentParent.group) {
            pos.x += positionRelativeToGroup.x;
            pos.y += positionRelativeToGroup.y;
            this.instance.getGroupContentArea(currentParent.group).appendChild(el);
          } else {
            this.instance._appendElement(el, this.instance.getContainer());
          }
          this.instance.setPosition(el, pos);
          delete jel._jsPlumbParentGroup;
          return {
            id: id,
            pos: pos
          };
        }
      }
    }, {
      key: "_updateConnectionsForGroup",
      value: function _updateConnectionsForGroup(group) {
        var _this3 = this;
        group.connections.source.length = 0;
        group.connections.target.length = 0;
        group.connections.internal.length = 0;
        var members = group.children.slice().map(function (cn) {
          return cn.el;
        });
        var childMembers = [];
        forEach(members, function (member) {
          Array.prototype.push.apply(childMembers, _this3.instance.getSelector(member, SELECTOR_MANAGED_ELEMENT));
        });
        Array.prototype.push.apply(members, childMembers);
        if (members.length > 0) {
          var c1 = this.instance.getConnections({
            source: members,
            scope: WILDCARD
          }, true);
          var c2 = this.instance.getConnections({
            target: members,
            scope: WILDCARD
          }, true);
          var processed = {};
          var gs, gt;
          var oneSet = function oneSet(c) {
            for (var i = 0; i < c.length; i++) {
              if (processed[c[i].id]) {
                continue;
              }
              processed[c[i].id] = true;
              gs = _this3.getGroupFor(c[i].source);
              gt = _this3.getGroupFor(c[i].target);
              if (c[i].source === group.el && gt === group || c[i].target === group.el && gs === group) {
                group.connections.internal.push(c[i]);
              } else if (gs === group) {
                if (gt !== group) {
                  group.connections.source.push(c[i]);
                } else {
                  group.connections.internal.push(c[i]);
                }
                _this3._connectionSourceMap[c[i].id] = group;
              } else if (gt === group) {
                group.connections.target.push(c[i]);
                _this3._connectionTargetMap[c[i].id] = group;
              }
            }
          };
          oneSet(c1);
          oneSet(c2);
        }
      }
    }, {
      key: "_collapseConnection",
      value: function _collapseConnection(conn, index, group) {
        var otherEl = conn.endpoints[index === 0 ? 1 : 0].element;
        if (otherEl._jsPlumbParentGroup && !otherEl._jsPlumbParentGroup.proxied && otherEl._jsPlumbParentGroup.collapsed) {
          return false;
        }
        var es = conn.endpoints[0].element,
            esg = es._jsPlumbParentGroup,
            esgcp = esg != null ? esg.collapseParent || esg : null,
            et = conn.endpoints[1].element,
            etg = et._jsPlumbParentGroup,
            etgcp = etg != null ? etg.collapseParent || etg : null;
        if (esgcp == null || etgcp == null || esgcp.id !== etgcp.id) {
          var groupEl = group.el;
              this.instance.getId(groupEl);
          this.instance.proxyConnection(conn, index, groupEl,
          function (conn, index) {
            return group.getEndpoint(conn, index);
          }, function (conn, index) {
            return group.getAnchor(conn, index);
          });
          return true;
        } else {
          return false;
        }
      }
    }, {
      key: "_expandConnection",
      value: function _expandConnection(c, index, group) {
        this.instance.unproxyConnection(c, index);
      }
    }, {
      key: "isElementDescendant",
      value: function isElementDescendant(el, parentEl) {
        var c = this.instance.getContainer();
        var abort = false;
        while (!abort) {
          if (el == null || el === c) {
            return false;
          } else {
            if (el === parentEl) {
              return true;
            } else {
              el = el.parentNode;
            }
          }
        }
      }
    }, {
      key: "collapseGroup",
      value: function collapseGroup(group) {
        var _this4 = this;
        var actualGroup = this.getGroup(group);
        if (actualGroup == null || actualGroup.collapsed) {
          return;
        }
        var groupEl = actualGroup.el;
        if (actualGroup.collapseParent == null) {
          this.instance.setGroupVisible(actualGroup, false);
          actualGroup.collapsed = true;
          this.instance.removeClass(groupEl, CLASS_GROUP_EXPANDED);
          this.instance.addClass(groupEl, CLASS_GROUP_COLLAPSED);
          if (actualGroup.proxied) {
            var collapsedConnectionIds = new Set();
            var _collapseSet = function _collapseSet(conns, index) {
              for (var i = 0; i < conns.length; i++) {
                var c = conns[i];
                if (_this4._collapseConnection(c, index, actualGroup) === true) {
                  collapsedConnectionIds.add(c.id);
                }
              }
            };
            _collapseSet(actualGroup.connections.source, 0);
            _collapseSet(actualGroup.connections.target, 1);
            forEach(actualGroup.getGroups(), function (cg) {
              _this4.cascadeCollapse(actualGroup, cg, collapsedConnectionIds);
            });
          }
          this.instance.revalidate(groupEl);
          this.repaintGroup(actualGroup);
          this.instance.fire(EVENT_GROUP_COLLAPSE, {
            group: actualGroup
          });
        } else {
          actualGroup.collapsed = true;
          this.instance.removeClass(groupEl, CLASS_GROUP_EXPANDED);
          this.instance.addClass(groupEl, CLASS_GROUP_COLLAPSED);
        }
      }
    }, {
      key: "cascadeCollapse",
      value: function cascadeCollapse(collapsedGroup, targetGroup, collapsedIds) {
        var _this5 = this;
        if (collapsedGroup.proxied) {
          var _collapseSet = function _collapseSet(conns, index) {
            for (var i = 0; i < conns.length; i++) {
              var c = conns[i];
              if (!collapsedIds.has(c.id)) {
                if (_this5._collapseConnection(c, index, collapsedGroup) === true) {
                  collapsedIds.add(c.id);
                }
              }
            }
          };
          _collapseSet(targetGroup.connections.source, 0);
          _collapseSet(targetGroup.connections.target, 1);
        }
        forEach(targetGroup.getGroups(), function (cg) {
          _this5.cascadeCollapse(collapsedGroup, cg, collapsedIds);
        });
      }
    }, {
      key: "expandGroup",
      value: function expandGroup(group, doNotFireEvent) {
        var _this6 = this;
        var actualGroup = this.getGroup(group);
        if (actualGroup == null) {
          return;
        }
        var groupEl = actualGroup.el;
        if (actualGroup.collapseParent == null) {
          this.instance.setGroupVisible(actualGroup, true);
          actualGroup.collapsed = false;
          this.instance.addClass(groupEl, CLASS_GROUP_EXPANDED);
          this.instance.removeClass(groupEl, CLASS_GROUP_COLLAPSED);
          if (actualGroup.proxied) {
            var _expandSet = function _expandSet(conns, index) {
              for (var i = 0; i < conns.length; i++) {
                var c = conns[i];
                _this6._expandConnection(c, index, actualGroup);
              }
            };
            _expandSet(actualGroup.connections.source, 0);
            _expandSet(actualGroup.connections.target, 1);
            var _expandNestedGroup = function _expandNestedGroup(group, ignoreCollapsedStateForNested) {
              if (ignoreCollapsedStateForNested || group.collapsed) {
                var _collapseSet = function _collapseSet(conns, index) {
                  for (var i = 0; i < conns.length; i++) {
                    var c = conns[i];
                    _this6._collapseConnection(c, index, group.collapseParent || group);
                  }
                };
                _collapseSet(group.connections.source, 0);
                _collapseSet(group.connections.target, 1);
                forEach(group.connections.internal, function (c) {
                  return c.setVisible(false);
                });
                forEach(group.getGroups(), function (g) {
                  return _expandNestedGroup(g, true);
                });
              } else {
                _this6.expandGroup(group, true);
              }
            };
            forEach(actualGroup.getGroups(), _expandNestedGroup);
          }
          this.instance.revalidate(groupEl);
          this.repaintGroup(actualGroup);
          if (!doNotFireEvent) {
            this.instance.fire(EVENT_GROUP_EXPAND, {
              group: actualGroup
            });
          }
        } else {
          actualGroup.collapsed = false;
          this.instance.addClass(groupEl, CLASS_GROUP_EXPANDED);
          this.instance.removeClass(groupEl, CLASS_GROUP_COLLAPSED);
        }
      }
    }, {
      key: "toggleGroup",
      value: function toggleGroup(group) {
        group = this.getGroup(group);
        if (group != null) {
          if (group.collapsed) {
            this.expandGroup(group);
          } else {
            this.collapseGroup(group);
          }
        }
      }
    }, {
      key: "repaintGroup",
      value: function repaintGroup(group) {
        var actualGroup = this.getGroup(group);
        var m = actualGroup.children;
        for (var i = 0; i < m.length; i++) {
          this.instance.revalidate(m[i].el);
        }
      }
    }, {
      key: "addToGroup",
      value: function addToGroup(group, doNotFireEvent) {
        var _this7 = this;
        var actualGroup = this.getGroup(group);
        if (actualGroup) {
          var groupEl = actualGroup.el;
          var _one = function _one(el) {
            var jel = el;
            var isGroup = jel._isJsPlumbGroup != null,
                droppingGroup = jel._jsPlumbGroup;
            var currentGroup = jel._jsPlumbParentGroup;
            if (currentGroup !== actualGroup) {
              var entry = _this7.instance.manage(el);
              var elpos = _this7.instance.getOffset(el);
              var cpos = actualGroup.collapsed ? _this7.instance.getOffsetRelativeToRoot(groupEl) : _this7.instance.getOffset(_this7.instance.getGroupContentArea(actualGroup));
              entry.group = actualGroup.elId;
              if (currentGroup != null) {
                currentGroup.remove(el, false, doNotFireEvent, false, actualGroup);
                _this7._updateConnectionsForGroup(currentGroup);
              }
              if (isGroup) {
                actualGroup.addGroup(droppingGroup);
              } else {
                actualGroup.add(el, doNotFireEvent);
              }
              var handleDroppedConnections = function handleDroppedConnections(list, index) {
                var oidx = index === 0 ? 1 : 0;
                list.each(function (c) {
                  c.setVisible(false);
                  if (c.endpoints[oidx].element._jsPlumbGroup === actualGroup) {
                    c.endpoints[oidx].setVisible(false);
                    _this7._expandConnection(c, oidx, actualGroup);
                  } else {
                    c.endpoints[index].setVisible(false);
                    _this7._collapseConnection(c, index, actualGroup);
                  }
                });
              };
              if (actualGroup.collapsed) {
                handleDroppedConnections(_this7.instance.select({
                  source: el
                }), 0);
                handleDroppedConnections(_this7.instance.select({
                  target: el
                }), 1);
              }
              _this7.instance.getId(el);
              var newPosition = {
                x: elpos.x - cpos.x,
                y: elpos.y - cpos.y
              };
              _this7.instance.setPosition(el, newPosition);
              _this7._updateConnectionsForGroup(actualGroup);
              _this7.instance.revalidate(el);
              if (!doNotFireEvent) {
                var p = {
                  group: actualGroup,
                  el: el,
                  pos: newPosition
                };
                if (currentGroup) {
                  p.sourceGroup = currentGroup;
                }
                _this7.instance.fire(EVENT_GROUP_MEMBER_ADDED$1, p);
              }
            }
          };
          for (var _len = arguments.length, el = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            el[_key - 2] = arguments[_key];
          }
          forEach(el, _one);
        }
      }
    }, {
      key: "removeFromGroup",
      value: function removeFromGroup(group, doNotFireEvent) {
        var _this8 = this;
        var actualGroup = this.getGroup(group);
        if (actualGroup) {
          var _one = function _one(_el) {
            if (actualGroup.collapsed) {
              var _expandSet = function _expandSet(conns, index) {
                for (var i = 0; i < conns.length; i++) {
                  var c = conns[i];
                  if (c.proxies) {
                    for (var j = 0; j < c.proxies.length; j++) {
                      if (c.proxies[j] != null) {
                        var proxiedElement = c.proxies[j].originalEp.element;
                        if (proxiedElement === _el || _this8.isElementDescendant(proxiedElement, _el)) {
                          _this8._expandConnection(c, index, actualGroup);
                        }
                      }
                    }
                  }
                }
              };
              _expandSet(actualGroup.connections.source.slice(), 0);
              _expandSet(actualGroup.connections.target.slice(), 1);
            }
            actualGroup.remove(_el, null, doNotFireEvent);
            var entry = _this8.instance.getManagedElements()[_this8.instance.getId(_el)];
            if (entry) {
              delete entry.group;
            }
          };
          for (var _len2 = arguments.length, el = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
            el[_key2 - 2] = arguments[_key2];
          }
          forEach(el, _one);
        }
      }
    }, {
      key: "getAncestors",
      value: function getAncestors(group) {
        var ancestors = [];
        var p = group.group;
        while (p != null) {
          ancestors.push(p);
          p = p.group;
        }
        return ancestors;
      }
    }, {
      key: "isAncestor",
      value: function isAncestor(group, possibleAncestor) {
        if (group == null || possibleAncestor == null) {
          return false;
        }
        return this.getAncestors(group).indexOf(possibleAncestor) !== -1;
      }
    }, {
      key: "getDescendants",
      value: function getDescendants(group) {
        var d = [];
        var _one = function _one(g) {
          var childGroups = g.getGroups();
          d.push.apply(d, _toConsumableArray$2(childGroups));
          forEach(childGroups, _one);
        };
        _one(group);
        return d;
      }
    }, {
      key: "isDescendant",
      value: function isDescendant(possibleDescendant, ancestor) {
        if (possibleDescendant == null || ancestor == null) {
          return false;
        }
        return this.getDescendants(ancestor).indexOf(possibleDescendant) !== -1;
      }
    }, {
      key: "reset",
      value: function reset() {
        this._connectionSourceMap = {};
        this._connectionTargetMap = {};
        this.groupMap = {};
      }
    }]);
    return GroupManager;
  }();

  var SelectionBase = function () {
    function SelectionBase(instance, entries) {
      _classCallCheck$f(this, SelectionBase);
      this.instance = instance;
      this.entries = entries;
    }
    _createClass$f(SelectionBase, [{
      key: "length",
      get: function get() {
        return this.entries.length;
      }
    }, {
      key: "each",
      value: function each(handler) {
        forEach(this.entries, function (e) {
          return handler(e);
        });
        return this;
      }
    }, {
      key: "get",
      value: function get(index) {
        return this.entries[index];
      }
    }, {
      key: "addClass",
      value: function addClass(clazz, cascade) {
        this.each(function (c) {
          return c.addClass(clazz, cascade);
        });
        return this;
      }
    }, {
      key: "removeClass",
      value: function removeClass(clazz, cascade) {
        this.each(function (c) {
          return c.removeClass(clazz, cascade);
        });
        return this;
      }
    }, {
      key: "removeAllOverlays",
      value: function removeAllOverlays() {
        this.each(function (c) {
          return c.removeAllOverlays();
        });
        return this;
      }
    }, {
      key: "setLabel",
      value: function setLabel(label) {
        this.each(function (c) {
          return c.setLabel(label);
        });
        return this;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.entries.length = 0;
        return this;
      }
    }, {
      key: "map",
      value: function map(fn) {
        var a = [];
        this.each(function (e) {
          return a.push(fn(e));
        });
        return a;
      }
    }, {
      key: "addOverlay",
      value: function addOverlay(spec) {
        this.each(function (c) {
          return c.addOverlay(spec);
        });
        return this;
      }
    }, {
      key: "removeOverlay",
      value: function removeOverlay(id) {
        this.each(function (c) {
          return c.removeOverlay(id);
        });
        return this;
      }
    }, {
      key: "removeOverlays",
      value: function removeOverlays() {
        this.each(function (c) {
          return c.removeOverlays();
        });
        return this;
      }
    }, {
      key: "showOverlay",
      value: function showOverlay(id) {
        this.each(function (c) {
          return c.showOverlay(id);
        });
        return this;
      }
    }, {
      key: "hideOverlay",
      value: function hideOverlay(id) {
        this.each(function (c) {
          return c.hideOverlay(id);
        });
        return this;
      }
    }, {
      key: "setPaintStyle",
      value: function setPaintStyle(style) {
        this.each(function (c) {
          return c.setPaintStyle(style);
        });
        return this;
      }
    }, {
      key: "setHoverPaintStyle",
      value: function setHoverPaintStyle(style) {
        this.each(function (c) {
          return c.setHoverPaintStyle(style);
        });
        return this;
      }
    }, {
      key: "setSuspendEvents",
      value: function setSuspendEvents(suspend) {
        this.each(function (c) {
          return c.setSuspendEvents(suspend);
        });
        return this;
      }
    }, {
      key: "setParameter",
      value: function setParameter(name, value) {
        this.each(function (c) {
          return c.parameters[name] = value;
        });
        return this;
      }
    }, {
      key: "setParameters",
      value: function setParameters(p) {
        this.each(function (c) {
          return c.parameters = p;
        });
        return this;
      }
    }, {
      key: "setVisible",
      value: function setVisible(v) {
        this.each(function (c) {
          return c.setVisible(v);
        });
        return this;
      }
    }, {
      key: "addType",
      value: function addType(name) {
        this.each(function (c) {
          return c.addType(name);
        });
        return this;
      }
    }, {
      key: "toggleType",
      value: function toggleType(name) {
        this.each(function (c) {
          return c.toggleType(name);
        });
        return this;
      }
    }, {
      key: "removeType",
      value: function removeType(name) {
        this.each(function (c) {
          return c.removeType(name);
        });
        return this;
      }
    }, {
      key: "bind",
      value: function bind(evt, handler) {
        this.each(function (c) {
          return c.bind(evt, handler);
        });
        return this;
      }
    }, {
      key: "unbind",
      value: function unbind(evt, handler) {
        this.each(function (c) {
          return c.unbind(evt, handler);
        });
        return this;
      }
    }, {
      key: "setHover",
      value: function setHover(h) {
        var _this = this;
        this.each(function (c) {
          return _this.instance.setHover(c, h);
        });
        return this;
      }
    }]);
    return SelectionBase;
  }();

  var EndpointSelection = function (_SelectionBase) {
    _inherits$a(EndpointSelection, _SelectionBase);
    var _super = _createSuper$a(EndpointSelection);
    function EndpointSelection() {
      _classCallCheck$f(this, EndpointSelection);
      return _super.apply(this, arguments);
    }
    _createClass$f(EndpointSelection, [{
      key: "setEnabled",
      value: function setEnabled(e) {
        this.each(function (ep) {
          return ep.enabled = e;
        });
        return this;
      }
    }, {
      key: "setAnchor",
      value: function setAnchor(a) {
        this.each(function (ep) {
          return ep.setAnchor(a);
        });
        return this;
      }
    }, {
      key: "deleteEveryConnection",
      value: function deleteEveryConnection() {
        this.each(function (ep) {
          return ep.deleteEveryConnection();
        });
        return this;
      }
    }, {
      key: "deleteAll",
      value: function deleteAll() {
        var _this = this;
        this.each(function (ep) {
          return _this.instance.deleteEndpoint(ep);
        });
        this.clear();
        return this;
      }
    }]);
    return EndpointSelection;
  }(SelectionBase);

  var ConnectionSelection = function (_SelectionBase) {
    _inherits$a(ConnectionSelection, _SelectionBase);
    var _super = _createSuper$a(ConnectionSelection);
    function ConnectionSelection() {
      _classCallCheck$f(this, ConnectionSelection);
      return _super.apply(this, arguments);
    }
    _createClass$f(ConnectionSelection, [{
      key: "setDetachable",
      value: function setDetachable(d) {
        this.each(function (c) {
          return c.setDetachable(d);
        });
        return this;
      }
    }, {
      key: "setReattach",
      value: function setReattach(d) {
        this.each(function (c) {
          return c.setReattach(d);
        });
        return this;
      }
    }, {
      key: "setConnector",
      value: function setConnector(spec) {
        this.each(function (c) {
          return c.setConnector(spec);
        });
        return this;
      }
    }, {
      key: "deleteAll",
      value: function deleteAll() {
        var _this = this;
        this.each(function (c) {
          return _this.instance.deleteConnection(c);
        });
        this.clear();
      }
    }, {
      key: "repaint",
      value: function repaint() {
        var _this2 = this;
        this.each(function (c) {
          return _this2.instance._paintConnection(c);
        });
        return this;
      }
    }]);
    return ConnectionSelection;
  }(SelectionBase);

  var Transaction = function Transaction() {
    _classCallCheck$f(this, Transaction);
    _defineProperty$e(this, "affectedElements", new Set());
  };
  function EMPTY_POSITION() {
    return {
      x: 0,
      y: 0,
      w: 0,
      h: 0,
      r: 0,
      c: {
        x: 0,
        y: 0
      },
      x2: 0,
      y2: 0,
      t: {
        x: 0,
        y: 0,
        c: {
          x: 0,
          y: 0
        },
        w: 0,
        h: 0,
        r: 0,
        x2: 0,
        y2: 0,
        cr: 0,
        sr: 0
      },
      dirty: true
    };
  }
  function rotate(x, y, w, h, r) {
    var center = {
      x: x + w / 2,
      y: y + h / 2
    },
        cr = Math.cos(r / 360 * Math.PI * 2),
        sr = Math.sin(r / 360 * Math.PI * 2),
        _point = function _point(x, y) {
      return {
        x: center.x + Math.round((x - center.x) * cr - (y - center.y) * sr),
        y: center.y + Math.round((y - center.y) * cr - (x - center.x) * sr)
      };
    };
    var p1 = _point(x, y),
        p2 = _point(x + w, y),
        p3 = _point(x + w, y + h),
        p4 = _point(x, y + h),
        c = _point(x + w / 2, y + h / 2);
    var xmin = Math.min(p1.x, p2.x, p3.x, p4.x),
        xmax = Math.max(p1.x, p2.x, p3.x, p4.x),
        ymin = Math.min(p1.y, p2.y, p3.y, p4.y),
        ymax = Math.max(p1.y, p2.y, p3.y, p4.y);
    return {
      x: xmin,
      y: ymin,
      w: xmax - xmin,
      h: ymax - ymin,
      c: c,
      r: r,
      x2: xmax,
      y2: ymax,
      cr: cr,
      sr: sr
    };
  }
  var entryComparator = function entryComparator(value, arrayEntry) {
    var c = 0;
    if (arrayEntry[1] > value[1]) {
      c = -1;
    } else if (arrayEntry[1] < value[1]) {
      c = 1;
    }
    return c;
  };
  var reverseEntryComparator = function reverseEntryComparator(value, arrayEntry) {
    return entryComparator(value, arrayEntry) * -1;
  };
  function _updateElementIndex(id, value, array, sortDescending) {
    insertSorted([id, value], array, entryComparator, sortDescending);
  }
  function _clearElementIndex(id, array) {
    var idx = findWithFunction(array, function (entry) {
      return entry[0] === id;
    });
    if (idx > -1) {
      array.splice(idx, 1);
    }
  }
  var Viewport = function (_EventGenerator) {
    _inherits$a(Viewport, _EventGenerator);
    var _super = _createSuper$a(Viewport);
    function Viewport(instance) {
      var _this;
      _classCallCheck$f(this, Viewport);
      _this = _super.call(this);
      _this.instance = instance;
      _defineProperty$e(_assertThisInitialized$a(_this), "_currentTransaction", null);
      _defineProperty$e(_assertThisInitialized$a(_this), "_sortedElements", {
        xmin: [],
        xmax: [],
        ymin: [],
        ymax: []
      });
      _defineProperty$e(_assertThisInitialized$a(_this), "_elementMap", new Map());
      _defineProperty$e(_assertThisInitialized$a(_this), "_transformedElementMap", new Map());
      _defineProperty$e(_assertThisInitialized$a(_this), "_bounds", {
        minx: 0,
        maxx: 0,
        miny: 0,
        maxy: 0
      });
      return _this;
    }
    _createClass$f(Viewport, [{
      key: "_updateBounds",
      value: function _updateBounds(id, updatedElement, doNotRecalculateBounds) {
        if (updatedElement != null) {
          _clearElementIndex(id, this._sortedElements.xmin);
          _clearElementIndex(id, this._sortedElements.xmax);
          _clearElementIndex(id, this._sortedElements.ymin);
          _clearElementIndex(id, this._sortedElements.ymax);
          _updateElementIndex(id, updatedElement.t.x, this._sortedElements.xmin, false);
          _updateElementIndex(id, updatedElement.t.x + updatedElement.t.w, this._sortedElements.xmax, true);
          _updateElementIndex(id, updatedElement.t.y, this._sortedElements.ymin, false);
          _updateElementIndex(id, updatedElement.t.y + updatedElement.t.h, this._sortedElements.ymax, true);
          if (doNotRecalculateBounds !== true) {
            this._recalculateBounds();
          }
        }
      }
    }, {
      key: "_recalculateBounds",
      value: function _recalculateBounds() {
        this._bounds.minx = this._sortedElements.xmin.length > 0 ? this._sortedElements.xmin[0][1] : 0;
        this._bounds.maxx = this._sortedElements.xmax.length > 0 ? this._sortedElements.xmax[0][1] : 0;
        this._bounds.miny = this._sortedElements.ymin.length > 0 ? this._sortedElements.ymin[0][1] : 0;
        this._bounds.maxy = this._sortedElements.ymax.length > 0 ? this._sortedElements.ymax[0][1] : 0;
      }
    }, {
      key: "recomputeBounds",
      value: function recomputeBounds() {
        var _this2 = this;
        this._sortedElements.xmin.length = 0;
        this._sortedElements.xmax.length = 0;
        this._sortedElements.ymin.length = 0;
        this._sortedElements.ymax.length = 0;
        this._elementMap.forEach(function (vp, id) {
          _this2._sortedElements.xmin.push([id, vp.t.x]);
          _this2._sortedElements.xmax.push([id, vp.t.x + vp.t.w]);
          _this2._sortedElements.ymin.push([id, vp.t.y]);
          _this2._sortedElements.ymax.push([id, vp.t.y + vp.t.h]);
        });
        this._sortedElements.xmin.sort(entryComparator);
        this._sortedElements.ymin.sort(entryComparator);
        this._sortedElements.xmax.sort(reverseEntryComparator);
        this._sortedElements.ymax.sort(reverseEntryComparator);
        this._recalculateBounds();
      }
    }, {
      key: "_finaliseUpdate",
      value: function _finaliseUpdate(id, e, doNotRecalculateBounds) {
        e.t = rotate(e.x, e.y, e.w, e.h, e.r);
        this._transformedElementMap.set(id, e.t);
        if (doNotRecalculateBounds !== true) {
          this._updateBounds(id, e, doNotRecalculateBounds);
        }
      }
    }, {
      key: "shouldFireEvent",
      value: function shouldFireEvent(event, value, originalEvent) {
        return true;
      }
    }, {
      key: "startTransaction",
      value: function startTransaction() {
        if (this._currentTransaction != null) {
          throw new Error("Viewport: cannot start transaction; a transaction is currently active.");
        }
        this._currentTransaction = new Transaction();
      }
    }, {
      key: "endTransaction",
      value: function endTransaction() {
        var _this3 = this;
        if (this._currentTransaction != null) {
          this._currentTransaction.affectedElements.forEach(function (id) {
            var entry = _this3.getPosition(id);
            _this3._finaliseUpdate(id, entry, true);
          });
          this.recomputeBounds();
          this._currentTransaction = null;
        }
      }
    }, {
      key: "updateElements",
      value: function updateElements(entries) {
        var _this4 = this;
        forEach(entries, function (e) {
          return _this4.updateElement(e.id, e.x, e.y, e.width, e.height, e.rotation);
        });
      }
    }, {
      key: "updateElement",
      value: function updateElement(id, x, y, width, height, rotation, doNotRecalculateBounds) {
        var e = getsert(this._elementMap, id, EMPTY_POSITION);
        e.dirty = x == null && e.x == null || y == null && e.y == null || width == null && e.w == null || height == null && e.h == null;
        if (x != null) {
          e.x = x;
        }
        if (y != null) {
          e.y = y;
        }
        if (width != null) {
          e.w = width;
        }
        if (height != null) {
          e.h = height;
        }
        if (rotation != null) {
          e.r = rotation || 0;
        }
        e.c.x = e.x + e.w / 2;
        e.c.y = e.y + e.h / 2;
        e.x2 = e.x + e.w;
        e.y2 = e.y + e.h;
        if (this._currentTransaction == null) {
          this._finaliseUpdate(id, e, doNotRecalculateBounds);
        } else {
          this._currentTransaction.affectedElements.add(id);
        }
        return e;
      }
    }, {
      key: "refreshElement",
      value: function refreshElement(elId, doNotRecalculateBounds) {
        var me = this.instance.getManagedElements();
        var s = me[elId] ? me[elId].el : null;
        if (s != null) {
          var size = this.getSize(s);
          var offset = this.getOffset(s);
          return this.updateElement(elId, offset.x, offset.y, size.w, size.h, null, doNotRecalculateBounds);
        } else {
          return null;
        }
      }
    }, {
      key: "getSize",
      value: function getSize(el) {
        return this.instance.getSize(el);
      }
    }, {
      key: "getOffset",
      value: function getOffset(el) {
        return this.instance.getOffset(el);
      }
    }, {
      key: "registerElement",
      value: function registerElement(id, doNotRecalculateBounds) {
        return this.updateElement(id, 0, 0, 0, 0, 0, doNotRecalculateBounds);
      }
    }, {
      key: "addElement",
      value: function addElement(id, x, y, width, height, rotation) {
        return this.updateElement(id, x, y, width, height, rotation);
      }
    }, {
      key: "rotateElement",
      value: function rotateElement(id, rotation) {
        var e = getsert(this._elementMap, id, EMPTY_POSITION);
        e.r = rotation || 0;
        this._finaliseUpdate(id, e);
        return e;
      }
    }, {
      key: "getBoundsWidth",
      value: function getBoundsWidth() {
        return this._bounds.maxx - this._bounds.minx;
      }
    }, {
      key: "getBoundsHeight",
      value: function getBoundsHeight() {
        return this._bounds.maxy - this._bounds.miny;
      }
    }, {
      key: "getX",
      value: function getX() {
        return this._bounds.minx;
      }
    }, {
      key: "getY",
      value: function getY() {
        return this._bounds.miny;
      }
    }, {
      key: "setSize",
      value: function setSize(id, w, h) {
        if (this._elementMap.has(id)) {
          return this.updateElement(id, null, null, w, h, null);
        }
      }
    }, {
      key: "setPosition",
      value: function setPosition(id, x, y) {
        if (this._elementMap.has(id)) {
          return this.updateElement(id, x, y, null, null, null);
        }
      }
    }, {
      key: "reset",
      value: function reset() {
        this._sortedElements.xmin.length = 0;
        this._sortedElements.xmax.length = 0;
        this._sortedElements.ymin.length = 0;
        this._sortedElements.ymax.length = 0;
        this._elementMap.clear();
        this._transformedElementMap.clear();
        this._recalculateBounds();
      }
    }, {
      key: "remove",
      value: function remove(id) {
        _clearElementIndex(id, this._sortedElements.xmin);
        _clearElementIndex(id, this._sortedElements.xmax);
        _clearElementIndex(id, this._sortedElements.ymin);
        _clearElementIndex(id, this._sortedElements.ymax);
        this._elementMap["delete"](id);
        this._transformedElementMap["delete"](id);
        this._recalculateBounds();
      }
    }, {
      key: "getPosition",
      value: function getPosition(id) {
        return this._elementMap.get(id);
      }
    }, {
      key: "getElements",
      value: function getElements() {
        return this._elementMap;
      }
    }, {
      key: "isEmpty",
      value: function isEmpty() {
        return this._elementMap.size === 0;
      }
    }]);
    return Viewport;
  }(EventGenerator);

  var ConnectionDragSelector = function () {
    function ConnectionDragSelector(selector, def) {
      var exclude = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      _classCallCheck$f(this, ConnectionDragSelector);
      this.selector = selector;
      this.def = def;
      this.exclude = exclude;
      _defineProperty$e(this, "id", void 0);
      this.id = uuid();
    }
    _createClass$f(ConnectionDragSelector, [{
      key: "setEnabled",
      value: function setEnabled(enabled) {
        this.def.enabled = enabled;
      }
    }, {
      key: "isEnabled",
      value: function isEnabled() {
        return this.def.enabled !== false;
      }
    }]);
    return ConnectionDragSelector;
  }();
  var REDROP_POLICY_STRICT = "strict";
  var REDROP_POLICY_ANY = "any";
  var SourceSelector = function (_ConnectionDragSelect) {
    _inherits$a(SourceSelector, _ConnectionDragSelect);
    var _super = _createSuper$a(SourceSelector);
    function SourceSelector(selector, def, exclude) {
      var _this;
      _classCallCheck$f(this, SourceSelector);
      _this = _super.call(this, selector, def, exclude);
      _this.def = def;
      _defineProperty$e(_assertThisInitialized$a(_this), "redrop", void 0);
      _this.redrop = def.def.redrop || REDROP_POLICY_STRICT;
      return _this;
    }
    return SourceSelector;
  }(ConnectionDragSelector);
  var TargetSelector = function (_ConnectionDragSelect2) {
    _inherits$a(TargetSelector, _ConnectionDragSelect2);
    var _super2 = _createSuper$a(TargetSelector);
    function TargetSelector(selector, def, exclude) {
      var _this2;
      _classCallCheck$f(this, TargetSelector);
      _this2 = _super2.call(this, selector, def, exclude);
      _this2.def = def;
      return _this2;
    }
    return TargetSelector;
  }(ConnectionDragSelector);

  var _edgeSortFunctions;
  function _placeAnchorsOnLine(element, connections, horizontal, otherMultiplier, reverse) {
    var sizeInAxis = horizontal ? element.w : element.h;
    var sizeInOtherAxis = horizontal ? element.h : element.w;
    var a = [],
        step = sizeInAxis / (connections.length + 1);
    for (var i = 0; i < connections.length; i++) {
      var val = (i + 1) * step,
          other = otherMultiplier * sizeInOtherAxis;
      if (reverse) {
        val = sizeInAxis - val;
      }
      var dx = horizontal ? val : other,
          x = element.x + dx,
          xp = dx / element.w;
      var dy = horizontal ? other : val,
          y = element.y + dy,
          yp = dy / element.h;
      if (element.r !== 0 && element.r != null) {
        var rotated = rotatePoint({
          x: x,
          y: y
        }, element.c, element.r);
        x = rotated.x;
        y = rotated.y;
      }
      a.push({
        x: x,
        y: y,
        xLoc: xp,
        yLoc: yp,
        c: connections[i].c
      });
    }
    return a;
  }
  function _rightAndBottomSort(a, b) {
    return b.theta - a.theta;
  }
  function _leftAndTopSort(a, b) {
    var p1 = a.theta < 0 ? -Math.PI - a.theta : Math.PI - a.theta,
        p2 = b.theta < 0 ? -Math.PI - b.theta : Math.PI - b.theta;
    return p1 - p2;
  }
  var edgeSortFunctions = (_edgeSortFunctions = {}, _defineProperty$e(_edgeSortFunctions, TOP$2, _leftAndTopSort), _defineProperty$e(_edgeSortFunctions, RIGHT$1, _rightAndBottomSort), _defineProperty$e(_edgeSortFunctions, BOTTOM$1, _rightAndBottomSort), _defineProperty$e(_edgeSortFunctions, LEFT$2, _leftAndTopSort), _edgeSortFunctions);
  function isContinuous(a) {
    return a.isContinuous === true;
  }
  function _isFloating(a) {
    return a.isContinuous === true;
  }
  function isDynamic(a) {
    return a.locations.length > 1;
  }
  function getCurrentLocation(anchor) {
    return [anchor.currentLocation, anchor.locations[anchor.currentLocation]];
  }
  var LightweightRouter = function () {
    function LightweightRouter(instance) {
      var _this = this;
      _classCallCheck$f(this, LightweightRouter);
      this.instance = instance;
      _defineProperty$e(this, "anchorLists", new Map());
      _defineProperty$e(this, "anchorLocations", new Map());
      instance.bind(EVENT_INTERNAL_CONNECTION_DETACHED, function (p) {
        if (p.sourceEndpoint._anchor.isContinuous) {
          _this._removeEndpointFromAnchorLists(p.sourceEndpoint);
        }
        if (p.targetEndpoint._anchor.isContinuous) {
          _this._removeEndpointFromAnchorLists(p.targetEndpoint);
        }
      });
      instance.bind(EVENT_INTERNAL_ENDPOINT_UNREGISTERED, function (ep) {
        _this._removeEndpointFromAnchorLists(ep);
      });
    }
    _createClass$f(LightweightRouter, [{
      key: "getAnchorOrientation",
      value: function getAnchorOrientation(anchor) {
        var loc = this.anchorLocations.get(anchor.id);
        return loc ? [loc.ox, loc.oy] : [0, 0];
      }
    }, {
      key: "_distance",
      value: function _distance(anchor, cx, cy, xy, wh, rotation, targetRotation) {
        var ax = xy.x + anchor.x * wh.w,
            ay = xy.y + anchor.y * wh.h,
            acx = xy.x + wh.w / 2,
            acy = xy.y + wh.h / 2;
        if (rotation != null && rotation.length > 0) {
          var rotated = this.instance._applyRotations([ax, ay, 0, 0], rotation);
          ax = rotated.x;
          ay = rotated.y;
        }
        return Math.sqrt(Math.pow(cx - ax, 2) + Math.pow(cy - ay, 2)) + Math.sqrt(Math.pow(acx - ax, 2) + Math.pow(acy - ay, 2));
      }
    }, {
      key: "_anchorSelector",
      value: function _anchorSelector(xy, wh, txy, twh, rotation, targetRotation, locations) {
        var cx = txy.x + twh.w / 2,
            cy = txy.y + twh.h / 2;
        var minIdx = -1,
            minDist = Infinity;
        for (var i = 0; i < locations.length; i++) {
          var d = this._distance(locations[i], cx, cy, xy, wh, rotation, targetRotation);
          if (d < minDist) {
            minIdx = i + 0;
            minDist = d;
          }
        }
        return [minIdx, locations[minIdx]];
      }
    }, {
      key: "_floatingAnchorCompute",
      value: function _floatingAnchorCompute(anchor, params) {
        var xy = params.xy;
        var pos = {
          curX: xy.x + anchor.size.w / 2,
          curY: xy.y + anchor.size.h / 2,
          x: 0,
          y: 0,
          ox: 0,
          oy: 0
        };
        return this._setComputedPosition(anchor, pos);
      }
    }, {
      key: "_setComputedPosition",
      value: function _setComputedPosition(anchor, pos, timestamp) {
        this.anchorLocations.set(anchor.id, pos);
        anchor.computedPosition = pos;
        if (timestamp) {
          anchor.timestamp = timestamp;
        }
        return pos;
      }
    }, {
      key: "_computeSingleLocation",
      value: function _computeSingleLocation(loc, xy, wh, params) {
        var candidate = {
          curX: xy.x + loc.x * wh.w + loc.offx,
          curY: xy.y + loc.y * wh.h + loc.offy,
          x: loc.x,
          y: loc.y,
          ox: 0,
          oy: 0
        };
        var pos;
        var rotation = params.rotation;
        if (rotation != null && rotation.length > 0) {
          var o = [loc.iox, loc.ioy],
              current = {
            x: candidate.curX,
            y: candidate.curY,
            cr: 0,
            sr: 0
          };
          forEach(rotation, function (r) {
            current = rotatePoint(current, r.c, r.r);
            var _o = [Math.round(o[0] * current.cr - o[1] * current.sr), Math.round(o[1] * current.cr + o[0] * current.sr)];
            o = _o.slice();
          });
          loc.ox = o[0];
          loc.oy = o[1];
          pos = {
            curX: current.x,
            curY: current.y,
            x: loc.x,
            y: loc.y,
            ox: o[0],
            oy: o[1]
          };
        } else {
          loc.ox = loc.iox;
          loc.oy = loc.ioy;
          pos = extend({
            ox: loc.iox,
            oy: loc.ioy
          }, candidate);
        }
        return pos;
      }
    }, {
      key: "_singleAnchorCompute",
      value: function _singleAnchorCompute(anchor, params) {
        var xy = params.xy,
            wh = params.wh,
            timestamp = params.timestamp,
            pos = this.anchorLocations.get(anchor.id);
        if (pos != null && timestamp && timestamp === anchor.timestamp) {
          return pos;
        }
        var _getCurrentLocation = getCurrentLocation(anchor),
            _getCurrentLocation2 = _slicedToArray$4(_getCurrentLocation, 2);
            _getCurrentLocation2[0];
            var currentLoc = _getCurrentLocation2[1];
        pos = this._computeSingleLocation(currentLoc, xy, wh, params);
        return this._setComputedPosition(anchor, pos, timestamp);
      }
    }, {
      key: "_defaultAnchorCompute",
      value: function _defaultAnchorCompute(anchor, params) {
        var pos;
        if (anchor.locations.length === 1) {
          return this._singleAnchorCompute(anchor, params);
        }
        var xy = params.xy,
            wh = params.wh,
            txy = params.txy,
            twh = params.twh;
        var _getCurrentLocation3 = getCurrentLocation(anchor),
            _getCurrentLocation4 = _slicedToArray$4(_getCurrentLocation3, 2),
            currentIdx = _getCurrentLocation4[0],
            currentLoc = _getCurrentLocation4[1];
        if (anchor.locked || txy == null || twh == null) {
          pos = this._computeSingleLocation(currentLoc, xy, wh, params);
        } else {
          var _this$_anchorSelector = this._anchorSelector(xy, wh, txy, twh, params.rotation, params.tRotation, anchor.locations),
              _this$_anchorSelector2 = _slicedToArray$4(_this$_anchorSelector, 2),
              newIdx = _this$_anchorSelector2[0],
              newLoc = _this$_anchorSelector2[1];
          anchor.currentLocation = newIdx;
          if (newIdx !== currentIdx) {
            anchor.cssClass = newLoc.cls || anchor.cssClass;
            params.element._anchorLocationChanged(anchor);
          }
          pos = this._computeSingleLocation(newLoc, xy, wh, params);
        }
        return this._setComputedPosition(anchor, pos, params.timestamp);
      }
    }, {
      key: "_placeAnchors",
      value: function _placeAnchors(elementId, _anchorLists) {
        var _this2 = this;
        var cd = this.instance.viewport.getPosition(elementId),
            placeSomeAnchors = function placeSomeAnchors(desc, element, unsortedConnections, isHorizontal, otherMultiplier, orientation) {
          if (unsortedConnections.length > 0) {
            var sc = unsortedConnections.sort(edgeSortFunctions[desc]),
            reverse = desc === RIGHT$1 || desc === TOP$2,
                anchors = _placeAnchorsOnLine(cd, sc, isHorizontal, otherMultiplier, reverse);
            for (var i = 0; i < anchors.length; i++) {
              var c = anchors[i].c,
                  weAreSource = c.endpoints[0].elementId === elementId,
                  ep = weAreSource ? c.endpoints[0] : c.endpoints[1];
              _this2._setComputedPosition(ep._anchor, {
                curX: anchors[i].x,
                curY: anchors[i].y,
                x: anchors[i].xLoc,
                y: anchors[i].yLoc,
                ox: orientation[0],
                oy: orientation[1]
              });
            }
          }
        };
        placeSomeAnchors(BOTTOM$1, cd, _anchorLists.bottom, true, 1, [0, 1]);
        placeSomeAnchors(TOP$2, cd, _anchorLists.top, true, 0, [0, -1]);
        placeSomeAnchors(LEFT$2, cd, _anchorLists.left, false, 0, [-1, 0]);
        placeSomeAnchors(RIGHT$1, cd, _anchorLists.right, false, 1, [1, 0]);
      }
    }, {
      key: "_updateAnchorList",
      value: function _updateAnchorList(lists, theta, order, conn, aBoolean, otherElId, idx, reverse, edgeId, connsToPaint, endpointsToPaint) {
        var endpoint = conn.endpoints[idx],
            endpointId = endpoint.id,
            oIdx = [1, 0][idx],
            values = {
          theta: theta,
          order: order,
          c: conn,
          b: aBoolean,
          elId: otherElId,
          epId: endpointId
        },
            listToAddTo = lists[edgeId],
            listToRemoveFrom = endpoint._continuousAnchorEdge ? lists[endpoint._continuousAnchorEdge] : null,
            candidate;
        if (listToRemoveFrom) {
          var rIdx = findWithFunction(listToRemoveFrom, function (e) {
            return e.epId === endpointId;
          });
          if (rIdx !== -1) {
            listToRemoveFrom.splice(rIdx, 1);
            for (var i = 0; i < listToRemoveFrom.length; i++) {
              candidate = listToRemoveFrom[i].c;
              if (candidate.placeholder !== true) {
                connsToPaint.add(candidate);
              }
              endpointsToPaint.add(listToRemoveFrom[i].c.endpoints[idx]);
              endpointsToPaint.add(listToRemoveFrom[i].c.endpoints[oIdx]);
            }
          }
        }
        for (var _i = 0; _i < listToAddTo.length; _i++) {
          candidate = listToAddTo[_i].c;
          if (candidate.placeholder !== true) {
            connsToPaint.add(candidate);
          }
          endpointsToPaint.add(listToAddTo[_i].c.endpoints[idx]);
          endpointsToPaint.add(listToAddTo[_i].c.endpoints[oIdx]);
        }
        {
          var insertIdx = reverse ? 0 : listToAddTo.length;
          listToAddTo.splice(insertIdx, 0, values);
        }
        endpoint._continuousAnchorEdge = edgeId;
      }
    }, {
      key: "_removeEndpointFromAnchorLists",
      value: function _removeEndpointFromAnchorLists(endpoint) {
        var listsForElement = this.anchorLists.get(endpoint.elementId);
        var total = 0;
        (function (list, eId) {
          if (list) {
            var f = function f(e) {
              return e.epId === eId;
            };
            removeWithFunction(list.top, f);
            removeWithFunction(list.left, f);
            removeWithFunction(list.bottom, f);
            removeWithFunction(list.right, f);
            total += list.top.length;
            total += list.left.length;
            total += list.bottom.length;
            total += list.right.length;
          }
        })(listsForElement, endpoint.id);
        if (total === 0) {
          this.anchorLists["delete"](endpoint.elementId);
        }
        this.anchorLocations["delete"](endpoint._anchor.id);
      }
    }, {
      key: "computeAnchorLocation",
      value: function computeAnchorLocation(anchor, params) {
        var pos;
        if (isContinuous(anchor)) {
          pos = this.anchorLocations.get(anchor.id) || {
            curX: 0,
            curY: 0,
            x: 0,
            y: 0,
            ox: 0,
            oy: 0
          };
        } else if (_isFloating(anchor)) {
          pos = this._floatingAnchorCompute(anchor, params);
        } else {
          pos = this._defaultAnchorCompute(anchor, params);
        }
        anchor.timestamp = params.timestamp;
        return pos;
      }
    }, {
      key: "computePath",
      value: function computePath(connection, timestamp) {
        var sourceInfo = this.instance.viewport.getPosition(connection.sourceId),
            targetInfo = this.instance.viewport.getPosition(connection.targetId),
            sE = connection.endpoints[0],
            tE = connection.endpoints[1];
        var sAnchorP = this.getEndpointLocation(sE, {
          xy: sourceInfo,
          wh: sourceInfo,
          element: sE,
          timestamp: timestamp,
          rotation: this.instance._getRotations(connection.sourceId)
        }),
            tAnchorP = this.getEndpointLocation(tE, {
          xy: targetInfo,
          wh: targetInfo,
          element: tE,
          timestamp: timestamp,
          rotation: this.instance._getRotations(connection.targetId)
        });
        connection.connector.resetBounds();
        connection.connector.compute({
          sourcePos: sAnchorP,
          targetPos: tAnchorP,
          sourceEndpoint: connection.endpoints[0],
          targetEndpoint: connection.endpoints[1],
          strokeWidth: connection.paintStyleInUse.strokeWidth,
          sourceInfo: sourceInfo,
          targetInfo: targetInfo
        });
      }
    }, {
      key: "getEndpointLocation",
      value: function getEndpointLocation(endpoint, params) {
        params = params || {};
        var anchor = endpoint._anchor;
        var pos = this.anchorLocations.get(anchor.id);
        if (pos == null || params.timestamp != null && anchor.timestamp !== params.timestamp) {
          pos = this.computeAnchorLocation(anchor, params);
          this._setComputedPosition(anchor, pos, params.timestamp);
        }
        return pos;
      }
    }, {
      key: "getEndpointOrientation",
      value: function getEndpointOrientation(ep) {
        return ep._anchor ? this.getAnchorOrientation(ep._anchor) : [0, 0];
      }
    }, {
      key: "setAnchorOrientation",
      value: function setAnchorOrientation(anchor, orientation) {
        var anchorLoc = this.anchorLocations.get(anchor.id);
        if (anchorLoc != null) {
          anchorLoc.ox = orientation[0];
          anchorLoc.oy = orientation[1];
        }
      }
    }, {
      key: "isDynamicAnchor",
      value: function isDynamicAnchor(ep) {
        return ep._anchor ? !isContinuous(ep._anchor) && ep._anchor.locations.length > 1 : false;
      }
    }, {
      key: "isFloating",
      value: function isFloating(ep) {
        return ep._anchor ? _isFloating(ep._anchor) : false;
      }
    }, {
      key: "prepareAnchor",
      value: function prepareAnchor(params) {
        return makeLightweightAnchorFromSpec(params);
      }
    }, {
      key: "redraw",
      value: function redraw(elementId, timestamp, offsetToUI) {
        var _this3 = this;
        var connectionsToPaint = new Set(),
            endpointsToPaint = new Set(),
            anchorsToUpdate = new Set();
        if (!this.instance._suspendDrawing) {
          var ep = this.instance.endpointsByElement[elementId] || [];
          timestamp = timestamp || uuid();
          var orientationCache = {},
              a,
              anEndpoint;
          for (var i = 0; i < ep.length; i++) {
            anEndpoint = ep[i];
            endpointsToPaint.add(anEndpoint);
            a = anEndpoint._anchor;
            if (anEndpoint.connections.length === 0) {
              if (isContinuous(a)) {
                if (!this.anchorLists.has(elementId)) {
                  this.anchorLists.set(elementId, {
                    top: [],
                    right: [],
                    bottom: [],
                    left: []
                  });
                }
                this._updateAnchorList(this.anchorLists.get(elementId), -Math.PI / 2, 0, {
                  endpoints: [anEndpoint, anEndpoint],
                  placeholder: true
                }, false, elementId, 0, false, getDefaultFace(a), connectionsToPaint, endpointsToPaint);
                anchorsToUpdate.add(elementId);
              }
            } else {
              for (var _i2 = 0; _i2 < anEndpoint.connections.length; _i2++) {
                var conn = anEndpoint.connections[_i2],
                    sourceId = conn.sourceId,
                    targetId = conn.targetId,
                    sourceContinuous = isContinuous(conn.endpoints[0]._anchor),
                    targetContinuous = isContinuous(conn.endpoints[1]._anchor);
                if (sourceContinuous || targetContinuous) {
                  var c1 = (conn.endpoints[0]._anchor.faces || []).join("-"),
                      c2 = (conn.endpoints[1]._anchor.faces || []).join("-"),
                      oKey = [sourceId, c1, targetId, c2].join("-"),
                      o = orientationCache[oKey],
                      oIdx = conn.sourceId === elementId ? 1 : 0;
                  if (sourceContinuous && !this.anchorLists.has(sourceId)) {
                    this.anchorLists.set(sourceId, {
                      top: [],
                      right: [],
                      bottom: [],
                      left: []
                    });
                  }
                  if (targetContinuous && !this.anchorLists.has(targetId)) {
                    this.anchorLists.set(targetId, {
                      top: [],
                      right: [],
                      bottom: [],
                      left: []
                    });
                  }
                  var td = this.instance.viewport.getPosition(targetId),
                      sd = this.instance.viewport.getPosition(sourceId);
                  if (targetId === sourceId && (sourceContinuous || targetContinuous)) {
                    this._updateAnchorList(this.anchorLists.get(sourceId), -Math.PI / 2, 0, conn, false, targetId, 0, false, TOP$2, connectionsToPaint, endpointsToPaint);
                    this._updateAnchorList(this.anchorLists.get(targetId), -Math.PI / 2, 0, conn, false, sourceId, 1, false, TOP$2, connectionsToPaint, endpointsToPaint);
                  } else {
                    var sourceRotation = this.instance._getRotations(sourceId);
                    var targetRotation = this.instance._getRotations(targetId);
                    if (!o) {
                      o = this._calculateOrientation(sourceId, targetId, sd, td, conn.endpoints[0]._anchor, conn.endpoints[1]._anchor, sourceRotation, targetRotation);
                      orientationCache[oKey] = o;
                    }
                    if (sourceContinuous) {
                      this._updateAnchorList(this.anchorLists.get(sourceId), o.theta, 0, conn, false, targetId, 0, false, o.a[0], connectionsToPaint, endpointsToPaint);
                    }
                    if (targetContinuous) {
                      this._updateAnchorList(this.anchorLists.get(targetId), o.theta2, -1, conn, true, sourceId, 1, true, o.a[1], connectionsToPaint, endpointsToPaint);
                    }
                  }
                  if (sourceContinuous) {
                    anchorsToUpdate.add(sourceId);
                  }
                  if (targetContinuous) {
                    anchorsToUpdate.add(targetId);
                  }
                  connectionsToPaint.add(conn);
                  if (sourceContinuous && oIdx === 0 || targetContinuous && oIdx === 1) {
                    endpointsToPaint.add(conn.endpoints[oIdx]);
                  }
                } else {
                  var otherEndpoint = anEndpoint.connections[_i2].endpoints[conn.sourceId === elementId ? 1 : 0],
                      otherAnchor = otherEndpoint._anchor;
                  if (isDynamic(otherAnchor)) {
                    this.instance._paintEndpoint(otherEndpoint, {
                      elementWithPrecedence: elementId,
                      timestamp: timestamp
                    });
                    connectionsToPaint.add(anEndpoint.connections[_i2]);
                    for (var k = 0; k < otherEndpoint.connections.length; k++) {
                      if (otherEndpoint.connections[k] !== anEndpoint.connections[_i2]) {
                        connectionsToPaint.add(otherEndpoint.connections[k]);
                      }
                    }
                  } else {
                    connectionsToPaint.add(anEndpoint.connections[_i2]);
                  }
                }
              }
            }
          }
          anchorsToUpdate.forEach(function (anchor) {
            _this3._placeAnchors(anchor, _this3.anchorLists.get(anchor));
          });
          endpointsToPaint.forEach(function (ep) {
            var cd = _this3.instance.viewport.getPosition(ep.elementId);
            _this3.instance._paintEndpoint(ep, {
              timestamp: timestamp,
              offset: cd
            });
          });
          connectionsToPaint.forEach(function (c) {
            _this3.instance._paintConnection(c, {
              timestamp: timestamp
            });
          });
        }
        return {
          c: connectionsToPaint,
          e: endpointsToPaint
        };
      }
    }, {
      key: "reset",
      value: function reset() {
        this.anchorLocations.clear();
        this.anchorLists.clear();
      }
    }, {
      key: "setAnchor",
      value: function setAnchor(endpoint, anchor) {
        if (anchor != null) {
          endpoint._anchor = anchor;
        }
      }
    }, {
      key: "setConnectionAnchors",
      value: function setConnectionAnchors(conn, anchors) {
        conn.endpoints[0]._anchor = anchors[0];
        conn.endpoints[1]._anchor = anchors[1];
      }
    }, {
      key: "_calculateOrientation",
      value: function _calculateOrientation(sourceId, targetId, sd, td, sourceAnchor, targetAnchor, sourceRotation, targetRotation) {
        var _this4 = this;
        var Orientation = {
          HORIZONTAL: "horizontal",
          VERTICAL: "vertical",
          DIAGONAL: "diagonal",
          IDENTITY: "identity"
        };
        if (sourceId === targetId) {
          return {
            orientation: Orientation.IDENTITY,
            a: [TOP$2, TOP$2]
          };
        }
        var theta = Math.atan2(td.c.y - sd.c.y, td.c.x - sd.c.x),
            theta2 = Math.atan2(sd.c.y - td.c.y, sd.c.x - td.c.x);
        var candidates = [],
            midpoints = {};
        (function (types, dim) {
          for (var i = 0; i < types.length; i++) {
            var _midpoints$types$i;
            midpoints[types[i]] = (_midpoints$types$i = {}, _defineProperty$e(_midpoints$types$i, LEFT$2, {
              x: dim[i][0].x,
              y: dim[i][0].c.y
            }), _defineProperty$e(_midpoints$types$i, RIGHT$1, {
              x: dim[i][0].x + dim[i][0].w,
              y: dim[i][0].c.y
            }), _defineProperty$e(_midpoints$types$i, TOP$2, {
              x: dim[i][0].c.x,
              y: dim[i][0].y
            }), _defineProperty$e(_midpoints$types$i, BOTTOM$1, {
              x: dim[i][0].c.x,
              y: dim[i][0].y + dim[i][0].h
            }), _midpoints$types$i);
            if (dim[i][1] != null && dim[i][1].length > 0) {
              for (var axis in midpoints[types[i]]) {
                midpoints[types[i]][axis] = _this4.instance._applyRotationsXY(midpoints[types[i]][axis], dim[i][1]);
              }
            }
          }
        })([SOURCE$1, TARGET$1], [[sd, sourceRotation], [td, targetRotation]]);
        var FACES = [TOP$2, LEFT$2, RIGHT$1, BOTTOM$1];
        for (var sf = 0; sf < FACES.length; sf++) {
          for (var tf = 0; tf < FACES.length; tf++) {
            candidates.push({
              source: FACES[sf],
              target: FACES[tf],
              dist: lineLength(midpoints.source[FACES[sf]], midpoints.target[FACES[tf]])
            });
          }
        }
        candidates.sort(function (a, b) {
          if (a.dist < b.dist) {
            return -1;
          } else if (b.dist < a.dist) {
            return 1;
          } else {
            var _axisIndices;
            var axisIndices = (_axisIndices = {}, _defineProperty$e(_axisIndices, LEFT$2, 0), _defineProperty$e(_axisIndices, TOP$2, 1), _defineProperty$e(_axisIndices, RIGHT$1, 2), _defineProperty$e(_axisIndices, BOTTOM$1, 3), _axisIndices),
                ais = axisIndices[a.source],
                bis = axisIndices[b.source],
                ait = axisIndices[a.target],
                bit = axisIndices[b.target];
            return ais < bis ? -1 : bis < ais ? 1 : ait < bit ? -1 : bit < ait ? 1 : 0;
          }
        });
        var sourceEdge = candidates[0].source,
            targetEdge = candidates[0].target;
        for (var i = 0; i < candidates.length; i++) {
          if (isContinuous(sourceAnchor) && sourceAnchor.locked) {
            sourceEdge = sourceAnchor.currentFace;
          } else if (!sourceAnchor.isContinuous || isEdgeSupported(sourceAnchor, candidates[i].source)) {
            sourceEdge = candidates[i].source;
          } else {
            sourceEdge = null;
          }
          if (targetAnchor.isContinuous && targetAnchor.locked) {
            targetEdge = targetAnchor.currentFace;
          } else if (!targetAnchor.isContinuous || isEdgeSupported(targetAnchor, candidates[i].target)) {
            targetEdge = candidates[i].target;
          } else {
            targetEdge = null;
          }
          if (sourceEdge != null && targetEdge != null) {
            break;
          }
        }
        if (sourceAnchor.isContinuous) {
          this.setCurrentFace(sourceAnchor, sourceEdge);
        }
        if (targetAnchor.isContinuous) {
          this.setCurrentFace(targetAnchor, targetEdge);
        }
        return {
          a: [sourceEdge, targetEdge],
          theta: theta,
          theta2: theta2
        };
      }
    }, {
      key: "setCurrentFace",
      value: function setCurrentFace(a, face, overrideLock) {
        a.currentFace = face;
        if (overrideLock && a.lockedFace != null) {
          a.lockedFace = a.currentFace;
        }
      }
    }, {
      key: "lock",
      value: function lock(a) {
        a.locked = true;
        if (isContinuous(a)) {
          a.lockedFace = a.currentFace;
        }
      }
    }, {
      key: "unlock",
      value: function unlock(a) {
        a.locked = false;
        if (isContinuous(a)) {
          a.lockedFace = null;
        }
      }
    }, {
      key: "selectAnchorLocation",
      value: function selectAnchorLocation(a, coords) {
        var idx = findWithFunction(a.locations, function (loc) {
          return loc.x === coords.x && loc.y === coords.y;
        });
        if (idx !== -1) {
          a.currentLocation = idx;
          return true;
        } else {
          return false;
        }
      }
    }, {
      key: "lockCurrentAxis",
      value: function lockCurrentAxis(a) {
        if (a.currentFace != null) {
          a.lockedAxis = a.currentFace === LEFT$2 || a.currentFace === RIGHT$1 ? X_AXIS_FACES : Y_AXIS_FACES;
        }
      }
    }, {
      key: "unlockCurrentAxis",
      value: function unlockCurrentAxis(a) {
        a.lockedAxis = null;
      }
    }, {
      key: "anchorsEqual",
      value: function anchorsEqual(a1, a2) {
        if (!a1 || !a2) {
          return false;
        }
        var l1 = a1.locations[a1.currentLocation],
            l2 = a2.locations[a2.currentLocation];
        return l1.x === l2.x && l1.y === l2.y && l1.offx === l2.offx && l1.offy === l2.offy && l1.ox === l2.ox && l1.oy === l2.oy;
      }
    }]);
    return LightweightRouter;
  }();

  function _scopeMatch(e1, e2) {
    var s1 = e1.scope.split(/\s/),
        s2 = e2.scope.split(/\s/);
    for (var i = 0; i < s1.length; i++) {
      for (var j = 0; j < s2.length; j++) {
        if (s2[j] === s1[i]) {
          return true;
        }
      }
    }
    return false;
  }
  function prepareList(instance, input, doNotGetIds) {
    var r = [];
    var _resolveId = function _resolveId(i) {
      if (isString(i)) {
        return i;
      } else {
        return instance.getId(i);
      }
    };
    if (input) {
      if (typeof input === 'string') {
        if (input === "*") {
          return input;
        }
        r.push(input);
      } else {
        if (doNotGetIds) {
          r = input;
        } else {
          if (input.length != null) {
            var _r;
            (_r = r).push.apply(_r, _toConsumableArray$2(_toConsumableArray$2(input).map(_resolveId)));
          } else {
            r.push(_resolveId(input));
          }
        }
      }
    }
    return r;
  }
  function addManagedEndpoint(managedElement, ep) {
    if (managedElement != null) {
      managedElement.endpoints.push(ep);
    }
  }
  function removeManagedEndpoint(managedElement, endpoint) {
    if (managedElement != null) {
      removeWithFunction(managedElement.endpoints, function (ep) {
        return ep === endpoint;
      });
    }
  }
  function addManagedConnection(connection, sourceEl, targetEl) {
    if (sourceEl != null) {
      sourceEl.connections.push(connection);
      if (sourceEl.connections.length === 1) {
        connection.instance.addClass(connection.source, connection.instance.connectedClass);
      }
    }
    if (targetEl != null) {
      if (sourceEl == null || connection.sourceId !== connection.targetId) {
        targetEl.connections.push(connection);
        if (targetEl.connections.length === 1) {
          connection.instance.addClass(connection.target, connection.instance.connectedClass);
        }
      }
    }
  }
  function removeManagedConnection(connection, sourceEl, targetEl) {
    if (sourceEl != null) {
      var sourceCount = sourceEl.connections.length;
      removeWithFunction(sourceEl.connections, function (_c) {
        return connection.id === _c.id;
      });
      if (sourceCount > 0 && sourceEl.connections.length === 0) {
        connection.instance.removeClass(connection.source, connection.instance.connectedClass);
      }
    }
    if (targetEl != null) {
      var targetCount = targetEl.connections.length;
      if (sourceEl == null || connection.sourceId !== connection.targetId) {
        removeWithFunction(targetEl.connections, function (_c) {
          return connection.id === _c.id;
        });
      }
      if (targetCount > 0 && targetEl.connections.length === 0) {
        connection.instance.removeClass(connection.target, connection.instance.connectedClass);
      }
    }
  }
  var JsPlumbInstance = function (_EventGenerator) {
    _inherits$a(JsPlumbInstance, _EventGenerator);
    var _super = _createSuper$a(JsPlumbInstance);
    function JsPlumbInstance(_instanceIndex, defaults) {
      var _this;
      _classCallCheck$f(this, JsPlumbInstance);
      _this = _super.call(this);
      _this._instanceIndex = _instanceIndex;
      _defineProperty$e(_assertThisInitialized$a(_this), "defaults", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "_initialDefaults", {});
      _defineProperty$e(_assertThisInitialized$a(_this), "isConnectionBeingDragged", false);
      _defineProperty$e(_assertThisInitialized$a(_this), "currentlyDragging", false);
      _defineProperty$e(_assertThisInitialized$a(_this), "hoverSuspended", false);
      _defineProperty$e(_assertThisInitialized$a(_this), "_suspendDrawing", false);
      _defineProperty$e(_assertThisInitialized$a(_this), "_suspendedAt", null);
      _defineProperty$e(_assertThisInitialized$a(_this), "connectorClass", CLASS_CONNECTOR);
      _defineProperty$e(_assertThisInitialized$a(_this), "connectorOutlineClass", CLASS_CONNECTOR_OUTLINE);
      _defineProperty$e(_assertThisInitialized$a(_this), "connectedClass", CLASS_CONNECTED);
      _defineProperty$e(_assertThisInitialized$a(_this), "endpointClass", CLASS_ENDPOINT);
      _defineProperty$e(_assertThisInitialized$a(_this), "endpointConnectedClass", CLASS_ENDPOINT_CONNECTED);
      _defineProperty$e(_assertThisInitialized$a(_this), "endpointFullClass", CLASS_ENDPOINT_FULL);
      _defineProperty$e(_assertThisInitialized$a(_this), "endpointDropAllowedClass", CLASS_ENDPOINT_DROP_ALLOWED);
      _defineProperty$e(_assertThisInitialized$a(_this), "endpointDropForbiddenClass", CLASS_ENDPOINT_DROP_FORBIDDEN);
      _defineProperty$e(_assertThisInitialized$a(_this), "endpointAnchorClassPrefix", CLASS_ENDPOINT_ANCHOR_PREFIX);
      _defineProperty$e(_assertThisInitialized$a(_this), "overlayClass", CLASS_OVERLAY);
      _defineProperty$e(_assertThisInitialized$a(_this), "connections", []);
      _defineProperty$e(_assertThisInitialized$a(_this), "endpointsByElement", {});
      _defineProperty$e(_assertThisInitialized$a(_this), "endpointsByUUID", new Map());
      _defineProperty$e(_assertThisInitialized$a(_this), "sourceSelectors", []);
      _defineProperty$e(_assertThisInitialized$a(_this), "targetSelectors", []);
      _defineProperty$e(_assertThisInitialized$a(_this), "allowNestedGroups", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "_curIdStamp", 1);
      _defineProperty$e(_assertThisInitialized$a(_this), "viewport", new Viewport(_assertThisInitialized$a(_this)));
      _defineProperty$e(_assertThisInitialized$a(_this), "router", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "groupManager", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "_connectionTypes", new Map());
      _defineProperty$e(_assertThisInitialized$a(_this), "_endpointTypes", new Map());
      _defineProperty$e(_assertThisInitialized$a(_this), "_container", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "_managedElements", {});
      _defineProperty$e(_assertThisInitialized$a(_this), "DEFAULT_SCOPE", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "_zoom", 1);
      _this.defaults = {
        anchor: AnchorLocations.Bottom,
        anchors: [null, null],
        connectionsDetachable: true,
        connectionOverlays: [],
        connector: StraightConnector.type,
        container: null,
        endpoint: DotEndpoint.type,
        endpointOverlays: [],
        endpoints: [null, null],
        endpointStyle: {
          fill: "#456"
        },
        endpointStyles: [null, null],
        endpointHoverStyle: null,
        endpointHoverStyles: [null, null],
        hoverPaintStyle: null,
        listStyle: {},
        maxConnections: 1,
        paintStyle: {
          strokeWidth: 2,
          stroke: "#456"
        },
        reattachConnections: false,
        scope: "jsplumb_defaultscope",
        allowNestedGroups: true
      };
      if (defaults) {
        extend(_this.defaults, defaults);
      }
      extend(_this._initialDefaults, _this.defaults);
      _this.DEFAULT_SCOPE = _this.defaults.scope;
      _this.allowNestedGroups = _this._initialDefaults.allowNestedGroups !== false;
      _this.router = new LightweightRouter(_assertThisInitialized$a(_this));
      _this.groupManager = new GroupManager(_assertThisInitialized$a(_this));
      _this.setContainer(_this._initialDefaults.container);
      return _this;
    }
    _createClass$f(JsPlumbInstance, [{
      key: "defaultScope",
      get: function get() {
        return this.DEFAULT_SCOPE;
      }
    }, {
      key: "currentZoom",
      get: function get() {
        return this._zoom;
      }
    }, {
      key: "areDefaultAnchorsSet",
      value: function areDefaultAnchorsSet() {
        return this.validAnchorsSpec(this.defaults.anchors);
      }
    }, {
      key: "validAnchorsSpec",
      value: function validAnchorsSpec(anchors) {
        return anchors != null && anchors[0] != null && anchors[1] != null;
      }
    }, {
      key: "getContainer",
      value: function getContainer() {
        return this._container;
      }
    }, {
      key: "setZoom",
      value: function setZoom(z, repaintEverything) {
        this._zoom = z;
        this.fire(EVENT_ZOOM, this._zoom);
        if (repaintEverything) {
          this.repaintEverything();
        }
        return true;
      }
    }, {
      key: "_idstamp",
      value: function _idstamp() {
        return "" + this._curIdStamp++;
      }
    }, {
      key: "checkCondition",
      value: function checkCondition(conditionName, args) {
        var l = this.getListener(conditionName),
            r = true;
        if (l && l.length > 0) {
          var values = Array.prototype.slice.call(arguments, 1);
          try {
            for (var i = 0, j = l.length; i < j; i++) {
              r = r && l[i].apply(l[i], values);
            }
          } catch (e) {
            log("cannot check condition [" + conditionName + "]" + e);
          }
        }
        return r;
      }
    }, {
      key: "getId",
      value: function getId(element, uuid) {
        if (element == null) {
          return null;
        }
        var id = this.getAttribute(element, ATTRIBUTE_MANAGED);
        if (!id || id === "undefined") {
          if (arguments.length === 2 && arguments[1] !== undefined) {
            id = uuid;
          } else if (arguments.length === 1 || arguments.length === 3 && !arguments[2]) {
            id = "jsplumb-" + this._instanceIndex + "-" + this._idstamp();
          }
          this.setAttribute(element, ATTRIBUTE_MANAGED, id);
        }
        return id;
      }
    }, {
      key: "getConnections",
      value: function getConnections(options, flat) {
        if (!options) {
          options = {};
        } else if (options.constructor === String) {
          options = {
            "scope": options
          };
        }
        var scope = options.scope || this.defaultScope,
            scopes = prepareList(this, scope, true),
            sources = prepareList(this, options.source),
            targets = prepareList(this, options.target),
            results = !flat && scopes.length > 1 ? {} : [],
            _addOne = function _addOne(scope, obj) {
          if (!flat && scopes.length > 1) {
            var ss = results[scope];
            if (ss == null) {
              ss = results[scope] = [];
            }
            ss.push(obj);
          } else {
            results.push(obj);
          }
        };
        for (var j = 0, jj = this.connections.length; j < jj; j++) {
          var _c2 = this.connections[j],
              sourceId = _c2.proxies && _c2.proxies[0] ? _c2.proxies[0].originalEp.elementId : _c2.sourceId,
              targetId = _c2.proxies && _c2.proxies[1] ? _c2.proxies[1].originalEp.elementId : _c2.targetId;
          if (filterList(scopes, _c2.scope) && filterList(sources, sourceId) && filterList(targets, targetId)) {
            _addOne(_c2.scope, _c2);
          }
        }
        return results;
      }
    }, {
      key: "select",
      value: function select(params) {
        params = params || {};
        params.scope = params.scope || "*";
        return new ConnectionSelection(this, params.connections || this.getConnections(params, true));
      }
    }, {
      key: "selectEndpoints",
      value: function selectEndpoints(params) {
        params = params || {};
        params.scope = params.scope || WILDCARD;
        var noElementFilters = !params.element && !params.source && !params.target,
            elements = noElementFilters ? WILDCARD : prepareList(this, params.element),
            sources = noElementFilters ? WILDCARD : prepareList(this, params.source),
            targets = noElementFilters ? WILDCARD : prepareList(this, params.target),
            scopes = prepareList(this, params.scope, true);
        var ep = [];
        for (var _el2 in this.endpointsByElement) {
          var either = filterList(elements, _el2, true),
              source = filterList(sources, _el2, true),
              sourceMatchExact = sources !== "*",
              target = filterList(targets, _el2, true),
              targetMatchExact = targets !== "*";
          if (either || source || target) {
            inner: for (var i = 0, ii = this.endpointsByElement[_el2].length; i < ii; i++) {
              var _ep = this.endpointsByElement[_el2][i];
              if (filterList(scopes, _ep.scope, true)) {
                var noMatchSource = sourceMatchExact && sources.length > 0 && !_ep.isSource,
                    noMatchTarget = targetMatchExact && targets.length > 0 && !_ep.isTarget;
                if (noMatchSource || noMatchTarget) {
                  continue inner;
                }
                ep.push(_ep);
              }
            }
          }
        }
        return new EndpointSelection(this, ep);
      }
    }, {
      key: "setContainer",
      value: function setContainer(c) {
        this._container = c;
        this.fire(EVENT_CONTAINER_CHANGE, this._container);
      }
    }, {
      key: "_set",
      value: function _set(c, el, idx) {
        var stTypes = [{
          el: "source",
          elId: "sourceId"
        }, {
          el: "target",
          elId: "targetId"
        }];
        var ep,
            _st = stTypes[idx],
            cId = c[_st.elId],
            sid,
            oldEndpoint = c.endpoints[idx];
        var evtParams = {
          index: idx,
          originalEndpoint: oldEndpoint,
          originalSourceId: idx === 0 ? cId : c.sourceId,
          newSourceId: c.sourceId,
          originalTargetId: idx === 1 ? cId : c.targetId,
          newTargetId: c.targetId,
          connection: c,
          newEndpoint: oldEndpoint
        };
        if (el instanceof Endpoint) {
          ep = el;
          ep.addConnection(c);
        } else {
          sid = this.getId(el);
          if (sid === c[_st.elId]) {
            ep = null;
          } else {
            ep = c.makeEndpoint(idx === 0, el, sid);
          }
        }
        if (ep != null) {
          evtParams.newEndpoint = ep;
          oldEndpoint.detachFromConnection(c);
          c.endpoints[idx] = ep;
          c[_st.el] = ep.element;
          c[_st.elId] = ep.elementId;
          evtParams[idx === 0 ? "newSourceId" : "newTargetId"] = ep.elementId;
          this.fireMoveEvent(evtParams);
          this._paintConnection(c);
        }
        return evtParams;
      }
    }, {
      key: "setSource",
      value: function setSource(connection, el) {
        removeManagedConnection(connection, this._managedElements[connection.sourceId]);
        var p = this._set(connection, el, 0);
        addManagedConnection(connection, this._managedElements[p.newSourceId]);
      }
    }, {
      key: "setTarget",
      value: function setTarget(connection, el) {
        removeManagedConnection(connection, this._managedElements[connection.targetId]);
        var p = this._set(connection, el, 1);
        addManagedConnection(connection, this._managedElements[p.newTargetId]);
      }
    }, {
      key: "isHoverSuspended",
      value: function isHoverSuspended() {
        return this.hoverSuspended;
      }
    }, {
      key: "setSuspendDrawing",
      value: function setSuspendDrawing(val, repaintAfterwards) {
        var curVal = this._suspendDrawing;
        this._suspendDrawing = val;
        if (val) {
          this._suspendedAt = "" + new Date().getTime();
        } else {
          this._suspendedAt = null;
          this.viewport.recomputeBounds();
        }
        if (repaintAfterwards) {
          this.repaintEverything();
        }
        return curVal;
      }
    }, {
      key: "getSuspendedAt",
      value: function getSuspendedAt() {
        return this._suspendedAt;
      }
    }, {
      key: "batch",
      value: function batch(fn, doNotRepaintAfterwards) {
        var _wasSuspended = this._suspendDrawing === true;
        if (!_wasSuspended) {
          this.setSuspendDrawing(true);
        }
        fn();
        if (!_wasSuspended) {
          this.setSuspendDrawing(false, !doNotRepaintAfterwards);
        }
      }
    }, {
      key: "each",
      value: function each(spec, fn) {
        if (spec == null) {
          return;
        }
        if (spec.length != null) {
          for (var i = 0; i < spec.length; i++) {
            fn(spec[i]);
          }
        } else {
          fn(spec);
        }
        return this;
      }
    }, {
      key: "updateOffset",
      value: function updateOffset(params) {
        var elId = params.elId;
        if (params.recalc) {
          return this.viewport.refreshElement(elId);
        } else {
          return this.viewport.getPosition(elId);
        }
      }
    }, {
      key: "deleteConnection",
      value: function deleteConnection(connection, params) {
        if (connection != null && connection.deleted !== true) {
          params = params || {};
          if (params.force || functionChain(true, false, [[connection.endpoints[0], IS_DETACH_ALLOWED, [connection]], [connection.endpoints[1], IS_DETACH_ALLOWED, [connection]], [connection, IS_DETACH_ALLOWED, [connection]], [this, CHECK_CONDITION, [INTERCEPT_BEFORE_DETACH, connection]]])) {
            removeManagedConnection(connection, this._managedElements[connection.sourceId], this._managedElements[connection.targetId]);
            this.fireDetachEvent(connection, !connection.pending && params.fireEvent !== false, params.originalEvent);
            var _sourceEndpoint = connection.endpoints[0];
            var targetEndpoint = connection.endpoints[1];
            if (_sourceEndpoint !== params.endpointToIgnore) {
              _sourceEndpoint.detachFromConnection(connection, null, true);
            }
            if (targetEndpoint !== params.endpointToIgnore) {
              targetEndpoint.detachFromConnection(connection, null, true);
            }
            removeWithFunction(this.connections, function (_c) {
              return connection.id === _c.id;
            });
            connection.destroy();
            if (_sourceEndpoint !== params.endpointToIgnore && _sourceEndpoint.deleteOnEmpty && _sourceEndpoint.connections.length === 0) {
              this.deleteEndpoint(_sourceEndpoint);
            }
            if (targetEndpoint !== params.endpointToIgnore && targetEndpoint.deleteOnEmpty && targetEndpoint.connections.length === 0) {
              this.deleteEndpoint(targetEndpoint);
            }
            return true;
          }
        }
        return false;
      }
    }, {
      key: "deleteEveryConnection",
      value: function deleteEveryConnection(params) {
        var _this2 = this;
        params = params || {};
        var count = this.connections.length,
            deletedCount = 0;
        this.batch(function () {
          for (var i = 0; i < count; i++) {
            deletedCount += _this2.deleteConnection(_this2.connections[0], params) ? 1 : 0;
          }
        });
        return deletedCount;
      }
    }, {
      key: "deleteConnectionsForElement",
      value: function deleteConnectionsForElement(el, params) {
        var id = this.getId(el),
            m = this._managedElements[id];
        if (m) {
          var l = m.connections.length;
          for (var i = 0; i < l; i++) {
            this.deleteConnection(m.connections[0], params);
          }
        }
        return this;
      }
    }, {
      key: "fireDetachEvent",
      value: function fireDetachEvent(jpc, doFireEvent, originalEvent) {
        var argIsConnection = jpc.id != null,
            params = argIsConnection ? {
          connection: jpc,
          source: jpc.source,
          target: jpc.target,
          sourceId: jpc.sourceId,
          targetId: jpc.targetId,
          sourceEndpoint: jpc.endpoints[0],
          targetEndpoint: jpc.endpoints[1]
        } : jpc;
        if (doFireEvent) {
          this.fire(EVENT_CONNECTION_DETACHED, params, originalEvent);
        }
        this.fire(EVENT_INTERNAL_CONNECTION_DETACHED, params, originalEvent);
      }
    }, {
      key: "fireMoveEvent",
      value: function fireMoveEvent(params, evt) {
        this.fire(EVENT_CONNECTION_MOVED, params, evt);
      }
    }, {
      key: "manageAll",
      value: function manageAll(elements, recalc) {
        var nl = isString(elements) ? this.getSelector(this.getContainer(), elements) : elements;
        for (var i = 0; i < nl.length; i++) {
          this.manage(nl[i], null, recalc);
        }
      }
    }, {
      key: "manage",
      value: function manage(element, internalId, _recalc) {
        if (this.getAttribute(element, ATTRIBUTE_MANAGED) == null) {
          internalId = internalId || this.getAttribute(element, "id") || uuid();
          this.setAttribute(element, ATTRIBUTE_MANAGED, internalId);
        }
        var elId = this.getId(element);
        if (!this._managedElements[elId]) {
          var obj = {
            el: element,
            endpoints: [],
            connections: [],
            rotation: 0,
            data: {}
          };
          this._managedElements[elId] = obj;
          if (this._suspendDrawing) {
            obj.viewportElement = this.viewport.registerElement(elId, true);
          } else {
            obj.viewportElement = this.updateOffset({
              elId: elId,
              recalc: true
            });
          }
          this.fire(EVENT_MANAGE_ELEMENT, {
            el: element
          });
        } else {
          if (_recalc) {
            this._managedElements[elId].viewportElement = this.updateOffset({
              elId: elId,
              timestamp: null,
              recalc: true
            });
          }
        }
        return this._managedElements[elId];
      }
    }, {
      key: "getManagedData",
      value: function getManagedData(elementId, dataIdentifier, key) {
        if (this._managedElements[elementId]) {
          var data = this._managedElements[elementId].data[dataIdentifier];
          return data != null ? data[key] : null;
        }
      }
    }, {
      key: "setManagedData",
      value: function setManagedData(elementId, dataIdentifier, key, data) {
        if (this._managedElements[elementId]) {
          this._managedElements[elementId].data[dataIdentifier] = this._managedElements[elementId].data[dataIdentifier] || {};
          this._managedElements[elementId].data[dataIdentifier][key] = data;
        }
      }
    }, {
      key: "getManagedElement",
      value: function getManagedElement(id) {
        return this._managedElements[id] ? this._managedElements[id].el : null;
      }
    }, {
      key: "unmanage",
      value: function unmanage(el, removeElement) {
        var _this3 = this;
        this.removeAllEndpoints(el, true);
        var _one = function _one(_el) {
          var id = _this3.getId(_el);
          _this3.removeAttribute(_el, ATTRIBUTE_MANAGED);
          delete _this3._managedElements[id];
          _this3.viewport.remove(id);
          _this3.fire(EVENT_UNMANAGE_ELEMENT, {
            el: _el
          });
          if (_el && removeElement) {
            _this3._removeElement(_el);
          }
        };
        this._getAssociatedElements(el).map(_one);
        _one(el);
      }
    }, {
      key: "rotate",
      value: function rotate(element, rotation, _doNotRepaint) {
        var elementId = this.getId(element);
        if (this._managedElements[elementId]) {
          this._managedElements[elementId].rotation = rotation;
          this.viewport.rotateElement(elementId, rotation);
          if (_doNotRepaint !== true) {
            return this.revalidate(element);
          }
        }
        return {
          c: new Set(),
          e: new Set()
        };
      }
    }, {
      key: "_getRotation",
      value: function _getRotation(elementId) {
        var entry = this._managedElements[elementId];
        if (entry != null) {
          return entry.rotation || 0;
        } else {
          return 0;
        }
      }
    }, {
      key: "_getRotations",
      value: function _getRotations(elementId) {
        var _this4 = this;
        var rotations = [];
        var entry = this._managedElements[elementId];
        var _oneLevel = function _oneLevel(e) {
          if (e.group != null) {
            var gEntry = _this4._managedElements[e.group];
            if (gEntry != null) {
              rotations.push({
                r: gEntry.viewportElement.r,
                c: gEntry.viewportElement.c
              });
              _oneLevel(gEntry);
            }
          }
        };
        if (entry != null) {
          rotations.push({
            r: entry.viewportElement.r || 0,
            c: entry.viewportElement.c
          });
          _oneLevel(entry);
        }
        return rotations;
      }
    }, {
      key: "_applyRotations",
      value: function _applyRotations(point, rotations) {
        var sl = point.slice();
        var current = {
          x: sl[0],
          y: sl[1],
          cr: 0,
          sr: 0
        };
        forEach(rotations, function (rotation) {
          current = rotatePoint(current, rotation.c, rotation.r);
        });
        return current;
      }
    }, {
      key: "_applyRotationsXY",
      value: function _applyRotationsXY(point, rotations) {
        forEach(rotations, function (rotation) {
          point = rotatePoint(point, rotation.c, rotation.r);
        });
        return point;
      }
    }, {
      key: "_internal_newEndpoint",
      value: function _internal_newEndpoint(params) {
        var _p = extend({}, params);
        var managedElement = this.manage(_p.element);
        _p.elementId = this.getId(_p.element);
        _p.id = "ep_" + this._idstamp();
        var ep = new Endpoint(this, _p);
        addManagedEndpoint(managedElement, ep);
        if (params.uuid) {
          this.endpointsByUUID.set(params.uuid, ep);
        }
        addToDictionary(this.endpointsByElement, ep.elementId, ep);
        if (!this._suspendDrawing) {
          this._paintEndpoint(ep, {
            timestamp: this._suspendedAt
          });
        }
        return ep;
      }
    }, {
      key: "_deriveEndpointAndAnchorSpec",
      value: function _deriveEndpointAndAnchorSpec(type, dontPrependDefault) {
        var bits = ((dontPrependDefault ? "" : "default ") + type).split(/[\s]/),
            eps = null,
            ep = null,
            a = null,
            as = null;
        for (var i = 0; i < bits.length; i++) {
          var _t = this.getConnectionType(bits[i]);
          if (_t) {
            if (_t.endpoints) {
              eps = _t.endpoints;
            }
            if (_t.endpoint) {
              ep = _t.endpoint;
            }
            if (_t.anchors) {
              as = _t.anchors;
            }
            if (_t.anchor) {
              a = _t.anchor;
            }
          }
        }
        return {
          endpoints: eps ? eps : [ep, ep],
          anchors: as ? as : [a, a]
        };
      }
    }, {
      key: "revalidate",
      value: function revalidate(el, timestamp) {
        var elId = this.getId(el);
        this.updateOffset({
          elId: elId,
          recalc: true,
          timestamp: timestamp
        });
        return this.repaint(el);
      }
    }, {
      key: "repaintEverything",
      value: function repaintEverything() {
        var timestamp = uuid(),
            elId;
        for (elId in this._managedElements) {
          this.viewport.refreshElement(elId, true);
        }
        this.viewport.recomputeBounds();
        for (elId in this._managedElements) {
          this.repaint(this._managedElements[elId].el, timestamp, true);
        }
        return this;
      }
    }, {
      key: "setElementPosition",
      value: function setElementPosition(el, x, y) {
        var id = this.getId(el);
        this.viewport.setPosition(id, x, y);
        return this.repaint(el);
      }
    }, {
      key: "repaint",
      value: function repaint(el, timestamp, offsetsWereJustCalculated) {
        var r = {
          c: new Set(),
          e: new Set()
        };
        var _mergeRedraw = function _mergeRedraw(r2) {
          r2.c.forEach(function (c) {
            return r.c.add(c);
          });
          r2.e.forEach(function (e) {
            return r.e.add(e);
          });
        };
        if (!this._suspendDrawing) {
          var id = this.getId(el);
          if (el != null) {
            var repaintEls = this._getAssociatedElements(el);
            if (timestamp == null) {
              timestamp = uuid();
            }
            if (!offsetsWereJustCalculated) {
              for (var i = 0; i < repaintEls.length; i++) {
                this.updateOffset({
                  elId: this.getId(repaintEls[i]),
                  recalc: true,
                  timestamp: timestamp
                });
              }
            }
            _mergeRedraw(this.router.redraw(id, timestamp, null));
            if (repaintEls.length > 0) {
              for (var j = 0; j < repaintEls.length; j++) {
                _mergeRedraw(this.router.redraw(this.getId(repaintEls[j]), timestamp, null));
              }
            }
          }
        }
        return r;
      }
    }, {
      key: "unregisterEndpoint",
      value: function unregisterEndpoint(endpoint) {
        var uuid = endpoint.getUuid();
        if (uuid) {
          this.endpointsByUUID["delete"](uuid);
        }
        removeManagedEndpoint(this._managedElements[endpoint.elementId], endpoint);
        var ebe = this.endpointsByElement[endpoint.elementId];
        if (ebe != null) {
          if (ebe.length > 1) {
            this.endpointsByElement[endpoint.elementId] = ebe.filter(function (e) {
              return e !== endpoint;
            });
          } else {
            delete this.endpointsByElement[endpoint.elementId];
          }
        }
        this.fire(EVENT_INTERNAL_ENDPOINT_UNREGISTERED, endpoint);
      }
    }, {
      key: "_maybePruneEndpoint",
      value: function _maybePruneEndpoint(endpoint) {
        if (endpoint.deleteOnEmpty && endpoint.connections.length === 0) {
          this.deleteEndpoint(endpoint);
          return true;
        } else {
          return false;
        }
      }
    }, {
      key: "deleteEndpoint",
      value: function deleteEndpoint(object) {
        var _this5 = this;
        var endpoint = typeof object === "string" ? this.endpointsByUUID.get(object) : object;
        if (endpoint) {
          var proxy = endpoint.proxiedBy;
          var connectionsToDelete = endpoint.connections.slice();
          forEach(connectionsToDelete, function (connection) {
            endpoint.detachFromConnection(connection, null, true);
          });
          this.unregisterEndpoint(endpoint);
          endpoint.destroy();
          forEach(connectionsToDelete, function (connection) {
            _this5.deleteConnection(connection, {
              force: true,
              endpointToIgnore: endpoint
            });
          });
          if (proxy != null) {
            this.deleteEndpoint(proxy);
          }
        }
        return this;
      }
    }, {
      key: "addEndpoint",
      value: function addEndpoint(el, params, referenceParams) {
        referenceParams = referenceParams || {};
        var p = extend({}, referenceParams);
        extend(p, params || {});
        var _p = extend({
          element: el
        }, p);
        return this._internal_newEndpoint(_p);
      }
    }, {
      key: "addEndpoints",
      value: function addEndpoints(el, endpoints, referenceParams) {
        var results = [];
        for (var i = 0, j = endpoints.length; i < j; i++) {
          results.push(this.addEndpoint(el, endpoints[i], referenceParams));
        }
        return results;
      }
    }, {
      key: "reset",
      value: function reset() {
        var _this6 = this;
        this.silently(function () {
          _this6.endpointsByElement = {};
          _this6._managedElements = {};
          _this6.endpointsByUUID.clear();
          _this6.viewport.reset();
          _this6.router.reset();
          _this6.groupManager.reset();
          _this6.connections.length = 0;
        });
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.reset();
        this.unbind();
        this.sourceSelectors.length = 0;
        this.targetSelectors.length = 0;
        this._connectionTypes.clear();
        this._endpointTypes.clear();
      }
    }, {
      key: "getEndpoints",
      value: function getEndpoints(el) {
        return this.endpointsByElement[this.getId(el)] || [];
      }
    }, {
      key: "getEndpoint",
      value: function getEndpoint(uuid) {
        return this.endpointsByUUID.get(uuid);
      }
    }, {
      key: "setEndpointUuid",
      value: function setEndpointUuid(endpoint, uuid) {
        if (endpoint.uuid) {
          this.endpointsByUUID["delete"](endpoint.uuid);
        }
        endpoint.uuid = uuid;
        this.endpointsByUUID.set(uuid, endpoint);
      }
    }, {
      key: "connect",
      value: function connect(params, referenceParams) {
        try {
          var _p = this._prepareConnectionParams(params, referenceParams),
              jpc = this._newConnection(_p);
          this._finaliseConnection(jpc, _p);
          return jpc;
        } catch (errorMessage) {
          log(errorMessage);
          return;
        }
      }
    }, {
      key: "_prepareConnectionParams",
      value: function _prepareConnectionParams(params, referenceParams) {
        var temp = extend({}, params);
        if (referenceParams) {
          extend(temp, referenceParams);
        }
        var _p = temp;
        if (_p.source) {
          if (_p.source.endpoint) {
            _p.sourceEndpoint = _p.source;
          }
        }
        if (_p.target) {
          if (_p.target.endpoint) {
            _p.targetEndpoint = _p.target;
          }
        }
        if (params.uuids) {
          _p.sourceEndpoint = this.getEndpoint(params.uuids[0]);
          _p.targetEndpoint = this.getEndpoint(params.uuids[1]);
        }
        if (_p.sourceEndpoint != null) {
          if (_p.sourceEndpoint.isFull()) {
            throw ERROR_SOURCE_ENDPOINT_FULL;
          }
          if (!_p.type) {
            _p.type = _p.sourceEndpoint.edgeType;
          }
          if (_p.sourceEndpoint.connectorOverlays) {
            _p.overlays = _p.overlays || [];
            for (var i = 0, j = _p.sourceEndpoint.connectorOverlays.length; i < j; i++) {
              _p.overlays.push(_p.sourceEndpoint.connectorOverlays[i]);
            }
          }
          if (_p.sourceEndpoint.scope) {
            _p.scope = _p.sourceEndpoint.scope;
          }
        } else {
          if (_p.source == null) {
            throw ERROR_SOURCE_DOES_NOT_EXIST;
          }
        }
        if (_p.targetEndpoint != null) {
          if (_p.targetEndpoint.isFull()) {
            throw ERROR_TARGET_ENDPOINT_FULL;
          }
        } else {
          if (_p.target == null) {
            throw ERROR_TARGET_DOES_NOT_EXIST;
          }
        }
        if (_p.sourceEndpoint && _p.targetEndpoint) {
          if (!_scopeMatch(_p.sourceEndpoint, _p.targetEndpoint)) {
            throw "Cannot establish connection: scopes do not match";
          }
        }
        return _p;
      }
    }, {
      key: "_newConnection",
      value: function _newConnection(params) {
        params.id = "con_" + this._idstamp();
        var c = new Connection(this, params);
        addManagedConnection(c, this._managedElements[c.sourceId], this._managedElements[c.targetId]);
        this._paintConnection(c);
        return c;
      }
    }, {
      key: "_finaliseConnection",
      value: function _finaliseConnection(jpc, params, originalEvent) {
        params = params || {};
        if (!jpc.suspendedEndpoint) {
          this.connections.push(jpc);
        }
        jpc.pending = null;
        jpc.endpoints[0].isTemporarySource = false;
        this.repaint(jpc.source);
        var payload = {
          connection: jpc,
          source: jpc.source,
          target: jpc.target,
          sourceId: jpc.sourceId,
          targetId: jpc.targetId,
          sourceEndpoint: jpc.endpoints[0],
          targetEndpoint: jpc.endpoints[1]
        };
        this.fire(EVENT_INTERNAL_CONNECTION, payload, originalEvent);
        if (!params.doNotFireConnectionEvent && params.fireEvent !== false) {
          this.fire(EVENT_CONNECTION, payload, originalEvent);
        }
      }
    }, {
      key: "removeAllEndpoints",
      value: function removeAllEndpoints(el, recurse) {
        var _this7 = this;
        var _one = function _one(_el) {
          var id = _this7.getId(_el),
              ebe = _this7.endpointsByElement[id],
              i,
              ii;
          if (ebe) {
            for (i = 0, ii = ebe.length; i < ii; i++) {
              _this7.deleteEndpoint(ebe[i]);
            }
          }
          delete _this7.endpointsByElement[id];
        };
        if (recurse) {
          this._getAssociatedElements(el).map(_one);
        }
        _one(el);
        return this;
      }
    }, {
      key: "_createSourceDefinition",
      value: function _createSourceDefinition(params, referenceParams) {
        var p = extend({}, referenceParams);
        extend(p, params);
        p.edgeType = p.edgeType || DEFAULT$1;
        var aae = this._deriveEndpointAndAnchorSpec(p.edgeType);
        p.endpoint = p.endpoint || aae.endpoints[0];
        p.anchor = p.anchor || aae.anchors[0];
        var maxConnections = p.maxConnections || -1;
        var _def = {
          def: extend({}, p),
          uniqueEndpoint: p.uniqueEndpoint,
          maxConnections: maxConnections,
          enabled: true,
          endpoint: null
        };
        return _def;
      }
    }, {
      key: "addSourceSelector",
      value: function addSourceSelector(selector, params) {
        var exclude = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var _def = this._createSourceDefinition(params);
        var sel = new SourceSelector(selector, _def, exclude);
        this.sourceSelectors.push(sel);
        return sel;
      }
    }, {
      key: "removeSourceSelector",
      value: function removeSourceSelector(selector) {
        removeWithFunction(this.sourceSelectors, function (s) {
          return s === selector;
        });
      }
    }, {
      key: "removeTargetSelector",
      value: function removeTargetSelector(selector) {
        removeWithFunction(this.targetSelectors, function (s) {
          return s === selector;
        });
      }
    }, {
      key: "addTargetSelector",
      value: function addTargetSelector(selector, params) {
        var exclude = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var _def = this._createTargetDefinition(params);
        var sel = new TargetSelector(selector, _def, exclude);
        this.targetSelectors.push(sel);
        return sel;
      }
    }, {
      key: "_createTargetDefinition",
      value: function _createTargetDefinition(params, referenceParams) {
        var p = extend({}, referenceParams);
        extend(p, params);
        p.edgeType = p.edgeType || DEFAULT$1;
        var maxConnections = p.maxConnections || -1;
        var _def = {
          def: extend({}, p),
          uniqueEndpoint: p.uniqueEndpoint,
          maxConnections: maxConnections,
          enabled: true,
          endpoint: null
        };
        return _def;
      }
    }, {
      key: "show",
      value: function show(el, changeEndpoints) {
        return this._setVisible(el, BLOCK, changeEndpoints);
      }
    }, {
      key: "hide",
      value: function hide(el, changeEndpoints) {
        return this._setVisible(el, NONE$1, changeEndpoints);
      }
    }, {
      key: "_setVisible",
      value: function _setVisible(el, state, alsoChangeEndpoints) {
        var visible = state === BLOCK;
        var endpointFunc = null;
        if (alsoChangeEndpoints) {
          endpointFunc = function endpointFunc(ep) {
            ep.setVisible(visible, true, true);
          };
        }
        var id = this.getId(el);
        this._operation(el, function (jpc) {
          if (visible && alsoChangeEndpoints) {
            var oidx = jpc.sourceId === id ? 1 : 0;
            if (jpc.endpoints[oidx].isVisible()) {
              jpc.setVisible(true);
            }
          } else {
            jpc.setVisible(visible);
          }
        }, endpointFunc);
        return this;
      }
    }, {
      key: "toggleVisible",
      value: function toggleVisible(el, changeEndpoints) {
        var endpointFunc = null;
        if (changeEndpoints) {
          endpointFunc = function endpointFunc(ep) {
            var state = ep.isVisible();
            ep.setVisible(!state);
          };
        }
        this._operation(el, function (jpc) {
          var state = jpc.isVisible();
          jpc.setVisible(!state);
        }, endpointFunc);
      }
    }, {
      key: "_operation",
      value: function _operation(el, func, endpointFunc) {
        var elId = this.getId(el);
        var endpoints = this.endpointsByElement[elId];
        if (endpoints && endpoints.length) {
          for (var i = 0, ii = endpoints.length; i < ii; i++) {
            for (var j = 0, jj = endpoints[i].connections.length; j < jj; j++) {
              var retVal = func(endpoints[i].connections[j]);
              if (retVal) {
                return;
              }
            }
            if (endpointFunc) {
              endpointFunc(endpoints[i]);
            }
          }
        }
      }
    }, {
      key: "registerConnectionType",
      value: function registerConnectionType(id, type) {
        this._connectionTypes.set(id, extend({}, type));
        if (type.overlays) {
          var to = {};
          for (var i = 0; i < type.overlays.length; i++) {
            var fo = convertToFullOverlaySpec(type.overlays[i]);
            to[fo.options.id] = fo;
          }
          this._connectionTypes.get(id).overlays = to;
        }
      }
    }, {
      key: "registerConnectionTypes",
      value: function registerConnectionTypes(types) {
        for (var i in types) {
          this.registerConnectionType(i, types[i]);
        }
      }
    }, {
      key: "registerEndpointType",
      value: function registerEndpointType(id, type) {
        this._endpointTypes.set(id, extend({}, type));
        if (type.overlays) {
          var to = {};
          for (var i = 0; i < type.overlays.length; i++) {
            var fo = convertToFullOverlaySpec(type.overlays[i]);
            to[fo.options.id] = fo;
          }
          this._endpointTypes.get(id).overlays = to;
        }
      }
    }, {
      key: "registerEndpointTypes",
      value: function registerEndpointTypes(types) {
        for (var i in types) {
          this.registerEndpointType(i, types[i]);
        }
      }
    }, {
      key: "getType",
      value: function getType(id, typeDescriptor) {
        return typeDescriptor === "connection" ? this.getConnectionType(id) : this.getEndpointType(id);
      }
    }, {
      key: "getConnectionType",
      value: function getConnectionType(id) {
        return this._connectionTypes.get(id);
      }
    }, {
      key: "getEndpointType",
      value: function getEndpointType(id) {
        return this._endpointTypes.get(id);
      }
    }, {
      key: "importDefaults",
      value: function importDefaults(d) {
        for (var i in d) {
          this.defaults[i] = d[i];
        }
        if (d.container) {
          this.setContainer(d.container);
        }
        return this;
      }
    }, {
      key: "restoreDefaults",
      value: function restoreDefaults() {
        this.defaults = extend({}, this._initialDefaults);
        return this;
      }
    }, {
      key: "getManagedElements",
      value: function getManagedElements() {
        return this._managedElements;
      }
    }, {
      key: "proxyConnection",
      value: function proxyConnection(connection, index, proxyEl, endpointGenerator, anchorGenerator) {
        var alreadyProxied = connection.proxies[index] != null,
            proxyEp,
            originalElementId = alreadyProxied ? connection.proxies[index].originalEp.elementId : connection.endpoints[index].elementId,
            originalEndpoint = alreadyProxied ? connection.proxies[index].originalEp : connection.endpoints[index],
            proxyElId = this.getId(proxyEl);
        if (connection.proxies[index]) {
          if (connection.proxies[index].ep.elementId === proxyElId) {
            proxyEp = connection.proxies[index].ep;
          } else {
            connection.proxies[index].ep.detachFromConnection(connection, index);
            proxyEp = this._internal_newEndpoint({
              element: proxyEl,
              endpoint: endpointGenerator(connection, index),
              anchor: anchorGenerator(connection, index),
              parameters: {
                isProxyEndpoint: true
              }
            });
          }
        } else {
          proxyEp = this._internal_newEndpoint({
            element: proxyEl,
            endpoint: endpointGenerator(connection, index),
            anchor: anchorGenerator(connection, index),
            parameters: {
              isProxyEndpoint: true
            }
          });
        }
        proxyEp.deleteOnEmpty = true;
        connection.proxies[index] = {
          ep: proxyEp,
          originalEp: originalEndpoint
        };
        this.sourceOrTargetChanged(originalElementId, proxyElId, connection, proxyEl, index);
        originalEndpoint.detachFromConnection(connection, null, true);
        proxyEp.connections = [connection];
        connection.endpoints[index] = proxyEp;
        originalEndpoint.proxiedBy = proxyEp;
        originalEndpoint.setVisible(false);
        connection.setVisible(true);
        this.revalidate(proxyEl);
      }
    }, {
      key: "unproxyConnection",
      value: function unproxyConnection(connection, index) {
        if (connection.proxies == null || connection.proxies[index] == null) {
          return;
        }
        var originalElement = connection.proxies[index].originalEp.element,
            originalElementId = connection.proxies[index].originalEp.elementId,
            proxyElId = connection.proxies[index].ep.elementId;
        connection.endpoints[index] = connection.proxies[index].originalEp;
        delete connection.proxies[index].originalEp.proxiedBy;
        this.sourceOrTargetChanged(proxyElId, originalElementId, connection, originalElement, index);
        connection.proxies[index].ep.detachFromConnection(connection, null);
        connection.proxies[index].originalEp.addConnection(connection);
        if (connection.isVisible()) {
          connection.proxies[index].originalEp.setVisible(true);
        }
        connection.proxies[index] = null;
        if (findWithFunction(connection.proxies, function (p) {
          return p != null;
        }) === -1) {
          connection.proxies.length = 0;
        }
      }
    }, {
      key: "sourceOrTargetChanged",
      value: function sourceOrTargetChanged(originalId, newId, connection, newElement, index) {
        if (originalId !== newId) {
          if (index === 0) {
            connection.sourceId = newId;
            connection.source = newElement;
          } else if (index === 1) {
            connection.targetId = newId;
            connection.target = newElement;
          }
          removeManagedConnection(connection, this._managedElements[originalId]);
          addManagedConnection(connection, this._managedElements[newId]);
        }
      }
    }, {
      key: "getGroup",
      value: function getGroup(groupId) {
        return this.groupManager.getGroup(groupId);
      }
    }, {
      key: "getGroupFor",
      value: function getGroupFor(el) {
        return this.groupManager.getGroupFor(el);
      }
    }, {
      key: "addGroup",
      value: function addGroup(params) {
        return this.groupManager.addGroup(params);
      }
    }, {
      key: "addToGroup",
      value: function addToGroup(group) {
        var _this$groupManager;
        for (var _len = arguments.length, el = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          el[_key - 1] = arguments[_key];
        }
        return (_this$groupManager = this.groupManager).addToGroup.apply(_this$groupManager, [group, false].concat(el));
      }
    }, {
      key: "collapseGroup",
      value: function collapseGroup(group) {
        this.groupManager.collapseGroup(group);
      }
    }, {
      key: "expandGroup",
      value: function expandGroup(group) {
        this.groupManager.expandGroup(group);
      }
    }, {
      key: "toggleGroup",
      value: function toggleGroup(group) {
        this.groupManager.toggleGroup(group);
      }
    }, {
      key: "removeGroup",
      value: function removeGroup(group, deleteMembers, manipulateView, doNotFireEvent) {
        return this.groupManager.removeGroup(group, deleteMembers, manipulateView, doNotFireEvent);
      }
    }, {
      key: "removeAllGroups",
      value: function removeAllGroups(deleteMembers, manipulateView) {
        this.groupManager.removeAllGroups(deleteMembers, manipulateView, false);
      }
    }, {
      key: "removeFromGroup",
      value: function removeFromGroup(group, el, doNotFireEvent) {
        this.groupManager.removeFromGroup(group, doNotFireEvent, el);
        this._appendElement(el, this.getContainer());
        this.updateOffset({
          recalc: true,
          elId: this.getId(el)
        });
      }
    }, {
      key: "_paintEndpoint",
      value: function _paintEndpoint(endpoint, params) {
        function findConnectionToUseForDynamicAnchor(ep) {
          var idx = 0;
          if (params.elementWithPrecedence != null) {
            for (var i = 0; i < ep.connections.length; i++) {
              if (ep.connections[i].sourceId === params.elementWithPrecedence || ep.connections[i].targetId === params.elementWithPrecedence) {
                idx = i;
                break;
              }
            }
          }
          return ep.connections[idx];
        }
        params = params || {};
        var timestamp = params.timestamp,
            recalc = !(params.recalc === false);
        if (!timestamp || endpoint.timestamp !== timestamp) {
          var info = this.viewport.getPosition(endpoint.elementId);
          var xy = params.offset ? {
            x: params.offset.x,
            y: params.offset.y
          } : {
            x: info.x,
            y: info.y
          };
          if (xy != null) {
            var ap = params.anchorLoc;
            if (ap == null) {
              var anchorParams = {
                xy: xy,
                wh: info,
                element: endpoint,
                timestamp: timestamp
              };
              if (recalc && this.router.isDynamicAnchor(endpoint) && endpoint.connections.length > 0) {
                var _c3 = findConnectionToUseForDynamicAnchor(endpoint),
                    oIdx = _c3.endpoints[0] === endpoint ? 1 : 0,
                    oId = oIdx === 0 ? _c3.sourceId : _c3.targetId,
                    oInfo = this.viewport.getPosition(oId);
                anchorParams.index = oIdx === 0 ? 1 : 0;
                anchorParams.connection = _c3;
                anchorParams.txy = oInfo;
                anchorParams.twh = oInfo;
                anchorParams.tElement = _c3.endpoints[oIdx];
                anchorParams.tRotation = this._getRotations(oId);
              } else if (endpoint.connections.length > 0) {
                anchorParams.connection = endpoint.connections[0];
              }
              anchorParams.rotation = this._getRotations(endpoint.elementId);
              ap = this.router.computeAnchorLocation(endpoint._anchor, anchorParams);
            }
            endpoint.endpoint.compute(ap, this.router.getEndpointOrientation(endpoint), endpoint.paintStyleInUse);
            this.renderEndpoint(endpoint, endpoint.paintStyleInUse);
            endpoint.timestamp = timestamp;
            for (var i in endpoint.overlays) {
              if (endpoint.overlays.hasOwnProperty(i)) {
                var _o = endpoint.overlays[i];
                if (_o.isVisible()) {
                  endpoint.overlayPlacements[i] = this.drawOverlay(_o, endpoint.endpoint, endpoint.paintStyleInUse, endpoint.getAbsoluteOverlayPosition(_o));
                  this._paintOverlay(_o, endpoint.overlayPlacements[i], {
                    xmin: 0,
                    ymin: 0
                  });
                }
              }
            }
          }
        }
      }
    }, {
      key: "_paintConnection",
      value: function _paintConnection(connection, params) {
        if (!this._suspendDrawing && connection.visible !== false) {
          params = params || {};
          var timestamp = params.timestamp;
          if (timestamp != null && timestamp === connection.lastPaintedAt) {
            return;
          }
          if (timestamp == null || timestamp !== connection.lastPaintedAt) {
            this.router.computePath(connection, timestamp);
            var overlayExtents = {
              xmin: Infinity,
              ymin: Infinity,
              xmax: -Infinity,
              ymax: -Infinity
            };
            for (var i in connection.overlays) {
              if (connection.overlays.hasOwnProperty(i)) {
                var _o2 = connection.overlays[i];
                if (_o2.isVisible()) {
                  connection.overlayPlacements[i] = this.drawOverlay(_o2, connection.connector, connection.paintStyleInUse, connection.getAbsoluteOverlayPosition(_o2));
                  overlayExtents.xmin = Math.min(overlayExtents.xmin, connection.overlayPlacements[i].xmin);
                  overlayExtents.xmax = Math.max(overlayExtents.xmax, connection.overlayPlacements[i].xmax);
                  overlayExtents.ymin = Math.min(overlayExtents.ymin, connection.overlayPlacements[i].ymin);
                  overlayExtents.ymax = Math.max(overlayExtents.ymax, connection.overlayPlacements[i].ymax);
                }
              }
            }
            var lineWidth = parseFloat("" + connection.paintStyleInUse.strokeWidth || "1") / 2,
                outlineWidth = parseFloat("" + connection.paintStyleInUse.strokeWidth || "0"),
                _extents = {
              xmin: Math.min(connection.connector.bounds.xmin - (lineWidth + outlineWidth), overlayExtents.xmin),
              ymin: Math.min(connection.connector.bounds.ymin - (lineWidth + outlineWidth), overlayExtents.ymin),
              xmax: Math.max(connection.connector.bounds.xmax + (lineWidth + outlineWidth), overlayExtents.xmax),
              ymax: Math.max(connection.connector.bounds.ymax + (lineWidth + outlineWidth), overlayExtents.ymax)
            };
            this.paintConnector(connection.connector, connection.paintStyleInUse, _extents);
            for (var j in connection.overlays) {
              if (connection.overlays.hasOwnProperty(j)) {
                var _p2 = connection.overlays[j];
                if (_p2.isVisible()) {
                  this._paintOverlay(_p2, connection.overlayPlacements[j], _extents);
                }
              }
            }
          }
          connection.lastPaintedAt = timestamp;
        }
      }
    }, {
      key: "_refreshEndpoint",
      value: function _refreshEndpoint(endpoint) {
        if (endpoint.connections.length > 0) {
          this.addEndpointClass(endpoint, this.endpointConnectedClass);
        } else {
          this.removeEndpointClass(endpoint, this.endpointConnectedClass);
        }
        if (endpoint.isFull()) {
          this.addEndpointClass(endpoint, this.endpointFullClass);
        } else {
          this.removeEndpointClass(endpoint, this.endpointFullClass);
        }
      }
    }, {
      key: "_makeConnector",
      value: function _makeConnector(connection, name, args) {
        return Connectors.get(connection, name, args);
      }
    }, {
      key: "addOverlay",
      value: function addOverlay(component, overlay, doNotRevalidate) {
        component.addOverlay(overlay);
        if (!doNotRevalidate) {
          var relatedElement = component instanceof Endpoint ? component.element : component.source;
          this.revalidate(relatedElement);
        }
      }
    }, {
      key: "getPathData",
      value: function getPathData(connector) {
        var p = "";
        for (var i = 0; i < connector.segments.length; i++) {
          p += connector.segments[i].getPath(i === 0);
          p += " ";
        }
        return p;
      }
    }]);
    return JsPlumbInstance;
  }(EventGenerator);

  var VERY_SMALL_VALUE = 0.0000000001;
  function gentleRound(n) {
    var f = Math.floor(n),
        r = Math.ceil(n);
    if (n - f < VERY_SMALL_VALUE) {
      return f;
    } else if (r - n < VERY_SMALL_VALUE) {
      return r;
    }
    return n;
  }
  var ArcSegment = function (_AbstractSegment) {
    _inherits$a(ArcSegment, _AbstractSegment);
    var _super = _createSuper$a(ArcSegment);
    function ArcSegment(params) {
      var _this;
      _classCallCheck$f(this, ArcSegment);
      _this = _super.call(this, params);
      _defineProperty$e(_assertThisInitialized$a(_this), "type", ArcSegment.segmentType);
      _defineProperty$e(_assertThisInitialized$a(_this), "cx", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "cy", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "radius", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "anticlockwise", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "startAngle", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "endAngle", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "sweep", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "length", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "circumference", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "frac", void 0);
      _this.cx = params.cx;
      _this.cy = params.cy;
      _this.radius = params.r;
      _this.anticlockwise = params.ac;
      if (params.startAngle && params.endAngle) {
        _this.startAngle = params.startAngle;
        _this.endAngle = params.endAngle;
        _this.x1 = _this.cx + _this.radius * Math.cos(_this.startAngle);
        _this.y1 = _this.cy + _this.radius * Math.sin(_this.startAngle);
        _this.x2 = _this.cx + _this.radius * Math.cos(_this.endAngle);
        _this.y2 = _this.cy + _this.radius * Math.sin(_this.endAngle);
      } else {
        _this.startAngle = _this._calcAngle(_this.x1, _this.y1);
        _this.endAngle = _this._calcAngle(_this.x2, _this.y2);
      }
      if (_this.endAngle < 0) {
        _this.endAngle += TWO_PI;
      }
      if (_this.startAngle < 0) {
        _this.startAngle += TWO_PI;
      }
      var ea = _this.endAngle < _this.startAngle ? _this.endAngle + TWO_PI : _this.endAngle;
      _this.sweep = Math.abs(ea - _this.startAngle);
      if (_this.anticlockwise) {
        _this.sweep = TWO_PI - _this.sweep;
      }
      _this.circumference = 2 * Math.PI * _this.radius;
      _this.frac = _this.sweep / TWO_PI;
      _this.length = _this.circumference * _this.frac;
      _this.extents = {
        xmin: _this.cx - _this.radius,
        xmax: _this.cx + _this.radius,
        ymin: _this.cy - _this.radius,
        ymax: _this.cy + _this.radius
      };
      return _this;
    }
    _createClass$f(ArcSegment, [{
      key: "_calcAngle",
      value: function _calcAngle(_x, _y) {
        return theta({
          x: this.cx,
          y: this.cy
        }, {
          x: _x,
          y: _y
        });
      }
    }, {
      key: "_calcAngleForLocation",
      value: function _calcAngleForLocation(segment, location) {
        if (segment.anticlockwise) {
          var sa = segment.startAngle < segment.endAngle ? segment.startAngle + TWO_PI : segment.startAngle,
              s = Math.abs(sa - segment.endAngle);
          return sa - s * location;
        } else {
          var ea = segment.endAngle < segment.startAngle ? segment.endAngle + TWO_PI : segment.endAngle,
              ss = Math.abs(ea - segment.startAngle);
          return segment.startAngle + ss * location;
        }
      }
    }, {
      key: "getPath",
      value: function getPath(isFirstSegment) {
        var laf = this.sweep > Math.PI ? 1 : 0,
            sf = this.anticlockwise ? 0 : 1;
        return (isFirstSegment ? "M" + this.x1 + " " + this.y1 + " " : "") + "A " + this.radius + " " + this.radius + " 0 " + laf + "," + sf + " " + this.x2 + " " + this.y2;
      }
    }, {
      key: "getLength",
      value: function getLength() {
        return this.length;
      }
    }, {
      key: "pointOnPath",
      value: function pointOnPath(location, absolute) {
        if (location === 0) {
          return {
            x: this.x1,
            y: this.y1,
            theta: this.startAngle
          };
        } else if (location === 1) {
          return {
            x: this.x2,
            y: this.y2,
            theta: this.endAngle
          };
        }
        if (absolute) {
          location = location / length;
        }
        var angle = this._calcAngleForLocation(this, location),
            _x = this.cx + this.radius * Math.cos(angle),
            _y = this.cy + this.radius * Math.sin(angle);
        return {
          x: gentleRound(_x),
          y: gentleRound(_y),
          theta: angle
        };
      }
    }, {
      key: "gradientAtPoint",
      value: function gradientAtPoint(location, absolute) {
        var p = this.pointOnPath(location, absolute);
        var m = normal({
          x: this.cx,
          y: this.cy
        }, p);
        if (!this.anticlockwise && (m === Infinity || m === -Infinity)) {
          m *= -1;
        }
        return m;
      }
    }, {
      key: "pointAlongPathFrom",
      value: function pointAlongPathFrom(location, distance, absolute) {
        var p = this.pointOnPath(location, absolute),
            arcSpan = distance / this.circumference * 2 * Math.PI,
            dir = this.anticlockwise ? -1 : 1,
            startAngle = p.theta + dir * arcSpan,
            startX = this.cx + this.radius * Math.cos(startAngle),
            startY = this.cy + this.radius * Math.sin(startAngle);
        return {
          x: startX,
          y: startY
        };
      }
    }]);
    return ArcSegment;
  }(AbstractSegment);
  _defineProperty$e(ArcSegment, "segmentType", "Arc");

  var DEFAULT_WIDTH = 20;
  var DEFAULT_LENGTH = 20;
  var ArrowOverlay = function (_Overlay) {
    _inherits$a(ArrowOverlay, _Overlay);
    var _super = _createSuper$a(ArrowOverlay);
    function ArrowOverlay(instance, component, p) {
      var _this;
      _classCallCheck$f(this, ArrowOverlay);
      _this = _super.call(this, instance, component, p);
      _this.instance = instance;
      _this.component = component;
      _defineProperty$e(_assertThisInitialized$a(_this), "width", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "length", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "foldback", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "direction", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "location", 0.5);
      _defineProperty$e(_assertThisInitialized$a(_this), "paintStyle", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "type", ArrowOverlay.type);
      _defineProperty$e(_assertThisInitialized$a(_this), "cachedDimensions", void 0);
      p = p || {};
      _this.width = p.width || DEFAULT_WIDTH;
      _this.length = p.length || DEFAULT_LENGTH;
      _this.direction = (p.direction || 1) < 0 ? -1 : 1;
      _this.foldback = p.foldback || 0.623;
      _this.paintStyle = p.paintStyle || {
        "strokeWidth": 1
      };
      _this.location = p.location == null ? _this.location : Array.isArray(p.location) ? p.location[0] : p.location;
      return _this;
    }
    _createClass$f(ArrowOverlay, [{
      key: "draw",
      value: function draw(component, currentConnectionPaintStyle, absolutePosition) {
        if (component instanceof AbstractConnector) {
          var connector = component;
          var hxy, mid, txy, tail, cxy;
          if (this.location > 1 || this.location < 0) {
            var fromLoc = this.location < 0 ? 1 : 0;
            hxy = connector.pointAlongPathFrom(fromLoc, this.location, false);
            mid = connector.pointAlongPathFrom(fromLoc, this.location - this.direction * this.length / 2, false);
            txy = pointOnLine(hxy, mid, this.length);
          } else if (this.location === 1) {
            hxy = connector.pointOnPath(this.location);
            mid = connector.pointAlongPathFrom(this.location, -this.length);
            txy = pointOnLine(hxy, mid, this.length);
            if (this.direction === -1) {
              var _ = txy;
              txy = hxy;
              hxy = _;
            }
          } else if (this.location === 0) {
            txy = connector.pointOnPath(this.location);
            mid = connector.pointAlongPathFrom(this.location, this.length);
            hxy = pointOnLine(txy, mid, this.length);
            if (this.direction === -1) {
              var __ = txy;
              txy = hxy;
              hxy = __;
            }
          } else {
            hxy = connector.pointAlongPathFrom(this.location, this.direction * this.length / 2);
            mid = connector.pointOnPath(this.location);
            txy = pointOnLine(hxy, mid, this.length);
          }
          tail = perpendicularLineTo(hxy, txy, this.width);
          cxy = pointOnLine(hxy, txy, this.foldback * this.length);
          var d = {
            hxy: hxy,
            tail: tail,
            cxy: cxy
          },
              stroke = this.paintStyle.stroke || currentConnectionPaintStyle.stroke,
              fill = this.paintStyle.fill || currentConnectionPaintStyle.stroke,
              lineWidth = this.paintStyle.strokeWidth || currentConnectionPaintStyle.strokeWidth;
          return {
            component: component,
            d: d,
            "stroke-width": lineWidth,
            stroke: stroke,
            fill: fill,
            xmin: Math.min(hxy.x, tail[0].x, tail[1].x),
            xmax: Math.max(hxy.x, tail[0].x, tail[1].x),
            ymin: Math.min(hxy.y, tail[0].y, tail[1].y),
            ymax: Math.max(hxy.y, tail[0].y, tail[1].y)
          };
        }
      }
    }, {
      key: "updateFrom",
      value: function updateFrom(d) {}
    }]);
    return ArrowOverlay;
  }(Overlay);
  _defineProperty$e(ArrowOverlay, "type", "Arrow");
  function isArrowOverlay(o) {
    return o.type === ArrowOverlay.type;
  }
  OverlayFactory.register(ArrowOverlay.type, ArrowOverlay);

  var PlainArrowOverlay = function (_ArrowOverlay) {
    _inherits$a(PlainArrowOverlay, _ArrowOverlay);
    var _super = _createSuper$a(PlainArrowOverlay);
    function PlainArrowOverlay(instance, component, p) {
      var _this;
      _classCallCheck$f(this, PlainArrowOverlay);
      _this = _super.call(this, instance, component, p);
      _this.instance = instance;
      _defineProperty$e(_assertThisInitialized$a(_this), "type", PlainArrowOverlay.type);
      _this.foldback = 1;
      return _this;
    }
    return PlainArrowOverlay;
  }(ArrowOverlay);
  _defineProperty$e(PlainArrowOverlay, "type", "PlainArrow");
  function isPlainArrowOverlay(o) {
    return o.type === PlainArrowOverlay.type;
  }
  OverlayFactory.register("PlainArrow", PlainArrowOverlay);

  var DiamondOverlay = function (_ArrowOverlay) {
    _inherits$a(DiamondOverlay, _ArrowOverlay);
    var _super = _createSuper$a(DiamondOverlay);
    function DiamondOverlay(instance, component, p) {
      var _this;
      _classCallCheck$f(this, DiamondOverlay);
      _this = _super.call(this, instance, component, p);
      _this.instance = instance;
      _defineProperty$e(_assertThisInitialized$a(_this), "type", DiamondOverlay.type);
      _this.length = _this.length / 2;
      _this.foldback = 2;
      return _this;
    }
    return DiamondOverlay;
  }(ArrowOverlay);
  _defineProperty$e(DiamondOverlay, "type", "Diamond");
  function isDiamondOverlay(o) {
    return o.type === DiamondOverlay.type;
  }
  OverlayFactory.register(DiamondOverlay.type, DiamondOverlay);

  var CustomOverlay = function (_Overlay) {
    _inherits$a(CustomOverlay, _Overlay);
    var _super = _createSuper$a(CustomOverlay);
    function CustomOverlay(instance, component, p) {
      var _this;
      _classCallCheck$f(this, CustomOverlay);
      _this = _super.call(this, instance, component, p);
      _this.instance = instance;
      _this.component = component;
      _defineProperty$e(_assertThisInitialized$a(_this), "create", void 0);
      _defineProperty$e(_assertThisInitialized$a(_this), "type", CustomOverlay.type);
      _this.create = p.create;
      return _this;
    }
    _createClass$f(CustomOverlay, [{
      key: "updateFrom",
      value: function updateFrom(d) {}
    }]);
    return CustomOverlay;
  }(Overlay);
  _defineProperty$e(CustomOverlay, "type", "Custom");
  function isCustomOverlay(o) {
    return o.type === CustomOverlay.type;
  }
  OverlayFactory.register(CustomOverlay.type, CustomOverlay);

  EndpointFactory.registerHandler(DotEndpointHandler);
  EndpointFactory.registerHandler(RectangleEndpointHandler);
  EndpointFactory.registerHandler(BlankEndpointHandler);
  Connectors.register(StraightConnector.type, StraightConnector);

  function _typeof$1(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof$1 = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof$1 = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof$1(obj);
  }

  function _classCallCheck$e(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$e(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$e(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$e(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$e(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty$d(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _inherits$9(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf$9(subClass, superClass);
  }

  function _getPrototypeOf$9(o) {
    _getPrototypeOf$9 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$9(o);
  }

  function _setPrototypeOf$9(o, p) {
    _setPrototypeOf$9 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$9(o, p);
  }

  function _isNativeReflectConstruct$9() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _assertThisInitialized$9(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn$9(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized$9(self);
  }

  function _createSuper$9(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$9();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf$9(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$9(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn$9(this, result);
    };
  }

  function _superPropBase$3(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf$9(object);
      if (object === null) break;
    }

    return object;
  }

  function _get$3(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get$3 = Reflect.get;
    } else {
      _get$3 = function _get(target, property, receiver) {
        var base = _superPropBase$3(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };
    }

    return _get$3(target, property, receiver || target);
  }

  function _slicedToArray$3(arr, i) {
    return _arrayWithHoles$3(arr) || _iterableToArrayLimit$3(arr, i) || _unsupportedIterableToArray$3(arr, i) || _nonIterableRest$3();
  }

  function _arrayWithHoles$3(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArrayLimit$3(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;

    var _s, _e;

    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray$3(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray$3(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen);
  }

  function _arrayLikeToArray$3(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableRest$3() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function matchesSelector$1(el, selector, ctx) {
    ctx = ctx || el.parentNode;
    var possibles = ctx.querySelectorAll(selector);
    for (var i = 0; i < possibles.length; i++) {
      if (possibles[i] === el) {
        return true;
      }
    }
    return false;
  }
  function consume(e, doNotPreventDefault) {
    if (e.stopPropagation) {
      e.stopPropagation();
    } else {
      e.returnValue = false;
    }
    if (!doNotPreventDefault && e.preventDefault) {
      e.preventDefault();
    }
  }
  function findParent(el, selector, container, matchOnElementAlso) {
    if (matchOnElementAlso && matchesSelector$1(el, selector, container)) {
      return el;
    } else {
      el = el.parentNode;
    }
    while (el != null && el !== container) {
      if (matchesSelector$1(el, selector)) {
        return el;
      } else {
        el = el.parentNode;
      }
    }
  }
  function getEventSource(e) {
    return e.srcElement || e.target;
  }
  function _setClassName(el, cn, classList) {
    cn = fastTrim(cn);
    if (typeof el.className.baseVal !== "undefined") {
      el.className.baseVal = cn;
    } else {
      el.className = cn;
    }
    try {
      var cl = el.classList;
      if (cl != null) {
        while (cl.length > 0) {
          cl.remove(cl.item(0));
        }
        for (var i = 0; i < classList.length; i++) {
          if (classList[i]) {
            cl.add(classList[i]);
          }
        }
      }
    } catch (e) {
      log("JSPLUMB: cannot set class list", e);
    }
  }
  function _getClassName(el) {
    return el.className != null ? typeof el.className.baseVal === "undefined" ? el.className : el.className.baseVal : "";
  }
  function _classManip(el, classesToAdd, classesToRemove) {
    var cta = classesToAdd == null ? [] : Array.isArray(classesToAdd) ? classesToAdd : classesToAdd.split(/\s+/);
    var ctr = classesToRemove == null ? [] : Array.isArray(classesToRemove) ? classesToRemove : classesToRemove.split(/\s+/);
    var className = _getClassName(el),
        curClasses = className.split(/\s+/);
    var _oneSet = function _oneSet(add, classes) {
      for (var i = 0; i < classes.length; i++) {
        if (add) {
          if (curClasses.indexOf(classes[i]) === -1) {
            curClasses.push(classes[i]);
          }
        } else {
          var idx = curClasses.indexOf(classes[i]);
          if (idx !== -1) {
            curClasses.splice(idx, 1);
          }
        }
      }
    };
    _oneSet(true, cta);
    _oneSet(false, ctr);
    _setClassName(el, curClasses.join(" "), curClasses);
  }
  function isNodeList(el) {
    return !isString(el) && !Array.isArray(el) && el.length != null && el.documentElement == null && el.nodeType == null;
  }
  function isArrayLike(el) {
    return !isString(el) && (Array.isArray(el) || isNodeList(el));
  }
  function getClass(el) {
    return _getClassName(el);
  }
  function addClass(el, clazz) {
    var _one = function _one(el, clazz) {
      if (el != null && clazz != null && clazz.length > 0) {
        if (el.classList) {
          var parts = fastTrim(clazz).split(/\s+/);
          forEach(parts, function (part) {
            el.classList.add(part);
          });
        } else {
          _classManip(el, clazz);
        }
      }
    };
    if (isNodeList(el)) {
      forEach(el, function (el) {
        return _one(el, clazz);
      });
    } else {
      _one(el, clazz);
    }
  }
  function hasClass(el, clazz) {
    if (el.classList) {
      return el.classList.contains(clazz);
    } else {
      return _getClassName(el).indexOf(clazz) !== -1;
    }
  }
  function removeClass(el, clazz) {
    var _one = function _one(el, clazz) {
      if (el != null && clazz != null && clazz.length > 0) {
        if (el.classList) {
          var parts = fastTrim(clazz).split(/\s+/);
          parts.forEach(function (part) {
            el.classList.remove(part);
          });
        } else {
          _classManip(el, null, clazz);
        }
      }
    };
    if (isNodeList(el)) {
      forEach(el, function (el) {
        return _one(el, clazz);
      });
    } else {
      _one(el, clazz);
    }
  }
  function toggleClass(el, clazz) {
    var _this = this;
    var _one = function _one(el, clazz) {
      if (el != null && clazz != null && clazz.length > 0) {
        if (el.classList) {
          el.classList.toggle(clazz);
        } else {
          if (_this.hasClass(el, clazz)) {
            _this.removeClass(el, clazz);
          } else {
            _this.addClass(el, clazz);
          }
        }
      }
    };
    if (isNodeList(el)) {
      forEach(el, function (el) {
        return _one(el, clazz);
      });
    } else {
      _one(el, clazz);
    }
  }
  function createElement(tag, style, clazz, atts) {
    return createElementNS(null, tag, style, clazz, atts);
  }
  function createElementNS(ns, tag, style, clazz, atts) {
    var e = ns == null ? document.createElement(tag) : document.createElementNS(ns, tag);
    var i;
    style = style || {};
    for (i in style) {
      e.style[i] = style[i];
    }
    if (clazz) {
      e.className = clazz;
    }
    atts = atts || {};
    for (i in atts) {
      e.setAttribute(i, "" + atts[i]);
    }
    return e;
  }
  function offsetRelativeToRoot(el) {
    var box = el.getBoundingClientRect(),
        body = document.body,
        docElem = document.documentElement,
    scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop,
        scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft,
    clientTop = docElem.clientTop || body.clientTop || 0,
        clientLeft = docElem.clientLeft || body.clientLeft || 0,
    top = box.top + scrollTop - clientTop,
        left = box.left + scrollLeft - clientLeft;
    return {
      x: Math.round(left),
      y: Math.round(top)
    };
  }
  function size(el) {
    return {
      w: el.offsetWidth,
      h: el.offsetHeight
    };
  }

  var svgAttributeMap = {
    "stroke-linejoin": "stroke-linejoin",
    "stroke-dashoffset": "stroke-dashoffset",
    "stroke-linecap": "stroke-linecap"
  };
  var STROKE_DASHARRAY = "stroke-dasharray";
  var DASHSTYLE = "dashstyle";
  var FILL = "fill";
  var STROKE = "stroke";
  var STROKE_WIDTH = "stroke-width";
  var LINE_WIDTH = "strokeWidth";
  var ELEMENT_SVG = "svg";
  var ELEMENT_PATH = "path";
  var ns = {
    svg: "http://www.w3.org/2000/svg"
  };
  function _attr(node, attributes) {
    for (var i in attributes) {
      node.setAttribute(i, "" + attributes[i]);
    }
  }
  function _node(name, attributes) {
    attributes = attributes || {};
    attributes.version = "1.1";
    attributes.xmlns = ns.svg;
    return createElementNS(ns.svg, name, null, null, attributes);
  }
  function _pos(d) {
    return "position:absolute;left:" + d[0] + "px;top:" + d[1] + "px";
  }
  function _applyStyles(parent, node, style) {
    node.setAttribute(FILL, style.fill ? style.fill : NONE$1);
    node.setAttribute(STROKE, style.stroke ? style.stroke : NONE$1);
    if (style.strokeWidth) {
      node.setAttribute(STROKE_WIDTH, style.strokeWidth);
    }
    if (style[DASHSTYLE] && style[LINE_WIDTH] && !style[STROKE_DASHARRAY]) {
      var sep = style[DASHSTYLE].indexOf(",") === -1 ? " " : ",",
          parts = style[DASHSTYLE].split(sep),
          styleToUse = "";
      forEach(parts, function (p) {
        styleToUse += Math.floor(p * style.strokeWidth) + sep;
      });
      node.setAttribute(STROKE_DASHARRAY, styleToUse);
    } else if (style[STROKE_DASHARRAY]) {
      node.setAttribute(STROKE_DASHARRAY, style[STROKE_DASHARRAY]);
    }
    for (var i in svgAttributeMap) {
      if (style[i]) {
        node.setAttribute(svgAttributeMap[i], style[i]);
      }
    }
  }
  function _appendAtIndex(svg, path, idx) {
    if (svg.childNodes.length > idx) {
      svg.insertBefore(path, svg.childNodes[idx]);
    } else {
      svg.appendChild(path);
    }
  }
  function _size(svg, x, y, w, h) {
    svg.style.width = w + "px";
    svg.style.height = h + "px";
    svg.style.left = x + "px";
    svg.style.top = y + "px";
    svg.height = h;
    svg.width = w;
  }

  function compoundEvent(stem, event, subevent) {
    var a = [stem, event];
    if (subevent) {
      a.push(subevent);
    }
    return a.join(":");
  }
  var ATTRIBUTE_CONTAINER = "data-jtk-container";
  var ATTRIBUTE_GROUP_CONTENT = "data-jtk-group-content";
  var ATTRIBUTE_JTK_ENABLED = "data-jtk-enabled";
  var ATTRIBUTE_JTK_SCOPE = "data-jtk-scope";
  var ENDPOINT = "endpoint";
  var ELEMENT = "element";
  var CONNECTION = "connection";
  var ELEMENT_DIV = "div";
  var EVENT_CLICK = "click";
  var EVENT_CONTEXTMENU = "contextmenu";
  var EVENT_DBL_CLICK = "dblclick";
  var EVENT_DBL_TAP = "dbltap";
  var EVENT_FOCUS = "focus";
  var EVENT_MOUSEDOWN = "mousedown";
  var EVENT_MOUSEENTER = "mouseenter";
  var EVENT_MOUSEEXIT = "mouseexit";
  var EVENT_MOUSEMOVE = "mousemove";
  var EVENT_MOUSEUP = "mouseup";
  var EVENT_MOUSEOUT = "mouseout";
  var EVENT_MOUSEOVER = "mouseover";
  var EVENT_TAP = "tap";
  var EVENT_DRAG_MOVE = "drag:move";
  var EVENT_DRAG_STOP = "drag:stop";
  var EVENT_DRAG_START = "drag:start";
  var EVENT_REVERT = "revert";
  var EVENT_CONNECTION_ABORT = "connection:abort";
  var EVENT_CONNECTION_DRAG = "connection:drag";
  var EVENT_ELEMENT_CLICK = compoundEvent(ELEMENT, EVENT_CLICK);
  var EVENT_ELEMENT_DBL_CLICK = compoundEvent(ELEMENT, EVENT_DBL_CLICK);
  var EVENT_ELEMENT_DBL_TAP = compoundEvent(ELEMENT, EVENT_DBL_TAP);
  var EVENT_ELEMENT_MOUSE_OUT = compoundEvent(ELEMENT, EVENT_MOUSEOUT);
  var EVENT_ELEMENT_MOUSE_OVER = compoundEvent(ELEMENT, EVENT_MOUSEOVER);
  var EVENT_ELEMENT_MOUSE_MOVE = compoundEvent(ELEMENT, EVENT_MOUSEMOVE);
  var EVENT_ELEMENT_MOUSE_UP = compoundEvent(ELEMENT, EVENT_MOUSEUP);
  var EVENT_ELEMENT_MOUSE_DOWN = compoundEvent(ELEMENT, EVENT_MOUSEDOWN);
  var EVENT_ELEMENT_CONTEXTMENU = compoundEvent(ELEMENT, EVENT_CONTEXTMENU);
  var EVENT_ELEMENT_TAP = compoundEvent(ELEMENT, EVENT_TAP);
  var EVENT_ENDPOINT_CLICK = compoundEvent(ENDPOINT, EVENT_CLICK);
  var EVENT_ENDPOINT_DBL_CLICK = compoundEvent(ENDPOINT, EVENT_DBL_CLICK);
  compoundEvent(ENDPOINT, EVENT_DBL_TAP);
  var EVENT_ENDPOINT_MOUSEOUT = compoundEvent(ENDPOINT, EVENT_MOUSEOUT);
  var EVENT_ENDPOINT_MOUSEOVER = compoundEvent(ENDPOINT, EVENT_MOUSEOVER);
  var EVENT_ENDPOINT_MOUSEUP = compoundEvent(ENDPOINT, EVENT_MOUSEUP);
  var EVENT_ENDPOINT_MOUSEDOWN = compoundEvent(ENDPOINT, EVENT_MOUSEDOWN);
  compoundEvent(ENDPOINT, EVENT_TAP);
  var EVENT_CONNECTION_CLICK = compoundEvent(CONNECTION, EVENT_CLICK);
  var EVENT_CONNECTION_DBL_CLICK = compoundEvent(CONNECTION, EVENT_DBL_CLICK);
  var EVENT_CONNECTION_DBL_TAP = compoundEvent(CONNECTION, EVENT_DBL_TAP);
  var EVENT_CONNECTION_MOUSEOUT = compoundEvent(CONNECTION, EVENT_MOUSEOUT);
  var EVENT_CONNECTION_MOUSEOVER = compoundEvent(CONNECTION, EVENT_MOUSEOVER);
  var EVENT_CONNECTION_MOUSEUP = compoundEvent(CONNECTION, EVENT_MOUSEUP);
  var EVENT_CONNECTION_MOUSEDOWN = compoundEvent(CONNECTION, EVENT_MOUSEDOWN);
  var EVENT_CONNECTION_CONTEXTMENU = compoundEvent(CONNECTION, EVENT_CONTEXTMENU);
  var EVENT_CONNECTION_TAP = compoundEvent(CONNECTION, EVENT_TAP);
  var PROPERTY_POSITION = "position";
  var SELECTOR_CONNECTOR = cls(CLASS_CONNECTOR);
  var SELECTOR_ENDPOINT = cls(CLASS_ENDPOINT);
  var SELECTOR_GROUP = att(ATTRIBUTE_GROUP);
  var SELECTOR_GROUP_CONTAINER = att(ATTRIBUTE_GROUP_CONTENT);
  var SELECTOR_OVERLAY = cls(CLASS_OVERLAY);

  function _touch(target, pageX, pageY, screenX, screenY, clientX, clientY) {
    return new Touch({
      target: target,
      identifier: uuid(),
      pageX: pageX,
      pageY: pageY,
      screenX: screenX,
      screenY: screenY,
      clientX: clientX || screenX,
      clientY: clientY || screenY
    });
  }
  function _touchList() {
    var list = [];
    list.push.apply(list, arguments);
    list.item = function (index) {
      return this[index];
    };
    return list;
  }
  function _touchAndList(target, pageX, pageY, screenX, screenY, clientX, clientY) {
    return _touchList(_touch(target, pageX, pageY, screenX, screenY, clientX, clientY));
  }
  function matchesSelector(el, selector, ctx) {
    ctx = ctx || el.parentNode;
    var possibles = ctx.querySelectorAll(selector);
    for (var i = 0; i < possibles.length; i++) {
      if (possibles[i] === el) {
        return true;
      }
    }
    return false;
  }
  function _t(e) {
    return e.srcElement || e.target;
  }
  function _pi(e, target, obj, doCompute) {
    if (!doCompute) return {
      path: [target],
      end: 1
    };else if (typeof e.path !== "undefined" && e.path.indexOf) {
      return {
        path: e.path,
        end: e.path.indexOf(obj)
      };
    } else {
      var out = {
        path: [],
        end: -1
      },
          _one = function _one(el) {
        out.path.push(el);
        if (el === obj) {
          out.end = out.path.length - 1;
        } else if (el.parentNode != null) {
          _one(el.parentNode);
        }
      };
      _one(target);
      return out;
    }
  }
  function _d(l, fn) {
    var i = 0,
        j;
    for (i = 0, j = l.length; i < j; i++) {
      if (l[i][0] === fn) {
        break;
      }
    }
    if (i < l.length) {
      l.splice(i, 1);
    }
  }
  var guid = 1;
  function isTouchDevice$1() {
    return "ontouchstart" in document.documentElement || navigator.maxTouchPoints != null && navigator.maxTouchPoints > 0;
  }
  function isMouseDevice() {
    return "onmousedown" in document.documentElement;
  }
  var touchMap = {
    "mousedown": "touchstart",
    "mouseup": "touchend",
    "mousemove": "touchmove"
  };
  var PAGE = "page";
  var SCREEN = "screen";
  var CLIENT = "client";
  function _genLoc(e, prefix) {
    if (e == null) return {
      x: 0,
      y: 0
    };
    var ts = touches(e),
        t = getTouch(ts, 0);
    return {
      x: t[prefix + "X"],
      y: t[prefix + "Y"]
    };
  }
  function pageLocation(e) {
    return _genLoc(e, PAGE);
  }
  function screenLocation(e) {
    return _genLoc(e, SCREEN);
  }
  function clientLocation(e) {
    return _genLoc(e, CLIENT);
  }
  function getTouch(touches, idx) {
    return touches.item ? touches.item(idx) : touches[idx];
  }
  function touches(e) {
    return e.touches && e.touches.length > 0 ? e.touches : e.changedTouches && e.changedTouches.length > 0 ? e.changedTouches : e.targetTouches && e.targetTouches.length > 0 ? e.targetTouches : [e];
  }
  function touchCount(e) {
    return touches(e).length;
  }
  function _bind$1(obj, type, fn, originalFn, options) {
    _store(obj, type, fn);
    originalFn.__tauid = fn.__tauid;
    if (obj.addEventListener) {
      obj.addEventListener(type, fn, false, options);
    } else if (obj.attachEvent) {
      var key = type + fn.__tauid;
      obj["e" + key] = fn;
      obj[key] = function () {
        obj["e" + key] && obj["e" + key](window.event);
      };
      obj.attachEvent("on" + type, obj[key]);
    }
  }
  function _unbind(obj, type, fn) {
    var _this = this;
    if (fn == null) return;
    _each$1(obj, function (_el) {
      _unstore(_el, type, fn);
      if (fn.__tauid != null) {
        if (_el.removeEventListener) {
          _el.removeEventListener(type, fn, false);
          if (isTouchDevice$1() && touchMap[type]) _el.removeEventListener(touchMap[type], fn, false);
        } else if (_this.detachEvent) {
          var key = type + fn.__tauid;
          _el[key] && _el.detachEvent("on" + type, _el[key]);
          _el[key] = null;
          _el["e" + key] = null;
        }
      }
      if (fn.__taTouchProxy) {
        _unbind(obj, fn.__taTouchProxy[1], fn.__taTouchProxy[0]);
      }
    });
  }
  function _each$1(obj, fn) {
    if (obj == null) return;
    var entries = typeof obj === "string" ? document.querySelectorAll(obj) : obj.length != null ? obj : [obj];
    for (var i = 0; i < entries.length; i++) {
      fn(entries[i]);
    }
  }
  function _store(obj, event, fn) {
    var g = guid++;
    obj.__ta = obj.__ta || {};
    obj.__ta[event] = obj.__ta[event] || {};
    obj.__ta[event][g] = fn;
    fn.__tauid = g;
    return g;
  }
  function _unstore(obj, event, fn) {
    obj.__ta && obj.__ta[event] && delete obj.__ta[event][fn.__tauid];
    if (fn.__taExtra) {
      for (var i = 0; i < fn.__taExtra.length; i++) {
        _unbind(obj, fn.__taExtra[i][0], fn.__taExtra[i][1]);
      }
      fn.__taExtra.length = 0;
    }
    fn.__taUnstore && fn.__taUnstore();
  }
  var NOT_SELECTOR_REGEX = /:not\(([^)]+)\)/;
  function _curryChildFilter(children, obj, fn, evt) {
    if (children == null) {
      return fn;
    } else {
      var c = children.split(","),
          pc = [],
          nc = [];
      forEach(c, function (sel) {
        var m = sel.match(NOT_SELECTOR_REGEX);
        if (m != null) {
          nc.push(m[1]);
        } else {
          pc.push(sel);
        }
      });
      if (nc.length > 0 && pc.length === 0) {
        pc.push(WILDCARD);
      }
      var _fn = function _fn(e) {
        _fn.__tauid = fn.__tauid;
        var t = _t(e);
        var done = false;
        var target = t;
        var pathInfo = _pi(e, t, obj, children != null);
        if (pathInfo.end != -1) {
          for (var p = 0; !done && p < pathInfo.end; p++) {
            target = pathInfo.path[p];
            for (var i = 0; i < nc.length; i++) {
              if (matchesSelector(target, nc[i], obj)) {
                return;
              }
            }
            for (var _i = 0; !done && _i < pc.length; _i++) {
              if (matchesSelector(target, pc[_i], obj)) {
                fn.apply(target, [e, target]);
                done = true;
                break;
              }
            }
          }
        }
      };
      registerExtraFunction(fn, evt, _fn);
      return _fn;
    }
  }
  function registerExtraFunction(fn, evt, newFn) {
    fn.__taExtra = fn.__taExtra || [];
    fn.__taExtra.push([evt, newFn]);
  }
  var DefaultHandler = function DefaultHandler(obj, evt, fn, children, options) {
    if (isTouchDevice$1() && touchMap[evt]) {
      var tfn = _curryChildFilter(children, obj, fn, touchMap[evt]);
      _bind$1(obj, touchMap[evt], tfn, fn, options);
    }
    if (evt === EVENT_FOCUS && obj.getAttribute(ATTRIBUTE_TABINDEX) == null) {
      obj.setAttribute(ATTRIBUTE_TABINDEX, "1");
    }
    _bind$1(obj, evt, _curryChildFilter(children, obj, fn, evt), fn, options);
  };
  var _tapProfiles = {
    "tap": {
      touches: 1,
      taps: 1
    },
    "dbltap": {
      touches: 1,
      taps: 2
    },
    "contextmenu": {
      touches: 2,
      taps: 1
    }
  };
  function meeHelper(type, evt, obj, target) {
    for (var i in obj.__tamee[type]) {
      if (obj.__tamee[type].hasOwnProperty(i)) {
        obj.__tamee[type][i].apply(target, [evt]);
      }
    }
  }
  var TapHandler = function () {
    function TapHandler() {
      _classCallCheck$e(this, TapHandler);
    }
    _createClass$e(TapHandler, null, [{
      key: "generate",
      value: function generate(clickThreshold, dblClickThreshold) {
        return function (obj, evt, fn, children) {
          if (evt == EVENT_CONTEXTMENU && isMouseDevice()) DefaultHandler(obj, evt, fn, children);else {
            if (obj.__taTapHandler == null) {
              var tt = obj.__taTapHandler = {
                tap: [],
                dbltap: [],
                down: false,
                taps: 0,
                downSelectors: []
              };
              var down = function down(e) {
                var target = _t(e),
                    pathInfo = _pi(e, target, obj, children != null),
                    finished = false;
                for (var p = 0; p < pathInfo.end; p++) {
                  if (finished) return;
                  target = pathInfo.path[p];
                  for (var i = 0; i < tt.downSelectors.length; i++) {
                    if (tt.downSelectors[i] == null || matchesSelector(target, tt.downSelectors[i], obj)) {
                      tt.down = true;
                      setTimeout(clearSingle, clickThreshold);
                      setTimeout(clearDouble, dblClickThreshold);
                      finished = true;
                      break;
                    }
                  }
                }
              },
                  up = function up(e) {
                if (tt.down) {
                  var target = _t(e),
                      currentTarget,
                      pathInfo;
                  tt.taps++;
                  var tc = touchCount(e);
                  for (var eventId in _tapProfiles) {
                    if (_tapProfiles.hasOwnProperty(eventId)) {
                      var p = _tapProfiles[eventId];
                      if (p.touches === tc && (p.taps === 1 || p.taps === tt.taps)) {
                        for (var i = 0; i < tt[eventId].length; i++) {
                          pathInfo = _pi(e, target, obj, tt[eventId][i][1] != null);
                          for (var pLoop = 0; pLoop < pathInfo.end; pLoop++) {
                            currentTarget = pathInfo.path[pLoop];
                            if (tt[eventId][i][1] == null || matchesSelector(currentTarget, tt[eventId][i][1], obj)) {
                              tt[eventId][i][0].apply(currentTarget, [e, currentTarget]);
                              break;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              },
                  clearSingle = function clearSingle() {
                tt.down = false;
              },
                  clearDouble = function clearDouble() {
                tt.taps = 0;
              };
              obj.__taTapHandler.downHandler = down;
              obj.__taTapHandler.upHandler = up;
              DefaultHandler(obj, EVENT_MOUSEDOWN, down);
              DefaultHandler(obj, EVENT_MOUSEUP, up);
            }
            obj.__taTapHandler.downSelectors.push(children);
            obj.__taTapHandler[evt].push([fn, children]);
            fn.__taUnstore = function () {
              if (obj.__taTapHandler != null) {
                removeWithFunction(obj.__taTapHandler.downSelectors, function (ds) {
                  return ds === children;
                });
                _d(obj.__taTapHandler[evt], fn);
                if (obj.__taTapHandler.downSelectors.length === 0) {
                  _unbind(obj, EVENT_MOUSEDOWN, obj.__taTapHandler.downHandler);
                  _unbind(obj, EVENT_MOUSEUP, obj.__taTapHandler.upHandler);
                  delete obj.__taTapHandler;
                }
              }
            };
          }
        };
      }
    }]);
    return TapHandler;
  }();
  var MouseEnterExitHandler = function () {
    function MouseEnterExitHandler() {
      _classCallCheck$e(this, MouseEnterExitHandler);
    }
    _createClass$e(MouseEnterExitHandler, null, [{
      key: "generate",
      value: function generate() {
        var activeElements = [];
        return function (obj, evt, fn, children) {
          if (!obj.__tamee) {
            obj.__tamee = {
              over: false,
              mouseenter: [],
              mouseexit: []
            };
            var over = function over(e) {
              var t = _t(e);
              if (children == null && t == obj && !obj.__tamee.over || matchesSelector(t, children, obj) && (t.__tamee == null || !t.__tamee.over)) {
                meeHelper(EVENT_MOUSEENTER, e, obj, t);
                t.__tamee = t.__tamee || {};
                t.__tamee.over = true;
                activeElements.push(t);
              }
            },
                out = function out(e) {
              var t = _t(e);
              for (var i = 0; i < activeElements.length; i++) {
                if (t == activeElements[i] && !matchesSelector(e.relatedTarget || e.toElement, "*", t)) {
                  t.__tamee.over = false;
                  activeElements.splice(i, 1);
                  meeHelper(EVENT_MOUSEEXIT, e, obj, t);
                }
              }
            };
            _bind$1(obj, EVENT_MOUSEOVER, _curryChildFilter(children, obj, over, EVENT_MOUSEOVER), over);
            _bind$1(obj, EVENT_MOUSEOUT, _curryChildFilter(children, obj, out, EVENT_MOUSEOUT), out);
          }
          fn.__taUnstore = function () {
            delete obj.__tamee[evt][fn.__tauid];
          };
          _store(obj, evt, fn);
          obj.__tamee[evt][fn.__tauid] = fn;
        };
      }
    }]);
    return MouseEnterExitHandler;
  }();
  var EventManager = function () {
    function EventManager(params) {
      _classCallCheck$e(this, EventManager);
      _defineProperty$d(this, "clickThreshold", void 0);
      _defineProperty$d(this, "dblClickThreshold", void 0);
      _defineProperty$d(this, "tapHandler", void 0);
      _defineProperty$d(this, "mouseEnterExitHandler", void 0);
      params = params || {};
      this.clickThreshold = params.clickThreshold || 250;
      this.dblClickThreshold = params.dblClickThreshold || 450;
      this.mouseEnterExitHandler = MouseEnterExitHandler.generate();
      this.tapHandler = TapHandler.generate(this.clickThreshold, this.dblClickThreshold);
    }
    _createClass$e(EventManager, [{
      key: "_doBind",
      value: function _doBind(el, evt, fn, children, options) {
        if (fn == null) return;
        var jel = el;
        if (evt === EVENT_TAP || evt === EVENT_DBL_TAP || evt === EVENT_CONTEXTMENU) {
          this.tapHandler(jel, evt, fn, children, options);
        } else if (evt === EVENT_MOUSEENTER || evt == EVENT_MOUSEEXIT) this.mouseEnterExitHandler(jel, evt, fn, children, options);else {
          DefaultHandler(jel, evt, fn, children, options);
        }
      }
    }, {
      key: "on",
      value: function on(el, event, children, fn, options) {
        var _c = fn == null ? null : children,
            _f = fn == null ? children : fn;
        this._doBind(el, event, _f, _c, options);
        return this;
      }
    }, {
      key: "off",
      value: function off(el, event, fn) {
        _unbind(el, event, fn);
        return this;
      }
    }, {
      key: "trigger",
      value: function trigger(el, event, originalEvent, payload, detail) {
        var originalIsMouse = isMouseDevice() && (typeof MouseEvent === "undefined" || originalEvent == null || originalEvent.constructor === MouseEvent);
        var eventToBind = isTouchDevice$1() && !isMouseDevice() && touchMap[event] ? touchMap[event] : event,
            bindingAMouseEvent = !(isTouchDevice$1() && !isMouseDevice() && touchMap[event]);
        var pl = pageLocation(originalEvent),
            sl = screenLocation(originalEvent),
            cl = clientLocation(originalEvent);
        _each$1(el, function (_el) {
          var evt;
          originalEvent = originalEvent || {
            screenX: sl.x,
            screenY: sl.y,
            clientX: cl.x,
            clientY: cl.y
          };
          var _decorate = function _decorate(_evt) {
            if (payload) {
              _evt.payload = payload;
            }
          };
          var eventGenerators = {
            "TouchEvent": function TouchEvent(evt) {
              var touchList = _touchAndList(_el, pl.x, pl.y, sl.x, sl.y, cl.x, cl.y),
                  init = evt.initTouchEvent || evt.initEvent;
              init(eventToBind, true, true, window, null, sl.x, sl.y, cl.x, cl.y, false, false, false, false, touchList, touchList, touchList, 1, 0);
            },
            "MouseEvents": function MouseEvents(evt) {
              evt.initMouseEvent(eventToBind, true, true, window, detail == null ? 1 : detail, sl.x, sl.y, cl.x, cl.y, false, false, false, false, 1, _el);
            }
          };
          var ite = !bindingAMouseEvent && !originalIsMouse && isTouchDevice$1() && touchMap[event],
              evtName = ite ? "TouchEvent" : "MouseEvents";
          evt = document.createEvent(evtName);
          eventGenerators[evtName](evt);
          _decorate(evt);
          _el.dispatchEvent(evt);
        });
        return this;
      }
    }]);
    return EventManager;
  }();

  function findDelegateElement(parentElement, childElement, selector) {
    if (matchesSelector$1(childElement, selector, parentElement)) {
      return childElement;
    } else {
      var currentParent = childElement.parentNode;
      while (currentParent != null && currentParent !== parentElement) {
        if (matchesSelector$1(currentParent, selector, parentElement)) {
          return currentParent;
        } else {
          currentParent = currentParent.parentNode;
        }
      }
    }
  }
  function _getPosition(el) {
    return {
      x: el.offsetLeft,
      y: el.offsetTop
    };
  }
  function _getSize(el) {
    return {
      w: el.offsetWidth,
      h: el.offsetHeight
    };
  }
  function _setPosition(el, pos) {
    el.style.left = pos.x + "px";
    el.style.top = pos.y + "px";
  }
  function _assignId(obj) {
    if (typeof obj === "function") {
      obj._katavorioId = uuid();
      return obj._katavorioId;
    } else {
      return obj;
    }
  }
  function isInsideParent(instance, _el, pos) {
    var p = _el.parentNode,
        s = instance.getSize(p),
        ss = instance.getSize(_el),
        leftEdge = pos.x,
        rightEdge = leftEdge + ss.w,
        topEdge = pos.y,
        bottomEdge = topEdge + ss.h;
    return rightEdge > 0 && leftEdge < s.w && bottomEdge > 0 && topEdge < s.h;
  }
  function findMatchingSelector(availableSelectors, parentElement, childElement) {
    var el = null;
    var draggableId = parentElement.getAttribute("katavorio-draggable"),
        prefix = draggableId != null ? "[katavorio-draggable='" + draggableId + "'] " : "";
    for (var i = 0; i < availableSelectors.length; i++) {
      el = findDelegateElement(parentElement, childElement, prefix + availableSelectors[i].selector);
      if (el != null) {
        if (availableSelectors[i].filter) {
          var matches = matchesSelector$1(childElement, availableSelectors[i].filter, el),
              exclude = availableSelectors[i].filterExclude === true;
          if (exclude && !matches || matches) {
            return null;
          }
        }
        return [availableSelectors[i], el];
      }
    }
    return null;
  }
  var EVENT_START = "start";
  var EVENT_BEFORE_START = "beforeStart";
  var EVENT_DRAG = "drag";
  var EVENT_DROP = "drop";
  var EVENT_OVER = "over";
  var EVENT_OUT = "out";
  var EVENT_STOP = "stop";
  var ATTRIBUTE_DRAGGABLE = "katavorio-draggable";
  var CLASS_DRAGGABLE$1 = ATTRIBUTE_DRAGGABLE;
  var DEFAULT_GRID_X = 10;
  var DEFAULT_GRID_Y = 10;
  var TRUE = function TRUE() {
    return true;
  };
  var FALSE = function FALSE() {
    return false;
  };
  var _classes = {
    delegatedDraggable: "katavorio-delegated-draggable",
    draggable: CLASS_DRAGGABLE$1,
    drag: "katavorio-drag",
    selected: "katavorio-drag-selected",
    noSelect: "katavorio-drag-no-select",
    ghostProxy: "katavorio-ghost-proxy",
    clonedDrag: "katavorio-clone-drag"
  };
  var _events = [EVENT_STOP, EVENT_START, EVENT_DRAG, EVENT_DROP, EVENT_OVER, EVENT_OUT, EVENT_BEFORE_START];
  var _devNull = function _devNull() {};
  var _each = function _each(obj, fn) {
    if (obj == null) return;
    obj = !isString(obj) && obj.tagName == null && obj.length != null ? obj : [obj];
    for (var i = 0; i < obj.length; i++) {
      fn.apply(obj[i], [obj[i]]);
    }
  };
  var _inputFilter = function _inputFilter(e, el, collicat) {
    var t = e.srcElement || e.target;
    return !matchesSelector$1(t, collicat.getInputFilterSelector(), el);
  };
  var Base$1 = function () {
    function Base(el, k) {
      _classCallCheck$e(this, Base);
      this.el = el;
      this.k = k;
      _defineProperty$d(this, "_class", void 0);
      _defineProperty$d(this, "uuid", uuid());
      _defineProperty$d(this, "enabled", true);
      _defineProperty$d(this, "scopes", []);
    }
    _createClass$e(Base, [{
      key: "setEnabled",
      value: function setEnabled(e) {
        this.enabled = e;
      }
    }, {
      key: "isEnabled",
      value: function isEnabled() {
        return this.enabled;
      }
    }, {
      key: "toggleEnabled",
      value: function toggleEnabled() {
        this.enabled = !this.enabled;
      }
    }, {
      key: "addScope",
      value: function addScope(scopes) {
        var m = {};
        _each(this.scopes, function (s) {
          m[s] = true;
        });
        _each(scopes ? scopes.split(/\s+/) : [], function (s) {
          m[s] = true;
        });
        this.scopes.length = 0;
        for (var i in m) {
          this.scopes.push(i);
        }
      }
    }, {
      key: "removeScope",
      value: function removeScope(scopes) {
        var m = {};
        _each(this.scopes, function (s) {
          m[s] = true;
        });
        _each(scopes ? scopes.split(/\s+/) : [], function (s) {
          delete m[s];
        });
        this.scopes.length = 0;
        for (var i in m) {
          this.scopes.push(i);
        }
      }
    }, {
      key: "toggleScope",
      value: function toggleScope(scopes) {
        var m = {};
        _each(this.scopes, function (s) {
          m[s] = true;
        });
        _each(scopes ? scopes.split(/\s+/) : [], function (s) {
          if (m[s]) delete m[s];else m[s] = true;
        });
        this.scopes.length = 0;
        for (var i in m) {
          this.scopes.push(i);
        }
      }
    }]);
    return Base;
  }();
  function getConstrainingRectangle(el) {
    return {
      w: el.parentNode.offsetWidth + el.parentNode.scrollLeft,
      h: el.parentNode.offsetHeight + el.parentNode.scrollTop
    };
  }
  var ContainmentType;
  (function (ContainmentType) {
    ContainmentType["notNegative"] = "notNegative";
    ContainmentType["parent"] = "parent";
    ContainmentType["parentEnclosed"] = "parentEnclosed";
  })(ContainmentType || (ContainmentType = {}));
  var Drag = function (_Base) {
    _inherits$9(Drag, _Base);
    var _super = _createSuper$9(Drag);
    function Drag(el, params, k) {
      var _this;
      _classCallCheck$e(this, Drag);
      _this = _super.call(this, el, k);
      _defineProperty$d(_assertThisInitialized$9(_this), "_class", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "rightButtonCanDrag", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "consumeStartEvent", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "clone", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "scroll", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "trackScroll", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "_downAt", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "_posAtDown", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "_pagePosAtDown", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "_pageDelta", {
        x: 0,
        y: 0
      });
      _defineProperty$d(_assertThisInitialized$9(_this), "_moving", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "_lastPosition", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "_lastScrollValues", {
        x: 0,
        y: 0
      });
      _defineProperty$d(_assertThisInitialized$9(_this), "_initialScroll", {
        x: 0,
        y: 0
      });
      _defineProperty$d(_assertThisInitialized$9(_this), "_size", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "_currentParentPosition", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "_ghostParentPosition", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "_dragEl", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "_multipleDrop", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "_ghostProxyOffsets", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "_ghostDx", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "_ghostDy", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "_isConstrained", false);
      _defineProperty$d(_assertThisInitialized$9(_this), "_ghostProxyParent", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "_useGhostProxy", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "_ghostProxyFunction", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "_activeSelectorParams", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "_availableSelectors", []);
      _defineProperty$d(_assertThisInitialized$9(_this), "_canDrag", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "_consumeFilteredEvents", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "_parent", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "_ignoreZoom", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "_filters", {});
      _defineProperty$d(_assertThisInitialized$9(_this), "_constrainRect", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "_elementToDrag", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "downListener", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "moveListener", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "upListener", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "scrollTracker", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "listeners", {
        "start": [],
        "drag": [],
        "stop": [],
        "over": [],
        "out": [],
        "beforeStart": [],
        "revert": []
      });
      _this._class = _this.k.css.draggable;
      addClass(_this.el, _this._class);
      _this.downListener = _this._downListener.bind(_assertThisInitialized$9(_this));
      _this.upListener = _this._upListener.bind(_assertThisInitialized$9(_this));
      _this.moveListener = _this._moveListener.bind(_assertThisInitialized$9(_this));
      _this.rightButtonCanDrag = params.rightButtonCanDrag === true;
      _this.consumeStartEvent = params.consumeStartEvent !== false;
      _this._dragEl = _this.el;
      _this.clone = params.clone === true;
      _this.scroll = params.scroll === true;
      _this.trackScroll = params.trackScroll !== false;
      _this._multipleDrop = params.multipleDrop !== false;
      _this._canDrag = params.canDrag || TRUE;
      _this._consumeFilteredEvents = params.consumeFilteredEvents;
      _this._parent = params.parent;
      _this._ignoreZoom = params.ignoreZoom === true;
      _this._ghostProxyParent = params.ghostProxyParent;
      if (_this.trackScroll) {
        _this.scrollTracker = _this._trackScroll.bind(_assertThisInitialized$9(_this));
        document.addEventListener("scroll", _this.scrollTracker);
      }
      if (params.ghostProxy === true) {
        _this._useGhostProxy = TRUE;
      } else {
        if (params.ghostProxy && typeof params.ghostProxy === "function") {
          _this._useGhostProxy = params.ghostProxy;
        } else {
          _this._useGhostProxy = function (container, dragEl) {
            if (_this._activeSelectorParams && _this._activeSelectorParams.useGhostProxy) {
              return _this._activeSelectorParams.useGhostProxy(container, dragEl);
            } else {
              return false;
            }
          };
        }
      }
      if (params.makeGhostProxy) {
        _this._ghostProxyFunction = params.makeGhostProxy;
      } else {
        _this._ghostProxyFunction = function (el) {
          if (_this._activeSelectorParams && _this._activeSelectorParams.makeGhostProxy) {
            return _this._activeSelectorParams.makeGhostProxy(el);
          } else {
            return el.cloneNode(true);
          }
        };
      }
      if (params.selector) {
        var draggableId = _this.el.getAttribute(ATTRIBUTE_DRAGGABLE);
        if (draggableId == null) {
          draggableId = "" + new Date().getTime();
          _this.el.setAttribute("katavorio-draggable", draggableId);
        }
        _this._availableSelectors.push(params);
      }
      _this.k.eventManager.on(_this.el, EVENT_MOUSEDOWN, _this.downListener);
      return _this;
    }
    _createClass$e(Drag, [{
      key: "_trackScroll",
      value: function _trackScroll(e) {
        if (this._moving) {
          var currentScrollValues = {
            x: document.documentElement.scrollLeft,
            y: document.documentElement.scrollTop
          },
              dsx = currentScrollValues.x - this._lastScrollValues.x,
              dsy = currentScrollValues.y - this._lastScrollValues.y,
              _pos = {
            x: dsx + this._lastPosition.x,
            y: dsy + this._lastPosition.y
          },
          dx = _pos.x - this._downAt.x,
              dy = _pos.y - this._downAt.y,
              _z = this._ignoreZoom ? 1 : this.k.getZoom();
          if (this._dragEl && this._dragEl.parentNode) {
            dx += this._dragEl.parentNode.scrollLeft - this._initialScroll.x;
            dy += this._dragEl.parentNode.scrollTop - this._initialScroll.y;
          }
          dx /= _z;
          dy /= _z;
          this.moveBy(dx, dy, e);
          this._lastPosition = _pos;
          this._lastScrollValues = currentScrollValues;
        }
      }
    }, {
      key: "on",
      value: function on(evt, fn) {
        if (this.listeners[evt]) {
          this.listeners[evt].push(fn);
        }
      }
    }, {
      key: "off",
      value: function off(evt, fn) {
        if (this.listeners[evt]) {
          var l = [];
          for (var i = 0; i < this.listeners[evt].length; i++) {
            if (this.listeners[evt][i] !== fn) {
              l.push(this.listeners[evt][i]);
            }
          }
          this.listeners[evt] = l;
        }
      }
    }, {
      key: "_upListener",
      value: function _upListener(e) {
        if (this._downAt) {
          this._downAt = null;
          this.k.eventManager.off(document, EVENT_MOUSEMOVE, this.moveListener);
          this.k.eventManager.off(document, EVENT_MOUSEUP, this.upListener);
          removeClass(document.body, _classes.noSelect);
          this.unmark(e);
          this.stop(e);
          this._moving = false;
          if (this.clone) {
            this._dragEl && this._dragEl.parentNode && this._dragEl.parentNode.removeChild(this._dragEl);
            this._dragEl = null;
          } else {
            if (this._activeSelectorParams && this._activeSelectorParams.revertFunction) {
              if (this._activeSelectorParams.revertFunction(this._dragEl, _getPosition(this._dragEl)) === true) {
                _setPosition(this._dragEl, this._posAtDown);
                this._dispatch(EVENT_REVERT, this._dragEl);
              }
            }
          }
        }
      }
    }, {
      key: "_downListener",
      value: function _downListener(e) {
        if (e.defaultPrevented) {
          return;
        }
        var isNotRightClick = this.rightButtonCanDrag || e.which !== 3 && e.button !== 2;
        if (isNotRightClick && this.isEnabled() && this._canDrag()) {
          var _f = this._testFilter(e) && _inputFilter(e, this.el, this.k);
          if (_f) {
            this._activeSelectorParams = null;
            this._elementToDrag = null;
            if (this._availableSelectors.length === 0) {
              console.log("JSPLUMB: no available drag selectors");
            }
            var eventTarget = e.target || e.srcElement;
            var match = findMatchingSelector(this._availableSelectors, this.el, eventTarget);
            if (match != null) {
              this._activeSelectorParams = match[0];
              this._elementToDrag = match[1];
            }
            if (this._activeSelectorParams == null || this._elementToDrag == null) {
              return;
            }
            var initial = this._activeSelectorParams.dragInit ? this._activeSelectorParams.dragInit(this._elementToDrag) : null;
            if (initial != null) {
              this._elementToDrag = initial;
            }
            if (this.clone) {
              this._dragEl = this._elementToDrag.cloneNode(true);
              addClass(this._dragEl, _classes.clonedDrag);
              this._dragEl.setAttribute("id", null);
              this._dragEl.style.position = "absolute";
              if (this._parent != null) {
                var _p2 = _getPosition(this.el);
                this._dragEl.style.left = _p2.x + "px";
                this._dragEl.style.top = _p2.y + "px";
                this._parent.appendChild(this._dragEl);
              } else {
                var b = offsetRelativeToRoot(this._elementToDrag);
                this._dragEl.style.left = b.x + "px";
                this._dragEl.style.top = b.y + "px";
                document.body.appendChild(this._dragEl);
              }
            } else {
              this._dragEl = this._elementToDrag;
            }
            if (this.consumeStartEvent) {
              consume(e);
            }
            this._downAt = pageLocation(e);
            if (this._dragEl && this._dragEl.parentNode) {
              this._initialScroll = {
                x: this._dragEl.parentNode.scrollLeft,
                y: this._dragEl.parentNode.scrollTop
              };
            }
            this._posAtDown = _getPosition(this._dragEl);
            this._pagePosAtDown = offsetRelativeToRoot(this._dragEl);
            this._pageDelta = {
              x: this._pagePosAtDown.x - this._posAtDown.x,
              y: this._pagePosAtDown.y - this._posAtDown.y
            };
            this._size = _getSize(this._dragEl);
            this.k.eventManager.on(document, EVENT_MOUSEMOVE, this.moveListener);
            this.k.eventManager.on(document, EVENT_MOUSEUP, this.upListener);
            addClass(document.body, _classes.noSelect);
            this._dispatch(EVENT_BEFORE_START, {
              el: this.el,
              pos: this._posAtDown,
              e: e,
              drag: this,
              size: this._size
            });
          } else if (this._consumeFilteredEvents) {
            consume(e);
          }
        }
      }
    }, {
      key: "_moveListener",
      value: function _moveListener(e) {
        if (this._downAt) {
          if (!this._moving) {
            var dispatchResult = this._dispatch(EVENT_START, {
              el: this.el,
              pos: this._posAtDown,
              e: e,
              drag: this,
              size: this._size
            });
            if (dispatchResult !== false) {
              if (!this._downAt) {
                return;
              }
              this.mark(dispatchResult);
              this._moving = true;
            } else {
              this.abort();
            }
          }
          if (this._downAt) {
            var _pos2 = pageLocation(e),
                dx = _pos2.x - this._downAt.x,
                dy = _pos2.y - this._downAt.y,
                _z2 = this._ignoreZoom ? 1 : this.k.getZoom();
            this._lastPosition = {
              x: _pos2.x,
              y: _pos2.y
            };
            this._lastScrollValues = {
              x: document.documentElement.scrollLeft,
              y: document.documentElement.scrollTop
            };
            if (this._dragEl && this._dragEl.parentNode) {
              dx += this._dragEl.parentNode.scrollLeft - this._initialScroll.x;
              dy += this._dragEl.parentNode.scrollTop - this._initialScroll.y;
            }
            dx /= _z2;
            dy /= _z2;
            this.moveBy(dx, dy, e);
          }
        }
      }
    }, {
      key: "mark",
      value: function mark(payload) {
        this._posAtDown = _getPosition(this._dragEl);
        this._pagePosAtDown = offsetRelativeToRoot(this._dragEl);
        this._pageDelta = {
          x: this._pagePosAtDown.x - this._posAtDown.x,
          y: this._pagePosAtDown.y - this._posAtDown.y
        };
        this._size = _getSize(this._dragEl);
        addClass(this._dragEl, this.k.css.drag);
        this._constrainRect = getConstrainingRectangle(this._dragEl);
        this._ghostDx = 0;
        this._ghostDy = 0;
      }
    }, {
      key: "unmark",
      value: function unmark(e) {
        if (this._isConstrained && this._useGhostProxy(this._elementToDrag, this._dragEl)) {
          this._ghostProxyOffsets = {
            x: this._dragEl.offsetLeft - this._ghostDx,
            y: this._dragEl.offsetTop - this._ghostDy
          };
          this._dragEl.parentNode.removeChild(this._dragEl);
          this._dragEl = this._elementToDrag;
        } else {
          this._ghostProxyOffsets = null;
        }
        removeClass(this._dragEl, this.k.css.drag);
        this._isConstrained = false;
      }
    }, {
      key: "moveBy",
      value: function moveBy(dx, dy, e) {
        var desiredLoc = this.toGrid({
          x: this._posAtDown.x + dx,
          y: this._posAtDown.y + dy
        }),
            cPos = this._doConstrain(desiredLoc, this._dragEl, this._constrainRect, this._size);
        if (this._useGhostProxy(this.el, this._dragEl)) {
          if (desiredLoc.x !== cPos.x || desiredLoc.y !== cPos.y) {
            if (!this._isConstrained) {
              var gp = this._ghostProxyFunction(this._elementToDrag);
              addClass(gp, _classes.ghostProxy);
              if (this._ghostProxyParent) {
                this._ghostProxyParent.appendChild(gp);
                this._currentParentPosition = offsetRelativeToRoot(this._elementToDrag.parentNode);
                this._ghostParentPosition = offsetRelativeToRoot(this._ghostProxyParent);
                this._ghostDx = this._currentParentPosition.x - this._ghostParentPosition.x;
                this._ghostDy = this._currentParentPosition.y - this._ghostParentPosition.y;
              } else {
                this._elementToDrag.parentNode.appendChild(gp);
              }
              this._dragEl = gp;
              this._isConstrained = true;
            }
            cPos = desiredLoc;
          } else {
            if (this._isConstrained) {
              this._dragEl.parentNode.removeChild(this._dragEl);
              this._dragEl = this._elementToDrag;
              this._isConstrained = false;
              this._currentParentPosition = null;
              this._ghostParentPosition = null;
              this._ghostDx = 0;
              this._ghostDy = 0;
            }
          }
        }
        _setPosition(this._dragEl, {
          x: cPos.x + this._ghostDx,
          y: cPos.y + this._ghostDy
        });
        this._dispatch(EVENT_DRAG, {
          el: this.el,
          pos: cPos,
          e: e,
          drag: this,
          size: this._size,
          originalPos: this._posAtDown
        });
      }
    }, {
      key: "abort",
      value: function abort() {
        if (this._downAt != null) {
          this._upListener();
        }
      }
    }, {
      key: "getDragElement",
      value: function getDragElement(retrieveOriginalElement) {
        return retrieveOriginalElement ? this._elementToDrag || this.el : this._dragEl || this.el;
      }
    }, {
      key: "stop",
      value: function stop(e, force) {
        if (force || this._moving) {
          var positions = [],
              dPos = _getPosition(this._dragEl);
          positions.push([this._dragEl, dPos, this, this._size]);
          this._dispatch(EVENT_STOP, {
            el: this._dragEl,
            pos: this._ghostProxyOffsets || dPos,
            finalPos: dPos,
            e: e,
            drag: this,
            selection: positions,
            size: this._size,
            originalPos: {
              x: this._posAtDown.x,
              y: this._posAtDown.y
            }
          });
        } else if (!this._moving) {
          this._activeSelectorParams.dragAbort ? this._activeSelectorParams.dragAbort(this._elementToDrag) : null;
        }
      }
    }, {
      key: "_dispatch",
      value: function _dispatch(evt, value) {
        var result = null;
        if (this._activeSelectorParams && this._activeSelectorParams[evt]) {
          result = this._activeSelectorParams[evt](value);
        } else if (this.listeners[evt]) {
          for (var i = 0; i < this.listeners[evt].length; i++) {
            try {
              var v = this.listeners[evt][i](value);
              if (v != null) {
                result = v;
              }
            } catch (e) {}
          }
        }
        return result;
      }
    }, {
      key: "resolveGrid",
      value: function resolveGrid() {
        var out = {
          grid: null,
          thresholdX: DEFAULT_GRID_X / 2,
          thresholdY: DEFAULT_GRID_Y / 2
        };
        if (this._activeSelectorParams != null && this._activeSelectorParams.grid != null) {
          out.grid = this._activeSelectorParams.grid;
          if (this._activeSelectorParams.snapThreshold != null) {
            out.thresholdX = this._activeSelectorParams.snapThreshold;
            out.thresholdY = this._activeSelectorParams.snapThreshold;
          }
        }
        return out;
      }
    }, {
      key: "toGrid",
      value: function toGrid(pos) {
        var _this$resolveGrid = this.resolveGrid(),
            grid = _this$resolveGrid.grid,
            thresholdX = _this$resolveGrid.thresholdX,
            thresholdY = _this$resolveGrid.thresholdY;
        if (grid == null) {
          return pos;
        } else {
          var tx = grid ? grid.w / 2 : thresholdX,
              ty = grid ? grid.h / 2 : thresholdY;
          return snapToGrid(pos, grid, tx, ty);
        }
      }
    }, {
      key: "setUseGhostProxy",
      value: function setUseGhostProxy(val) {
        this._useGhostProxy = val ? TRUE : FALSE;
      }
    }, {
      key: "_doConstrain",
      value: function _doConstrain(pos, dragEl, _constrainRect, _size) {
        if (this._activeSelectorParams != null && this._activeSelectorParams.constrainFunction && typeof this._activeSelectorParams.constrainFunction === "function") {
          return this._activeSelectorParams.constrainFunction(pos, dragEl, _constrainRect, _size);
        } else {
          return pos;
        }
      }
    }, {
      key: "_testFilter",
      value: function _testFilter(e) {
        for (var key in this._filters) {
          var f = this._filters[key];
          var rv = f[0](e);
          if (f[1]) {
            rv = !rv;
          }
          if (!rv) {
            return false;
          }
        }
        return true;
      }
    }, {
      key: "addFilter",
      value: function addFilter(f, _exclude) {
        var _this2 = this;
        if (f) {
          var key = _assignId(f);
          this._filters[key] = [function (e) {
            var t = e.srcElement || e.target;
            var m;
            if (isString(f)) {
              m = matchesSelector$1(t, f, _this2.el);
            } else if (typeof f === "function") {
              m = f(e, _this2.el);
            }
            return m;
          }, _exclude !== false];
        }
      }
    }, {
      key: "removeFilter",
      value: function removeFilter(f) {
        var key = typeof f === "function" ? f._katavorioId : f;
        delete this._filters[key];
      }
    }, {
      key: "clearAllFilters",
      value: function clearAllFilters() {
        this._filters = {};
      }
    }, {
      key: "addSelector",
      value: function addSelector(params, atStart) {
        if (params.selector) {
          if (atStart) {
            this._availableSelectors.unshift(params);
          } else {
            this._availableSelectors.push(params);
          }
        }
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.k.eventManager.off(this.el, EVENT_MOUSEDOWN, this.downListener);
        this.k.eventManager.off(document, EVENT_MOUSEMOVE, this.moveListener);
        this.k.eventManager.off(document, EVENT_MOUSEUP, this.upListener);
        this.downListener = null;
        this.upListener = null;
        this.moveListener = null;
        if (this.scrollTracker != null) {
          document.removeEventListener("scroll", this.scrollTracker);
        }
      }
    }]);
    return Drag;
  }(Base$1);
  var DEFAULT_INPUTS = ["input", "textarea", "select", "button", "option"];
  var DEFAULT_INPUT_FILTER_SELECTOR = DEFAULT_INPUTS.join(",");
  var Collicat = function () {
    function Collicat(options) {
      _classCallCheck$e(this, Collicat);
      _defineProperty$d(this, "eventManager", void 0);
      _defineProperty$d(this, "zoom", 1);
      _defineProperty$d(this, "css", {});
      _defineProperty$d(this, "inputFilterSelector", void 0);
      options = options || {};
      this.inputFilterSelector = options.inputFilterSelector || DEFAULT_INPUT_FILTER_SELECTOR;
      this.eventManager = new EventManager();
      this.zoom = options.zoom || 1;
      var _c = options.css || {};
      extend(this.css, _c);
    }
    _createClass$e(Collicat, [{
      key: "getZoom",
      value: function getZoom() {
        return this.zoom;
      }
    }, {
      key: "setZoom",
      value: function setZoom(z) {
        this.zoom = z;
      }
    }, {
      key: "_prepareParams",
      value: function _prepareParams(p) {
        p = p || {};
        var _p = {
          events: {}
        },
            i;
        for (i in p) {
          _p[i] = p[i];
        }
        for (i = 0; i < _events.length; i++) {
          _p.events[_events[i]] = p[_events[i]] || _devNull;
        }
        return _p;
      }
    }, {
      key: "getInputFilterSelector",
      value: function getInputFilterSelector() {
        return this.inputFilterSelector;
      }
    }, {
      key: "setInputFilterSelector",
      value: function setInputFilterSelector(selector) {
        this.inputFilterSelector = selector;
        return this;
      }
    }, {
      key: "draggable",
      value: function draggable(el, params) {
        if (el._katavorioDrag == null) {
          var _p3 = this._prepareParams(params);
          var d = new Drag(el, _p3, this);
          addClass(el, _classes.delegatedDraggable);
          el._katavorioDrag = d;
          return d;
        } else {
          return el._katavorioDrag;
        }
      }
    }, {
      key: "destroyDraggable",
      value: function destroyDraggable(el) {
        if (el._katavorioDrag) {
          el._katavorioDrag.destroy();
          delete el._katavorioDrag;
        }
      }
    }]);
    return Collicat;
  }();

  var CLASS_DRAG_SELECTED = "jtk-drag-selected";
  var DragSelection = function () {
    function DragSelection(instance) {
      _classCallCheck$e(this, DragSelection);
      this.instance = instance;
      _defineProperty$d(this, "_dragSelection", []);
      _defineProperty$d(this, "_dragSizes", new Map());
      _defineProperty$d(this, "_dragElements", new Map());
      _defineProperty$d(this, "_dragElementStartPositions", new Map());
      _defineProperty$d(this, "_dragElementPositions", new Map());
      _defineProperty$d(this, "__activeSet", void 0);
    }
    _createClass$e(DragSelection, [{
      key: "_activeSet",
      get: function get() {
        if (this.__activeSet == null) {
          return this._dragSelection;
        } else {
          return this.__activeSet;
        }
      }
    }, {
      key: "length",
      get: function get() {
        return this._dragSelection.length;
      }
    }, {
      key: "filterActiveSet",
      value: function filterActiveSet(fn) {
        var _this = this;
        this.__activeSet = [];
        forEach(this._dragSelection, function (p) {
          if (fn(p)) {
            _this.__activeSet.push(p);
          }
        });
      }
    }, {
      key: "clear",
      value: function clear() {
        var _this2 = this;
        this.reset();
        forEach(this._dragSelection, function (p) {
          return _this2.instance.removeClass(p.jel, CLASS_DRAG_SELECTED);
        });
        this._dragSelection.length = 0;
      }
    }, {
      key: "reset",
      value: function reset() {
        this._dragElementStartPositions.clear();
        this._dragElementPositions.clear();
        this._dragSizes.clear();
        this._dragElements.clear();
        this.__activeSet = null;
      }
    }, {
      key: "initialisePositions",
      value: function initialisePositions() {
        var _this3 = this;
        forEach(this._activeSet, function (p) {
          var off = {
            x: parseInt("" + p.jel.offsetLeft, 10),
            y: parseInt("" + p.jel.offsetTop, 10)
          };
          _this3._dragElementStartPositions.set(p.id, off);
          _this3._dragElementPositions.set(p.id, off);
          _this3._dragSizes.set(p.id, _this3.instance.getSize(p.jel));
        });
      }
    }, {
      key: "updatePositions",
      value: function updatePositions(currentPosition, originalPosition, callback) {
        var _this4 = this;
        var dx = currentPosition.x - originalPosition.x,
            dy = currentPosition.y - originalPosition.y;
        forEach(this._activeSet, function (p) {
          var op = _this4._dragElementStartPositions.get(p.id);
          if (op) {
            var x = op.x + dx,
                y = op.y + dy;
            var _s = _this4._dragSizes.get(p.id);
            var _b = {
              x: x,
              y: y,
              w: _s.w,
              h: _s.h
            };
            if (p.jel._jsPlumbParentGroup && p.jel._jsPlumbParentGroup.constrain) {
              var constrainRect = {
                w: p.jel.parentNode.offsetWidth + p.jel.parentNode.scrollLeft,
                h: p.jel.parentNode.offsetHeight + p.jel.parentNode.scrollTop
              };
              _b.x = Math.max(_b.x, 0);
              _b.y = Math.max(_b.y, 0);
              _b.x = Math.min(_b.x, constrainRect.w - _s.w);
              _b.y = Math.min(_b.y, constrainRect.h - _s.h);
            }
            _this4._dragElementPositions.set(p.id, {
              x: x,
              y: y
            });
            p.jel.style.left = _b.x + "px";
            p.jel.style.top = _b.y + "px";
            callback(p.jel, p.id, _s, _b);
          }
        });
      }
    }, {
      key: "each",
      value: function each(f) {
        var _this5 = this;
        forEach(this._activeSet, function (p) {
          var s = _this5._dragSizes.get(p.id);
          var o = _this5._dragElementPositions.get(p.id);
          var orig = _this5._dragElementStartPositions.get(p.id);
          f(p.jel, p.id, o, s, orig);
        });
      }
    }, {
      key: "add",
      value: function add(el, id) {
        var jel = el;
        id = id || this.instance.getId(jel);
        var idx = findWithFunction(this._dragSelection, function (p) {
          return p.id === id;
        });
        if (idx === -1) {
          this.instance.addClass(el, CLASS_DRAG_SELECTED);
          this._dragSelection.push({
            id: id,
            jel: jel
          });
        }
      }
    }, {
      key: "remove",
      value: function remove(el) {
        var _this6 = this;
        var jel = el;
        this._dragSelection = this._dragSelection.filter(function (p) {
          var out = p.jel !== jel;
          if (!out) {
            _this6.instance.removeClass(p.jel, CLASS_DRAG_SELECTED);
          }
          return out;
        });
      }
    }, {
      key: "toggle",
      value: function toggle(el) {
        var jel = el;
        var idx = findWithFunction(this._dragSelection, function (p) {
          return p.jel === jel;
        });
        if (idx !== -1) {
          this.remove(jel);
        } else {
          this.add(el);
        }
      }
    }]);
    return DragSelection;
  }();

  var CLASS_DELEGATED_DRAGGABLE = "jtk-delegated-draggable";
  var CLASS_DRAGGABLE = "jtk-draggable";
  var CLASS_DRAG_CONTAINER = "jtk-drag";
  var CLASS_GHOST_PROXY = "jtk-ghost-proxy";
  var CLASS_DRAG_ACTIVE = "jtk-drag-active";
  var CLASS_DRAGGED = "jtk-dragged";
  var CLASS_DRAG_HOVER = "jtk-drag-hover";
  var DragManager = function () {
    function DragManager(instance, dragSelection, options) {
      var _this = this;
      _classCallCheck$e(this, DragManager);
      this.instance = instance;
      this.dragSelection = dragSelection;
      _defineProperty$d(this, "collicat", void 0);
      _defineProperty$d(this, "drag", void 0);
      _defineProperty$d(this, "_draggables", {});
      _defineProperty$d(this, "_dlist", []);
      _defineProperty$d(this, "_elementsWithEndpoints", {});
      _defineProperty$d(this, "_draggablesForElements", {});
      _defineProperty$d(this, "handlers", []);
      _defineProperty$d(this, "_trackScroll", void 0);
      _defineProperty$d(this, "_filtersToAdd", []);
      this.collicat = new Collicat({
        zoom: this.instance.currentZoom,
        css: {
          noSelect: this.instance.dragSelectClass,
          delegatedDraggable: CLASS_DELEGATED_DRAGGABLE,
          draggable: CLASS_DRAGGABLE,
          drag: CLASS_DRAG_CONTAINER,
          selected: CLASS_DRAG_SELECTED,
          active: CLASS_DRAG_ACTIVE,
          hover: CLASS_DRAG_HOVER,
          ghostProxy: CLASS_GHOST_PROXY
        }
      });
      this.instance.bind(EVENT_ZOOM, function (z) {
        _this.collicat.setZoom(z);
      });
      options = options || {};
      this._trackScroll = options.trackScroll !== false;
    }
    _createClass$e(DragManager, [{
      key: "addHandler",
      value: function addHandler(handler, dragOptions) {
        var _this2 = this;
        var o = extend({
          selector: handler.selector
        }, dragOptions || {});
        o.start = wrap(o.start, function (p) {
          return handler.onStart(p);
        }, false);
        o.drag = wrap(o.drag, function (p) {
          return handler.onDrag(p);
        });
        o.stop = wrap(o.stop, function (p) {
          return handler.onStop(p);
        });
        var handlerBeforeStart = (handler.onBeforeStart || function (p) {}).bind(handler);
        o.beforeStart = wrap(o.beforeStart, function (p) {
          return handlerBeforeStart(p);
        });
        o.dragInit = function (el) {
          return handler.onDragInit(el);
        };
        o.dragAbort = function (el) {
          return handler.onDragAbort(el);
        };
        if (handler.useGhostProxy) {
          o.useGhostProxy = handler.useGhostProxy;
          o.makeGhostProxy = handler.makeGhostProxy;
        }
        if (o.constrainFunction == null && o.containment != null) {
          switch (o.containment) {
            case ContainmentType.notNegative:
              {
                o.constrainFunction = function (pos, dragEl, _constrainRect, _size) {
                  return {
                    x: Math.max(0, Math.min(pos.x)),
                    y: Math.max(0, Math.min(pos.y))
                  };
                };
                break;
              }
            case ContainmentType.parent:
              {
                var padding = o.containmentPadding || 5;
                o.constrainFunction = function (pos, dragEl, _constrainRect, _size) {
                  var x = pos.x < 0 ? 0 : pos.x > _constrainRect.w - padding ? _constrainRect.w - padding : pos.x;
                  var y = pos.y < 0 ? 0 : pos.y > _constrainRect.h - padding ? _constrainRect.h - padding : pos.y;
                  return {
                    x: x,
                    y: y
                  };
                };
                break;
              }
            case ContainmentType.parentEnclosed:
              {
                o.constrainFunction = function (pos, dragEl, _constrainRect, _size) {
                  var x = pos.x < 0 ? 0 : pos.x + _size.w > _constrainRect.w ? _constrainRect.w - _size.w : pos.x;
                  var y = pos.y < 0 ? 0 : pos.y + _size.h > _constrainRect.h ? _constrainRect.h - _size.h : pos.y;
                  return {
                    x: x,
                    y: y
                  };
                };
                break;
              }
          }
        }
        if (this.drag == null) {
          o.trackScroll = this._trackScroll;
          this.drag = this.collicat.draggable(this.instance.getContainer(), o);
          forEach(this._filtersToAdd, function (filterToAdd) {
            return _this2.drag.addFilter(filterToAdd[0], filterToAdd[1]);
          });
          this.drag.on(EVENT_REVERT, function (el) {
            _this2.instance.revalidate(el);
          });
        } else {
          this.drag.addSelector(o);
        }
        this.handlers.push({
          handler: handler,
          options: o
        });
        handler.init(this.drag);
      }
    }, {
      key: "addSelector",
      value: function addSelector(params, atStart) {
        this.drag && this.drag.addSelector(params, atStart);
      }
    }, {
      key: "addFilter",
      value: function addFilter(filter, exclude) {
        if (this.drag == null) {
          this._filtersToAdd.push([filter, exclude === true]);
        } else {
          this.drag.addFilter(filter, exclude);
        }
      }
    }, {
      key: "removeFilter",
      value: function removeFilter(filter) {
        if (this.drag != null) {
          this.drag.removeFilter(filter);
        }
      }
    }, {
      key: "setFilters",
      value: function setFilters(filters) {
        var _this3 = this;
        forEach(filters, function (f) {
          _this3.drag.addFilter(f[0], f[1]);
        });
      }
    }, {
      key: "reset",
      value: function reset() {
        var out = [];
        forEach(this.handlers, function (p) {
          p.handler.reset();
        });
        this.handlers.length = 0;
        if (this.drag != null) {
          var currentFilters = this.drag._filters;
          for (var f in currentFilters) {
            out.push([f, currentFilters[f][1]]);
          }
          this.collicat.destroyDraggable(this.instance.getContainer());
        }
        delete this.drag;
        return out;
      }
    }, {
      key: "setOption",
      value: function setOption(handler, options) {
        var handlerAndOptions = getWithFunction(this.handlers, function (p) {
          return p.handler === handler;
        });
        if (handlerAndOptions != null) {
          extend(handlerAndOptions.options, options || {});
        }
      }
    }]);
    return DragManager;
  }();

  function decodeDragGroupSpec(instance, spec) {
    if (isString(spec)) {
      return {
        id: spec,
        active: true
      };
    } else {
      return {
        id: instance.getId(spec),
        active: spec.active
      };
    }
  }
  function isActiveDragGroupMember(dragGroup, el) {
    var details = getFromSetWithFunction(dragGroup.members, function (m) {
      return m.el === el;
    });
    if (details !== null) {
      return details.active === true;
    } else {
      return false;
    }
  }
  function getAncestors(el) {
    var ancestors = [];
    var p = el._jsPlumbParentGroup;
    while (p != null) {
      ancestors.push(p.el);
      p = p.group;
    }
    return ancestors;
  }
  var ElementDragHandler = function () {
    function ElementDragHandler(instance, _dragSelection) {
      _classCallCheck$e(this, ElementDragHandler);
      this.instance = instance;
      this._dragSelection = _dragSelection;
      _defineProperty$d(this, "selector", "> " + SELECTOR_MANAGED_ELEMENT + ":not(" + cls(CLASS_OVERLAY) + ")");
      _defineProperty$d(this, "_dragOffset", null);
      _defineProperty$d(this, "_groupLocations", []);
      _defineProperty$d(this, "_intersectingGroups", []);
      _defineProperty$d(this, "_currentDragParentGroup", null);
      _defineProperty$d(this, "_dragGroupByElementIdMap", {});
      _defineProperty$d(this, "_dragGroupMap", {});
      _defineProperty$d(this, "_currentDragGroup", null);
      _defineProperty$d(this, "_currentDragGroupOffsets", new Map());
      _defineProperty$d(this, "_currentDragGroupSizes", new Map());
      _defineProperty$d(this, "_dragPayload", null);
      _defineProperty$d(this, "drag", void 0);
      _defineProperty$d(this, "originalPosition", void 0);
    }
    _createClass$e(ElementDragHandler, [{
      key: "onDragInit",
      value: function onDragInit(el) {
        return null;
      }
    }, {
      key: "onDragAbort",
      value: function onDragAbort(el) {
        return null;
      }
    }, {
      key: "getDropGroup",
      value: function getDropGroup() {
        var dropGroup = null;
        if (this._intersectingGroups.length > 0) {
          var targetGroup = this._intersectingGroups[0].groupLoc.group;
          var intersectingElement = this._intersectingGroups[0].intersectingElement;
          var currentGroup = intersectingElement._jsPlumbParentGroup;
          if (currentGroup !== targetGroup) {
            if (currentGroup == null || !currentGroup.overrideDrop(intersectingElement, targetGroup)) {
              dropGroup = this._intersectingGroups[0];
            }
          }
        }
        return dropGroup;
      }
    }, {
      key: "onStop",
      value: function onStop(params) {
        var _this = this;
        var jel = params.drag.getDragElement();
        var dropGroup = this.getDropGroup();
        var elementsToProcess = [];
        elementsToProcess.push({
          el: jel,
          id: this.instance.getId(jel),
          pos: params.finalPos,
          originalGroup: jel._jsPlumbParentGroup,
          redrawResult: null,
          originalPos: params.originalPos,
          reverted: false,
          dropGroup: dropGroup != null ? dropGroup.groupLoc.group : null
        });
        this._dragSelection.each(function (el, id, o, s, orig) {
          if (el !== params.el) {
            var pp = {
              x: o.x,
              y: o.y
            };
            var x = pp.x,
                y = pp.y;
            if (el._jsPlumbParentGroup && el._jsPlumbParentGroup.constrain) {
              var constrainRect = {
                w: el.parentNode.offsetWidth + el.parentNode.scrollLeft,
                h: el.parentNode.offsetHeight + el.parentNode.scrollTop
              };
              x = Math.max(x, 0);
              y = Math.max(y, 0);
              x = Math.min(x, constrainRect.w - s.w);
              y = Math.min(y, constrainRect.h - s.h);
              pp.x = x;
              pp.y = y;
            }
            elementsToProcess.push({
              el: el,
              id: id,
              pos: pp,
              originalPos: orig,
              originalGroup: el._jsPlumbParentGroup,
              redrawResult: null,
              reverted: false,
              dropGroup: dropGroup != null ? dropGroup.groupLoc.group : null
            });
          }
        });
        forEach(elementsToProcess, function (p) {
          var wasInGroup = p.originalGroup != null,
              isInOriginalGroup = wasInGroup && isInsideParent(_this.instance, p.el, p.pos),
              parentOffset = {
            x: 0,
            y: 0
          };
          if (wasInGroup && !isInOriginalGroup) {
            if (dropGroup == null) {
              var orphanedPosition = _this._pruneOrOrphan(p, true, true);
              if (orphanedPosition.pos != null) {
                p.pos = orphanedPosition.pos.pos;
              } else {
                if (!orphanedPosition.pruned && p.originalGroup.revert) {
                  p.pos = p.originalPos;
                  p.reverted = true;
                }
              }
            }
          } else if (wasInGroup && isInOriginalGroup) {
            parentOffset = _this.instance.viewport.getPosition(p.originalGroup.elId);
          }
          if (dropGroup != null && !isInOriginalGroup) {
            _this.instance.groupManager.addToGroup(dropGroup.groupLoc.group, false, p.el);
          } else {
            p.dropGroup = null;
          }
          if (p.reverted) {
            _this.instance.setPosition(p.el, p.pos);
          }
          p.redrawResult = _this.instance.setElementPosition(p.el, p.pos.x + parentOffset.x, p.pos.y + parentOffset.y);
          _this.instance.removeClass(p.el, CLASS_DRAGGED);
          _this.instance.select({
            source: p.el
          }).removeClass(_this.instance.elementDraggingClass + " " + _this.instance.sourceElementDraggingClass, true);
          _this.instance.select({
            target: p.el
          }).removeClass(_this.instance.elementDraggingClass + " " + _this.instance.targetElementDraggingClass, true);
        });
        if (elementsToProcess[0].originalGroup != null) {
          var currentGroup = jel._jsPlumbParentGroup;
          if (currentGroup !== elementsToProcess[0].originalGroup) {
            var originalElement = params.drag.getDragElement(true);
            if (elementsToProcess[0].originalGroup.ghost) {
              var o1 = this.instance.getOffset(this.instance.getGroupContentArea(currentGroup));
              var o2 = this.instance.getOffset(this.instance.getGroupContentArea(elementsToProcess[0].originalGroup));
              var o = {
                x: o2.x + params.pos.x - o1.x,
                y: o2.y + params.pos.y - o1.y
              };
              originalElement.style.left = o.x + "px";
              originalElement.style.top = o.y + "px";
              this.instance.revalidate(originalElement);
            }
          }
        }
        this.instance.fire(EVENT_DRAG_STOP, {
          elements: elementsToProcess,
          e: params.e,
          el: jel,
          payload: this._dragPayload
        });
        this._cleanup();
      }
    }, {
      key: "_cleanup",
      value: function _cleanup() {
        var _this2 = this;
        forEach(this._groupLocations, function (groupLoc) {
          _this2.instance.removeClass(groupLoc.el, CLASS_DRAG_ACTIVE);
          _this2.instance.removeClass(groupLoc.el, CLASS_DRAG_HOVER);
        });
        this._currentDragParentGroup = null;
        this._groupLocations.length = 0;
        this.instance.hoverSuspended = false;
        this._dragOffset = null;
        this._dragSelection.reset();
        this._dragPayload = null;
        this._currentDragGroupOffsets.clear();
        this._currentDragGroupSizes.clear();
        this._currentDragGroup = null;
      }
    }, {
      key: "reset",
      value: function reset() {}
    }, {
      key: "init",
      value: function init(drag) {
        this.drag = drag;
      }
    }, {
      key: "onDrag",
      value: function onDrag(params) {
        var _this3 = this;
        var el = params.drag.getDragElement();
        var finalPos = params.pos;
        var elSize = this.instance.getSize(el);
        var ui = {
          x: finalPos.x,
          y: finalPos.y
        };
        this._intersectingGroups.length = 0;
        if (this._dragOffset != null) {
          ui.x += this._dragOffset.x;
          ui.y += this._dragOffset.y;
        }
        var _one = function _one(el, bounds, findIntersectingGroups) {
          if (findIntersectingGroups) {
            var ancestorsOfIntersectingGroups = new Set();
            forEach(_this3._groupLocations, function (groupLoc) {
              if (!ancestorsOfIntersectingGroups.has(groupLoc.group.id) && intersects(bounds, groupLoc.r)) {
                if (groupLoc.group !== _this3._currentDragParentGroup) {
                  _this3.instance.addClass(groupLoc.el, CLASS_DRAG_HOVER);
                }
                _this3._intersectingGroups.push({
                  groupLoc: groupLoc,
                  intersectingElement: params.drag.getDragElement(true),
                  d: 0
                });
                forEach(_this3.instance.groupManager.getAncestors(groupLoc.group), function (g) {
                  return ancestorsOfIntersectingGroups.add(g.id);
                });
              } else {
                _this3.instance.removeClass(groupLoc.el, CLASS_DRAG_HOVER);
              }
            });
          }
          _this3.instance.setElementPosition(el, bounds.x, bounds.y);
          _this3.instance.fire(EVENT_DRAG_MOVE, {
            el: el,
            e: params.e,
            pos: {
              x: bounds.x,
              y: bounds.y
            },
            originalPosition: _this3.originalPosition,
            payload: _this3._dragPayload
          });
        };
        var elBounds = {
          x: ui.x,
          y: ui.y,
          w: elSize.w,
          h: elSize.h
        };
        _one(el, elBounds, true);
        this._dragSelection.updatePositions(finalPos, this.originalPosition, function (el, id, s, b) {
          _one(el, b, false);
        });
        this._currentDragGroupOffsets.forEach(function (v, k) {
          var s = _this3._currentDragGroupSizes.get(k);
          var _b = {
            x: elBounds.x + v[0].x,
            y: elBounds.y + v[0].y,
            w: s.w,
            h: s.h
          };
          v[1].style.left = _b.x + "px";
          v[1].style.top = _b.y + "px";
          _one(v[1], _b, false);
        });
      }
    }, {
      key: "onStart",
      value: function onStart(params) {
        var _this4 = this;
        var el = params.drag.getDragElement();
        var elOffset = this.instance.getOffset(el);
        this.originalPosition = {
          x: params.pos.x,
          y: params.pos.y
        };
        if (el._jsPlumbParentGroup) {
          this._dragOffset = this.instance.getOffset(el.offsetParent);
          this._currentDragParentGroup = el._jsPlumbParentGroup;
        }
        var cont = true;
        var nd = el.getAttribute(ATTRIBUTE_NOT_DRAGGABLE);
        if (this.instance.elementsDraggable === false || nd != null && nd !== FALSE$1) {
          cont = false;
        }
        if (cont) {
          this._groupLocations.length = 0;
          this._intersectingGroups.length = 0;
          this.instance.hoverSuspended = true;
          var originalElement = params.drag.getDragElement(true),
              descendants = originalElement.querySelectorAll(SELECTOR_MANAGED_ELEMENT),
              ancestors = getAncestors(originalElement),
              a = [];
          Array.prototype.push.apply(a, descendants);
          Array.prototype.push.apply(a, ancestors);
          this._dragSelection.filterActiveSet(function (p) {
            return a.indexOf(p.jel) === -1;
          });
          this._dragSelection.initialisePositions();
          var _one = function _one(_el) {
            if (!_el._isJsPlumbGroup || _this4.instance.allowNestedGroups) {
              var isNotInAGroup = !_el._jsPlumbParentGroup;
              var membersAreDroppable = isNotInAGroup || _el._jsPlumbParentGroup.dropOverride !== true;
              var isGhostOrNotConstrained = !isNotInAGroup && (_el._jsPlumbParentGroup.ghost || _el._jsPlumbParentGroup.constrain !== true);
              if (isNotInAGroup || membersAreDroppable && isGhostOrNotConstrained) {
                forEach(_this4.instance.groupManager.getGroups(), function (group) {
                  var elementGroup = _el._jsPlumbGroup;
                  if (group.droppable !== false && group.enabled !== false && _el._jsPlumbGroup !== group && !_this4.instance.groupManager.isDescendant(group, elementGroup)) {
                    var groupEl = group.el,
                        s = _this4.instance.getSize(groupEl),
                        o = _this4.instance.getOffset(groupEl),
                        boundingRect = {
                      x: o.x,
                      y: o.y,
                      w: s.w,
                      h: s.h
                    };
                    var groupLocation = {
                      el: groupEl,
                      r: boundingRect,
                      group: group
                    };
                    _this4._groupLocations.push(groupLocation);
                    if (group !== _this4._currentDragParentGroup) {
                      _this4.instance.addClass(groupEl, CLASS_DRAG_ACTIVE);
                    }
                  }
                });
                _this4._groupLocations.sort(function (a, b) {
                  if (_this4.instance.groupManager.isDescendant(a.group, b.group)) {
                    return -1;
                  } else if (_this4.instance.groupManager.isAncestor(b.group, a.group)) {
                    return 1;
                  } else {
                    return 0;
                  }
                });
              }
            }
            _this4.instance.select({
              source: _el
            }).addClass(_this4.instance.elementDraggingClass + " " + _this4.instance.sourceElementDraggingClass, true);
            _this4.instance.select({
              target: _el
            }).addClass(_this4.instance.elementDraggingClass + " " + _this4.instance.targetElementDraggingClass, true);
            return _this4.instance.fire(EVENT_DRAG_START, {
              el: _el,
              e: params.e,
              originalPosition: _this4.originalPosition,
              pos: _this4.originalPosition
            });
          };
          var elId = this.instance.getId(el);
          this._currentDragGroup = this._dragGroupByElementIdMap[elId];
          if (this._currentDragGroup && !isActiveDragGroupMember(this._currentDragGroup, el)) {
            this._currentDragGroup = null;
          }
          var dragStartReturn = _one(el);
          if (dragStartReturn === false) {
            this._cleanup();
            return false;
          } else {
            this._dragPayload = dragStartReturn;
          }
          if (this._currentDragGroup != null) {
            this._currentDragGroupOffsets.clear();
            this._currentDragGroupSizes.clear();
            this._currentDragGroup.members.forEach(function (jel) {
              var off = _this4.instance.getOffset(jel.el);
              _this4._currentDragGroupOffsets.set(jel.elId, [{
                x: off.x - elOffset.x,
                y: off.y - elOffset.y
              }, jel.el]);
              _this4._currentDragGroupSizes.set(jel.elId, _this4.instance.getSize(jel.el));
              _one(jel.el);
            });
          }
        }
        return cont;
      }
    }, {
      key: "addToDragGroup",
      value: function addToDragGroup(spec) {
        var _this5 = this;
        var details = decodeDragGroupSpec(this.instance, spec);
        var dragGroup = this._dragGroupMap[details.id];
        if (dragGroup == null) {
          dragGroup = {
            id: details.id,
            members: new Set()
          };
          this._dragGroupMap[details.id] = dragGroup;
        }
        for (var _len = arguments.length, els = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          els[_key - 1] = arguments[_key];
        }
        this.removeFromDragGroup.apply(this, els);
        forEach(els, function (el) {
          var elId = _this5.instance.getId(el);
          dragGroup.members.add({
            elId: elId,
            el: el,
            active: details.active
          });
          _this5._dragGroupByElementIdMap[elId] = dragGroup;
        });
      }
    }, {
      key: "removeFromDragGroup",
      value: function removeFromDragGroup() {
        var _this6 = this;
        for (var _len2 = arguments.length, els = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          els[_key2] = arguments[_key2];
        }
        forEach(els, function (el) {
          var id = _this6.instance.getId(el);
          var dragGroup = _this6._dragGroupByElementIdMap[id];
          if (dragGroup != null) {
            var s = new Set();
            dragGroup.members.forEach(function (member) {
              if (member.el !== el) {
                s.add(member);
              }
            });
            dragGroup.members = s;
            delete _this6._dragGroupByElementIdMap[id];
          }
        });
      }
    }, {
      key: "setDragGroupState",
      value: function setDragGroupState(state) {
        var _this7 = this;
        for (var _len3 = arguments.length, els = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
          els[_key3 - 1] = arguments[_key3];
        }
        var elementIds = els.map(function (el) {
          return _this7.instance.getId(el);
        });
        forEach(elementIds, function (id) {
          var dragGroup = _this7._dragGroupByElementIdMap[id];
          if (dragGroup != null) {
            var member = getFromSetWithFunction(dragGroup.members, function (m) {
              return m.elId === id;
            });
            if (member != null) {
              member.active = state;
            }
          }
        });
      }
    }, {
      key: "_pruneOrOrphan",
      value: function _pruneOrOrphan(params, doNotTransferToAncestor, isDefinitelyNotInsideParent) {
        var jel = params.el;
        var orphanedPosition = {
          pruned: false,
          pos: null
        };
        if (isDefinitelyNotInsideParent || !isInsideParent(this.instance, jel, params.pos)) {
          var group = jel._jsPlumbParentGroup;
          if (group.prune) {
            if (jel._isJsPlumbGroup) {
              this.instance.removeGroup(jel._jsPlumbGroup);
            } else {
              group.remove(params.el, true);
            }
            orphanedPosition.pruned = true;
          } else if (group.orphan) {
            orphanedPosition.pos = this.instance.groupManager.orphan(params.el, doNotTransferToAncestor);
            if (jel._isJsPlumbGroup) {
              group.removeGroup(jel._jsPlumbGroup);
            } else {
              group.remove(params.el);
            }
          }
        }
        return orphanedPosition;
      }
    }]);
    return ElementDragHandler;
  }();

  function _makeFloatingEndpoint(ep, endpoint, referenceCanvas, sourceElement, instance) {
    var floatingAnchor = createFloatingAnchor(instance, sourceElement);
    var p = {
      paintStyle: ep.getPaintStyle(),
      preparedAnchor: floatingAnchor,
      element: sourceElement,
      scope: ep.scope
    };
    if (endpoint != null) {
      if (isAssignableFrom(endpoint, EndpointRepresentation)) {
        p.existingEndpoint = endpoint;
      } else {
        p.endpoint = endpoint;
      }
    }
    var actualEndpoint = instance._internal_newEndpoint(p);
    instance._paintEndpoint(actualEndpoint, {});
    return actualEndpoint;
  }
  function selectorFilter(evt, _el, selector, _instance, negate) {
    var t = evt.target || evt.srcElement,
        ok = false,
        sel = _instance.getSelector(_el, selector);
    for (var j = 0; j < sel.length; j++) {
      if (sel[j] === t) {
        ok = true;
        break;
      }
    }
    return negate ? !ok : ok;
  }
  var SELECTOR_DRAG_ACTIVE_OR_HOVER = cls(CLASS_DRAG_ACTIVE, CLASS_DRAG_HOVER);
  var SOURCE_SELECTOR_UNIQUE_ENDPOINT_DATA = "sourceSelectorEndpoint";
  var EndpointDragHandler = function () {
    function EndpointDragHandler(instance) {
      _classCallCheck$e(this, EndpointDragHandler);
      this.instance = instance;
      _defineProperty$d(this, "jpc", void 0);
      _defineProperty$d(this, "existingJpc", void 0);
      _defineProperty$d(this, "_originalAnchorSpec", void 0);
      _defineProperty$d(this, "ep", void 0);
      _defineProperty$d(this, "endpointRepresentation", void 0);
      _defineProperty$d(this, "canvasElement", void 0);
      _defineProperty$d(this, "_activeDefinition", void 0);
      _defineProperty$d(this, "placeholderInfo", {
        id: null,
        element: null
      });
      _defineProperty$d(this, "floatingIndex", void 0);
      _defineProperty$d(this, "floatingId", void 0);
      _defineProperty$d(this, "floatingElement", void 0);
      _defineProperty$d(this, "floatingEndpoint", void 0);
      _defineProperty$d(this, "floatingAnchor", void 0);
      _defineProperty$d(this, "_stopped", void 0);
      _defineProperty$d(this, "inPlaceCopy", void 0);
      _defineProperty$d(this, "endpointDropTargets", []);
      _defineProperty$d(this, "currentDropTarget", null);
      _defineProperty$d(this, "payload", void 0);
      _defineProperty$d(this, "floatingConnections", {});
      _defineProperty$d(this, "_forceReattach", void 0);
      _defineProperty$d(this, "_forceDetach", void 0);
      _defineProperty$d(this, "mousedownHandler", void 0);
      _defineProperty$d(this, "mouseupHandler", void 0);
      _defineProperty$d(this, "selector", cls(CLASS_ENDPOINT));
      var container = instance.getContainer();
      this.mousedownHandler = this._mousedownHandler.bind(this);
      this.mouseupHandler = this._mouseupHandler.bind(this);
      instance.on(container, EVENT_MOUSEDOWN, SELECTOR_MANAGED_ELEMENT, this.mousedownHandler);
      instance.on(container, EVENT_MOUSEUP, [SELECTOR_MANAGED_ELEMENT, cls(CLASS_ENDPOINT)].join(","), this.mouseupHandler);
    }
    _createClass$e(EndpointDragHandler, [{
      key: "_resolveDragParent",
      value: function _resolveDragParent(def, eventTarget) {
        var container = this.instance.getContainer();
        var parent = findParent(eventTarget, SELECTOR_MANAGED_ELEMENT, container, true);
        if (def.parentSelector != null) {
          var child = findParent(eventTarget, def.parentSelector, container, true);
          if (child != null) {
            parent = findParent(child.parentNode, SELECTOR_MANAGED_ELEMENT, container, false);
          }
          return child || parent;
        } else {
          return parent;
        }
      }
    }, {
      key: "_mousedownHandler",
      value: function _mousedownHandler(e) {
        var sourceEl;
        var sourceSelector;
        if (e.which === 3 || e.button === 2) {
          return;
        }
        var eventTarget = e.target || e.srcElement;
        sourceSelector = this._getSourceDefinition(e);
        if (sourceSelector != null) {
          sourceEl = this._resolveDragParent(sourceSelector.def.def, eventTarget);
          if (sourceEl == null || sourceEl.getAttribute(ATTRIBUTE_JTK_ENABLED) === FALSE$1) {
            return;
          }
        }
        if (sourceSelector) {
          var sourceElement = e.currentTarget,
              def;
          if (eventTarget.getAttribute(ATTRIBUTE_JTK_ENABLED) !== FALSE$1) {
            consume(e);
            this._activeDefinition = sourceSelector;
            def = sourceSelector.def.def;
            if (def.canAcceptNewConnection != null && !def.canAcceptNewConnection(sourceEl, e)) {
              return false;
            }
            var elxy = getPositionOnElement(e, sourceEl, this.instance.currentZoom);
            var tempEndpointParams = {
              element: sourceEl
            };
            extend(tempEndpointParams, def);
            tempEndpointParams.isTemporarySource = true;
            if (def.scope) {
              tempEndpointParams.scope = def.scope;
            } else {
              var scopeFromElement = eventTarget.getAttribute(ATTRIBUTE_JTK_SCOPE);
              if (scopeFromElement != null) {
                tempEndpointParams.scope = scopeFromElement;
              }
            }
            var extractedParameters = def.parameterExtractor ? def.parameterExtractor(sourceEl, eventTarget, e) : {};
            tempEndpointParams = merge(tempEndpointParams, extractedParameters);
            if (tempEndpointParams.maxConnections != null && tempEndpointParams.maxConnections >= 0) {
              var sourceCount = this.instance.select({
                source: sourceEl
              }).length;
              if (sourceCount >= tempEndpointParams.maxConnections) {
                consume(e);
                if (def.onMaxConnections) {
                  def.onMaxConnections({
                    element: sourceEl,
                    maxConnections: tempEndpointParams.maxConnections
                  }, e);
                }
                e.stopImmediatePropagation && e.stopImmediatePropagation();
                return false;
              }
            }
            if (def.anchorPositionFinder) {
              var maybeAnchorSpec = def.anchorPositionFinder(sourceEl, elxy, def, e);
              if (maybeAnchorSpec != null) {
                tempEndpointParams.anchor = maybeAnchorSpec;
              }
            }
            this._originalAnchorSpec = tempEndpointParams.anchor || (this.instance.areDefaultAnchorsSet() ? this.instance.defaults.anchors[0] : this.instance.defaults.anchor);
            var _originalAnchor = this.instance.router.prepareAnchor(this._originalAnchorSpec);
            var anchorSpecToUse = [elxy.x, elxy.y, 0, 0];
            if (_originalAnchor.locations.length > 0) {
              anchorSpecToUse[2] = _originalAnchor.locations[0].ox;
              anchorSpecToUse[3] = _originalAnchor.locations[0].oy;
            } else if (_originalAnchor.isContinuous) {
              var dx = elxy.x < 0.5 ? elxy.x : 1 - elxy.x;
              var dy = elxy.y < 0.5 ? elxy.y : 1 - elxy.y;
              anchorSpecToUse[2] = dx < dy ? elxy.x < 0.5 ? -1 : 1 : 0;
              anchorSpecToUse[3] = dy < dx ? elxy.y < 0.5 ? -1 : 1 : 0;
            }
            tempEndpointParams.anchor = anchorSpecToUse;
            tempEndpointParams.deleteOnEmpty = true;
            this.ep = this.instance._internal_newEndpoint(tempEndpointParams);
            var payload = {};
            if (def.extract) {
              for (var att in def.extract) {
                var v = eventTarget.getAttribute(att);
                if (v) {
                  payload[def.extract[att]] = v;
                }
              }
              this.ep.mergeParameters(payload);
            }
            if (tempEndpointParams.uniqueEndpoint) {
              var elementId = this.ep.elementId;
              var existingUniqueEndpoint = this.instance.getManagedData(elementId, SOURCE_SELECTOR_UNIQUE_ENDPOINT_DATA, sourceSelector.id);
              if (existingUniqueEndpoint == null) {
                this.instance.setManagedData(elementId, SOURCE_SELECTOR_UNIQUE_ENDPOINT_DATA, sourceSelector.id, this.ep);
                this.ep.deleteOnEmpty = false;
              } else {
                this.ep.finalEndpoint = existingUniqueEndpoint;
              }
            }
            sourceElement._jsPlumbOrphanedEndpoints = sourceElement._jsPlumbOrphanedEndpoints || [];
            sourceElement._jsPlumbOrphanedEndpoints.push(this.ep);
            this.instance.trigger(this.ep.endpoint.canvas, EVENT_MOUSEDOWN, e, payload);
          }
        }
      }
    }, {
      key: "_mouseupHandler",
      value: function _mouseupHandler(e) {
        var el = e.currentTarget || e.srcElement;
        if (el._jsPlumbOrphanedEndpoints) {
          each(el._jsPlumbOrphanedEndpoints, this.instance._maybePruneEndpoint.bind(this.instance));
          el._jsPlumbOrphanedEndpoints.length = 0;
        }
        this._activeDefinition = null;
      }
    }, {
      key: "onDragInit",
      value: function onDragInit(el) {
        var ipco = this.instance.getOffset(el),
            ips = this.instance.getSize(el);
        this._makeDraggablePlaceholder(ipco, ips);
        this.placeholderInfo.element.jtk = el.jtk;
        return this.placeholderInfo.element;
      }
    }, {
      key: "onDragAbort",
      value: function onDragAbort(el) {
        this._cleanupDraggablePlaceholder();
      }
    }, {
      key: "_makeDraggablePlaceholder",
      value: function _makeDraggablePlaceholder(ipco, ips) {
        this.placeholderInfo = this.placeholderInfo || {};
        var n = createElement(ELEMENT_DIV, {
          position: "absolute"
        });
        this.instance._appendElement(n, this.instance.getContainer());
        var id = this.instance.getId(n);
        this.instance.setPosition(n, ipco);
        n.style.width = ips.w + "px";
        n.style.height = ips.h + "px";
        this.instance.manage(n);
        this.placeholderInfo.id = id;
        this.placeholderInfo.element = n;
        return n;
      }
    }, {
      key: "_cleanupDraggablePlaceholder",
      value: function _cleanupDraggablePlaceholder() {
        if (this.placeholderInfo.element) {
          this.instance.unmanage(this.placeholderInfo.element, true);
          delete this.placeholderInfo.element;
          delete this.placeholderInfo.id;
        }
      }
    }, {
      key: "reset",
      value: function reset() {
        var c = this.instance.getContainer();
        this.instance.off(c, EVENT_MOUSEUP, this.mouseupHandler);
        this.instance.off(c, EVENT_MOUSEDOWN, this.mousedownHandler);
      }
    }, {
      key: "init",
      value: function init(drag) {}
    }, {
      key: "startNewConnectionDrag",
      value: function startNewConnectionDrag(scope, data) {
        this.jpc = this.instance._newConnection({
          sourceEndpoint: this.ep,
          targetEndpoint: this.floatingEndpoint,
          source: this.ep.element,
          target: this.placeholderInfo.element,
          paintStyle: this.ep.connectorStyle,
          hoverPaintStyle: this.ep.connectorHoverStyle,
          connector: this.ep.connector,
          overlays: this.ep.connectorOverlays,
          type: this.ep.edgeType,
          cssClass: this.ep.connectorClass,
          hoverClass: this.ep.connectorHoverClass,
          scope: scope,
          data: data
        });
        this.jpc.pending = true;
        this.jpc.addClass(this.instance.draggingClass);
        this.floatingEndpoint.addClass(this.instance.draggingClass);
        this.instance.fire(EVENT_CONNECTION_DRAG, this.jpc);
      }
    }, {
      key: "startExistingConnectionDrag",
      value: function startExistingConnectionDrag() {
        this.existingJpc = true;
        this.instance.setHover(this.jpc, false);
        var anchorIdx = this.jpc.endpoints[0].id === this.ep.id ? 0 : 1;
        this.ep.detachFromConnection(this.jpc, null, true);
        this.floatingEndpoint.addConnection(this.jpc);
        this.floatingEndpoint.addClass(this.instance.draggingClass);
        this.instance.fire(EVENT_CONNECTION_DRAG, this.jpc);
        this.instance.sourceOrTargetChanged(this.jpc.endpoints[anchorIdx].elementId, this.placeholderInfo.id, this.jpc, this.placeholderInfo.element, anchorIdx);
        this.jpc.suspendedEndpoint = this.jpc.endpoints[anchorIdx];
        this.jpc.suspendedElement = this.jpc.endpoints[anchorIdx].element;
        this.jpc.suspendedElementId = this.jpc.endpoints[anchorIdx].elementId;
        this.jpc.suspendedElementType = anchorIdx === 0 ? SOURCE$1 : TARGET$1;
        this.instance.setHover(this.jpc.suspendedEndpoint, false);
        this.floatingEndpoint.referenceEndpoint = this.jpc.suspendedEndpoint;
        this.floatingEndpoint.mergeParameters(this.jpc.suspendedEndpoint.parameters);
        this.jpc.endpoints[anchorIdx] = this.floatingEndpoint;
        this.jpc.addClass(this.instance.draggingClass);
        this.floatingId = this.placeholderInfo.id;
        this.floatingIndex = anchorIdx;
      }
    }, {
      key: "_shouldStartDrag",
      value: function _shouldStartDrag() {
        var _continue = true;
        if (!this.ep.enabled) {
          _continue = false;
        }
        if (this.jpc == null && !this.ep.isSource && !this.ep.isTemporarySource) {
          _continue = false;
        }
        if (this.ep.isSource && this.ep.isFull() && !(this.jpc != null && this.ep.dragAllowedWhenFull)) {
          _continue = false;
        }
        if (this.jpc != null && !this.jpc.isDetachable(this.ep)) {
          if (this.ep.isFull()) {
            _continue = false;
          } else {
            this.jpc = null;
          }
        }
        var payload = {};
        var beforeDrag = this.instance.checkCondition(this.jpc == null ? INTERCEPT_BEFORE_DRAG : INTERCEPT_BEFORE_START_DETACH, {
          endpoint: this.ep,
          source: this.ep.element,
          sourceId: this.ep.elementId,
          connection: this.jpc
        });
        if (beforeDrag === false) {
          _continue = false;
        }
        else if (_typeof$1(beforeDrag) === "object") {
          payload = beforeDrag;
          extend(payload, this.payload || {});
        } else {
          payload = this.payload || {};
        }
        return [_continue, payload];
      }
    }, {
      key: "_createFloatingEndpoint",
      value: function _createFloatingEndpoint(canvasElement) {
        var endpointToFloat = this.ep.endpoint;
        if (this.ep.edgeType != null) {
          var aae = this.instance._deriveEndpointAndAnchorSpec(this.ep.edgeType);
          endpointToFloat = aae.endpoints[1];
        }
        this.floatingEndpoint = _makeFloatingEndpoint(this.ep, endpointToFloat, canvasElement, this.placeholderInfo.element, this.instance);
        this.floatingAnchor = this.floatingEndpoint._anchor;
        this.floatingEndpoint.deleteOnEmpty = true;
        this.floatingElement = this.floatingEndpoint.endpoint.canvas;
        this.floatingId = this.instance.getId(this.floatingElement);
      }
    }, {
      key: "_populateTargets",
      value: function _populateTargets(canvasElement, eventTarget, event) {
        var _this = this;
        var isSourceDrag = this.jpc && this.jpc.endpoints[0] === this.ep;
        var boundingRect;
        var matchingEndpoints = this.instance.getContainer().querySelectorAll([".", CLASS_ENDPOINT, "[", ATTRIBUTE_SCOPE_PREFIX, this.ep.scope, "]"].join(""));
        forEach(matchingEndpoints, function (candidate) {
          if ((_this.jpc != null || candidate !== canvasElement) && candidate !== _this.floatingElement && !candidate.jtk.endpoint.isFull()) {
            if (isSourceDrag && candidate.jtk.endpoint.isSource || !isSourceDrag && candidate.jtk.endpoint.isTarget) {
              var o = _this.instance.getOffset(candidate),
                  s = _this.instance.getSize(candidate);
              boundingRect = {
                x: o.x,
                y: o.y,
                w: s.w,
                h: s.h
              };
              _this.endpointDropTargets.push({
                el: candidate,
                targetEl: candidate,
                r: boundingRect,
                endpoint: candidate.jtk.endpoint,
                def: null
              });
              _this.instance.addClass(candidate, CLASS_DRAG_ACTIVE);
            }
          }
        });
        if (isSourceDrag) {
          var sourceDef = getWithFunction(this.instance.sourceSelectors, function (sSel) {
            return sSel.isEnabled() && (sSel.def.def.scope == null || sSel.def.def.scope === _this.ep.scope);
          });
          if (sourceDef != null) {
            var targetZones = this.instance.getContainer().querySelectorAll(sourceDef.redrop === REDROP_POLICY_ANY ? SELECTOR_MANAGED_ELEMENT : sourceDef.selector);
            forEach(targetZones, function (el) {
              if (el.getAttribute(ATTRIBUTE_JTK_ENABLED) !== FALSE$1) {
                var scopeFromElement = el.getAttribute(ATTRIBUTE_JTK_SCOPE);
                if (scopeFromElement != null && scopeFromElement !== _this.ep.scope) {
                  return;
                }
                var d = {
                  r: null,
                  el: el
                };
                d.targetEl = findParent(el, SELECTOR_MANAGED_ELEMENT, _this.instance.getContainer(), true);
                var o = _this.instance.getOffset(d.el),
                    s = _this.instance.getSize(d.el);
                d.r = {
                  x: o.x,
                  y: o.y,
                  w: s.w,
                  h: s.h
                };
                if (sourceDef.def.def.rank != null) {
                  d.rank = sourceDef.def.def.rank;
                }
                d.def = sourceDef;
                _this.endpointDropTargets.push(d);
                _this.instance.addClass(d.targetEl, CLASS_DRAG_ACTIVE);
              }
            });
          }
        } else {
          var targetDefs = getAllWithFunction(this.instance.targetSelectors, function (tSel) {
            return tSel.isEnabled();
          });
          targetDefs.forEach(function (targetDef) {
            var targetZones = _this.instance.getContainer().querySelectorAll(targetDef.selector);
            forEach(targetZones, function (el) {
              if (el.getAttribute(ATTRIBUTE_JTK_ENABLED) !== FALSE$1) {
                var scopeFromElement = el.getAttribute(ATTRIBUTE_JTK_SCOPE);
                if (scopeFromElement != null && scopeFromElement !== _this.ep.scope) {
                  return;
                }
                var d = {
                  r: null,
                  el: el
                };
                if (targetDef.def.def.parentSelector != null) {
                  d.targetEl = findParent(el, targetDef.def.def.parentSelector, _this.instance.getContainer(), true);
                }
                if (d.targetEl == null) {
                  d.targetEl = findParent(el, SELECTOR_MANAGED_ELEMENT, _this.instance.getContainer(), true);
                }
                if (targetDef.def.def.allowLoopback === false || _this._activeDefinition && _this._activeDefinition.def.def.allowLoopback === false) {
                  if (d.targetEl === _this.ep.element) {
                    return;
                  }
                }
                if (targetDef.def.def.canAcceptNewConnection != null && !targetDef.def.def.canAcceptNewConnection(d.targetEl, event)) {
                  return;
                }
                var maxConnections = targetDef.def.def.maxConnections;
                if (maxConnections != null && maxConnections !== -1) {
                  if (_this.instance.select({
                    target: d.targetEl
                  }).length >= maxConnections) {
                    return;
                  }
                }
                var o = _this.instance.getOffset(el),
                    s = _this.instance.getSize(el);
                d.r = {
                  x: o.x,
                  y: o.y,
                  w: s.w,
                  h: s.h
                };
                d.def = targetDef.def;
                if (targetDef.def.def.rank != null) {
                  d.rank = targetDef.def.def.rank;
                }
                _this.endpointDropTargets.push(d);
                _this.instance.addClass(d.targetEl, CLASS_DRAG_ACTIVE);
              }
            });
          });
        }
        this.endpointDropTargets.sort(function (a, b) {
          if (a.targetEl._isJsPlumbGroup && !b.targetEl._isJsPlumbGroup) {
            return 1;
          } else if (!a.targetEl._isJsPlumbGroup && b.targetEl._isJsPlumbGroup) {
            return -1;
          } else {
            if (a.targetEl._isJsPlumbGroup && b.targetEl._isJsPlumbGroup) {
              if (_this.instance.groupManager.isAncestor(a.targetEl._jsPlumbGroup, b.targetEl._jsPlumbGroup)) {
                return -1;
              } else if (_this.instance.groupManager.isAncestor(b.targetEl._jsPlumbGroup, a.targetEl._jsPlumbGroup)) {
                return 1;
              }
            } else {
              if (a.rank != null && b.rank != null) {
                if (a.rank > b.rank) {
                  return -1;
                } else if (a.rank < b.rank) {
                  return 1;
                } else ;
              } else {
                return 0;
              }
            }
          }
        });
      }
    }, {
      key: "onStart",
      value: function onStart(p) {
        this.endpointDropTargets.length = 0;
        this.currentDropTarget = null;
        this._stopped = false;
        var dragEl = p.drag.getDragElement();
        this.ep = dragEl.jtk.endpoint;
        var eventTarget = p.e.srcElement || p.e.target;
        if (!this.ep) {
          return false;
        }
        this.endpointRepresentation = this.ep.endpoint;
        this.canvasElement = this.endpointRepresentation.canvas;
        this.jpc = this.ep.connectorSelector();
        var _this$_shouldStartDra = this._shouldStartDrag(),
            _this$_shouldStartDra2 = _slicedToArray$3(_this$_shouldStartDra, 2),
            _continue = _this$_shouldStartDra2[0],
            payload = _this$_shouldStartDra2[1];
        if (_continue === false) {
          this._stopped = true;
          return false;
        }
        this.instance.setHover(this.ep, false);
        this.instance.isConnectionBeingDragged = true;
        if (this.jpc && !this.ep.isFull() && this.ep.isSource) {
          this.jpc = null;
        }
        this._createFloatingEndpoint(this.canvasElement);
        this._populateTargets(this.canvasElement, eventTarget, p.e);
        if (this.jpc == null) {
          this.startNewConnectionDrag(this.ep.scope, payload);
        } else {
          this.startExistingConnectionDrag();
        }
        this._registerFloatingConnection(this.placeholderInfo, this.jpc, this.floatingEndpoint);
        this.instance.currentlyDragging = true;
      }
    }, {
      key: "onBeforeStart",
      value: function onBeforeStart(beforeStartParams) {
        this.payload = beforeStartParams.e.payload || {};
      }
    }, {
      key: "onDrag",
      value: function onDrag(params) {
        if (this._stopped) {
          return true;
        }
        if (this.placeholderInfo.element) {
          var floatingElementSize = this.instance.getSize(this.floatingElement);
          this.instance.setElementPosition(this.placeholderInfo.element, params.pos.x, params.pos.y);
          var boundingRect = {
            x: params.pos.x,
            y: params.pos.y,
            w: floatingElementSize.w,
            h: floatingElementSize.h
          },
              newDropTarget,
              idx,
              _cont;
          for (var i = 0; i < this.endpointDropTargets.length; i++) {
            if (intersects(boundingRect, this.endpointDropTargets[i].r)) {
              newDropTarget = this.endpointDropTargets[i];
              break;
            }
          }
          if (newDropTarget !== this.currentDropTarget && this.currentDropTarget != null) {
            idx = this._getFloatingAnchorIndex();
            this.instance.removeClass(this.currentDropTarget.el, CLASS_DRAG_HOVER);
            if (this.currentDropTarget.endpoint) {
              this.currentDropTarget.endpoint.endpoint.removeClass(this.instance.endpointDropAllowedClass);
              this.currentDropTarget.endpoint.endpoint.removeClass(this.instance.endpointDropForbiddenClass);
            }
            this.floatingAnchor.out();
          }
          if (newDropTarget != null) {
            this.instance.addClass(newDropTarget.el, CLASS_DRAG_HOVER);
            idx = this._getFloatingAnchorIndex();
            if (newDropTarget.endpoint != null) {
              _cont = newDropTarget.endpoint.isSource && idx === 0 || newDropTarget.endpoint.isTarget && idx !== 0 || this.jpc.suspendedEndpoint && newDropTarget.endpoint.referenceEndpoint && newDropTarget.endpoint.referenceEndpoint.id === this.jpc.suspendedEndpoint.id;
              if (_cont) {
                var bb = this.instance.checkCondition(CHECK_DROP_ALLOWED, {
                  sourceEndpoint: this.jpc.endpoints[idx],
                  targetEndpoint: newDropTarget.endpoint.endpoint,
                  connection: this.jpc
                });
                if (bb) {
                  newDropTarget.endpoint.endpoint.addClass(this.instance.endpointDropAllowedClass);
                  newDropTarget.endpoint.endpoint.removeClass(this.instance.endpointDropForbiddenClass);
                } else {
                  newDropTarget.endpoint.endpoint.removeClass(this.instance.endpointDropAllowedClass);
                  newDropTarget.endpoint.endpoint.addClass(this.instance.endpointDropForbiddenClass);
                }
                this.floatingAnchor.over(newDropTarget.endpoint);
                this.instance._paintConnection(this.jpc);
              } else {
                newDropTarget = null;
              }
            }
          }
          this.currentDropTarget = newDropTarget;
        }
      }
    }, {
      key: "_maybeCleanup",
      value: function _maybeCleanup(ep) {
        if (ep._mtNew && ep.connections.length === 0) {
          this.instance.deleteEndpoint(ep);
        } else {
          delete ep._mtNew;
        }
      }
    }, {
      key: "_reattachOrDiscard",
      value: function _reattachOrDiscard(originalEvent) {
        var existingConnection = this.jpc.suspendedEndpoint != null;
        var idx = this._getFloatingAnchorIndex();
        if (existingConnection && this._shouldReattach(originalEvent)) {
          if (idx === 0) {
            this.jpc.source = this.jpc.suspendedElement;
            this.jpc.sourceId = this.jpc.suspendedElementId;
          } else {
            this.jpc.target = this.jpc.suspendedElement;
            this.jpc.targetId = this.jpc.suspendedElementId;
          }
          this._doForceReattach(idx);
          return true;
        } else {
          this._discard(idx, originalEvent);
          return false;
        }
      }
    }, {
      key: "onStop",
      value: function onStop(p) {
        var _this2 = this;
        var originalEvent = p.e;
        this.instance.isConnectionBeingDragged = false;
        this.instance.currentlyDragging = false;
        var classesToRemove = classList(CLASS_DRAG_HOVER, CLASS_DRAG_ACTIVE);
        var matchingSelectors = this.instance.getContainer().querySelectorAll(SELECTOR_DRAG_ACTIVE_OR_HOVER);
        forEach(matchingSelectors, function (el) {
          _this2.instance.removeClass(el, classesToRemove);
        });
        if (this.jpc && this.jpc.endpoints != null) {
          var existingConnection = this.jpc.suspendedEndpoint != null;
          var idx = this._getFloatingAnchorIndex();
          var suspendedEndpoint = this.jpc.suspendedEndpoint;
          var dropEndpoint;
          if (this.currentDropTarget != null) {
            dropEndpoint = this._getDropEndpoint(p, this.jpc);
            if (dropEndpoint == null) {
              !this._reattachOrDiscard(p.e);
            } else {
              if (suspendedEndpoint && suspendedEndpoint.id === dropEndpoint.id) {
                this._doForceReattach(idx);
              } else {
                if (!dropEndpoint.enabled) {
                  this._reattachOrDiscard(p.e);
                } else if (dropEndpoint.isFull()) {
                  dropEndpoint.fire(EVENT_MAX_CONNECTIONS, {
                    endpoint: this,
                    connection: this.jpc,
                    maxConnections: this.instance.defaults.maxConnections
                  }, originalEvent);
                  this._reattachOrDiscard(p.e);
                } else {
                  if (idx === 0) {
                    this.jpc.source = dropEndpoint.element;
                    this.jpc.sourceId = dropEndpoint.elementId;
                  } else {
                    this.jpc.target = dropEndpoint.element;
                    this.jpc.targetId = dropEndpoint.elementId;
                  }
                  var _doContinue = true;
                  if (existingConnection && this.jpc.suspendedEndpoint.id !== dropEndpoint.id) {
                    if (!this.jpc.isDetachAllowed(this.jpc) || !this.jpc.endpoints[idx].isDetachAllowed(this.jpc) || !this.jpc.suspendedEndpoint.isDetachAllowed(this.jpc) || !this.instance.checkCondition("beforeDetach", this.jpc)) {
                      _doContinue = false;
                    }
                  }
                  _doContinue = _doContinue && dropEndpoint.isDropAllowed(this.jpc.sourceId, this.jpc.targetId, this.jpc.scope, this.jpc, dropEndpoint);
                  if (_doContinue) {
                    this._drop(dropEndpoint, idx, originalEvent, _doContinue);
                  } else {
                    this._reattachOrDiscard(p.e);
                  }
                }
              }
            }
          } else {
            this._reattachOrDiscard(p.e);
          }
          this.instance._refreshEndpoint(this.ep);
          this.ep.removeClass(this.instance.draggingClass);
          this._cleanupDraggablePlaceholder();
          this.jpc.removeClass(this.instance.draggingClass);
          delete this.jpc.suspendedEndpoint;
          delete this.jpc.suspendedElement;
          delete this.jpc.suspendedElementType;
          delete this.jpc.suspendedElementId;
          delete this.jpc.suspendedIndex;
          delete this.floatingId;
          delete this.floatingIndex;
          delete this.floatingElement;
          delete this.floatingEndpoint;
          delete this.floatingAnchor;
          delete this.jpc.pending;
          if (dropEndpoint != null) {
            this._maybeCleanup(dropEndpoint);
          }
        }
      }
    }, {
      key: "_getSourceDefinition",
      value: function _getSourceDefinition(evt) {
        var selector;
        for (var i = 0; i < this.instance.sourceSelectors.length; i++) {
          selector = this.instance.sourceSelectors[i];
          if (selector.isEnabled()) {
            var r = selectorFilter(evt, this.instance.getContainer(), selector.selector, this.instance, selector.exclude);
            if (r !== false) {
              return selector;
            }
          }
        }
      }
    }, {
      key: "_getDropEndpoint",
      value: function _getDropEndpoint(p, jpc) {
        var dropEndpoint;
        if (this.currentDropTarget.endpoint == null) {
          var targetDefinition = this.currentDropTarget.def;
          var eventTarget = p.e.target || p.e.srcElement;
          if (targetDefinition == null) {
            return null;
          }
          var targetElement = this.currentDropTarget.targetEl;
          var elxy = getPositionOnElement(p.e, targetElement, this.instance.currentZoom);
          var eps = this.instance._deriveEndpointAndAnchorSpec(jpc.getType().join(" "), true);
          var pp = eps.endpoints ? extend(p, {
            endpoint: targetDefinition.def.endpoint || eps.endpoints[1]
          }) : p;
          var anchorsToUse = this.instance.validAnchorsSpec(eps.anchors) ? eps.anchors : this.instance.areDefaultAnchorsSet() ? this.instance.defaults.anchors : null;
          var anchorFromDef = targetDefinition.def.anchor;
          var anchorFromPositionFinder = targetDefinition.def.anchorPositionFinder ? targetDefinition.def.anchorPositionFinder(targetElement, elxy, targetDefinition.def, p.e) : null;
          var dropAnchor = anchorFromPositionFinder != null ? anchorFromPositionFinder : anchorFromDef != null ? anchorFromDef : anchorsToUse != null && anchorsToUse[1] != null ? anchorsToUse[1] : null;
          if (dropAnchor != null) {
            pp = extend(pp, {
              anchor: dropAnchor
            });
          }
          if (targetDefinition.def.portId != null) {
            pp.portId = targetDefinition.def.portId;
          }
          var extractedParameters = targetDefinition.def.parameterExtractor ? targetDefinition.def.parameterExtractor(this.currentDropTarget.el, eventTarget, p.e) : {};
          pp = merge(pp, extractedParameters);
          pp.element = targetElement;
          dropEndpoint = this.instance._internal_newEndpoint(pp);
          dropEndpoint._mtNew = true;
          dropEndpoint.deleteOnEmpty = true;
          if (targetDefinition.def.parameters) {
            dropEndpoint.mergeParameters(targetDefinition.def.parameters);
          }
          if (targetDefinition.def.extract) {
            var tpayload = {};
            for (var att in targetDefinition.def.extract) {
              var v = this.currentDropTarget.el.getAttribute(att);
              if (v) {
                tpayload[targetDefinition.def.extract[att]] = v;
              }
            }
            dropEndpoint.mergeParameters(tpayload);
          }
        } else {
          dropEndpoint = this.currentDropTarget.endpoint;
        }
        if (dropEndpoint) {
          dropEndpoint.removeClass(this.instance.endpointDropAllowedClass);
          dropEndpoint.removeClass(this.instance.endpointDropForbiddenClass);
        }
        return dropEndpoint;
      }
    }, {
      key: "_doForceReattach",
      value: function _doForceReattach(idx) {
        this.floatingEndpoint.detachFromConnection(this.jpc, null, true);
        this.jpc.endpoints[idx] = this.jpc.suspendedEndpoint;
        this.instance.setHover(this.jpc, false);
        this.jpc._forceDetach = true;
        this.jpc.suspendedEndpoint.addConnection(this.jpc);
        this.instance.sourceOrTargetChanged(this.floatingId, this.jpc.suspendedEndpoint.elementId, this.jpc, this.jpc.suspendedEndpoint.element, idx);
        this.instance.deleteEndpoint(this.floatingEndpoint);
        this.instance.repaint(this.jpc.source);
        delete this.jpc._forceDetach;
      }
    }, {
      key: "_shouldReattach",
      value: function _shouldReattach(originalEvent) {
        return this.jpc.isReattach() || this.jpc._forceReattach || !functionChain(true, false, [[this.jpc.endpoints[0], IS_DETACH_ALLOWED, [this.jpc]], [this.jpc.endpoints[1], IS_DETACH_ALLOWED, [this.jpc]], [this.jpc, IS_DETACH_ALLOWED, [this.jpc]], [this.instance, CHECK_CONDITION, [INTERCEPT_BEFORE_DETACH, this.jpc]]]);
      }
    }, {
      key: "_discard",
      value: function _discard(idx, originalEvent) {
        if (this.jpc.pending) {
          this.instance.fire(EVENT_CONNECTION_ABORT, this.jpc, originalEvent);
        } else {
          if (idx === 0) {
            this.jpc.source = this.jpc.suspendedEndpoint.element;
            this.jpc.sourceId = this.jpc.suspendedEndpoint.elementId;
          } else {
            this.jpc.target = this.jpc.suspendedEndpoint.element;
            this.jpc.targetId = this.jpc.suspendedEndpoint.elementId;
          }
          this.jpc.endpoints[idx] = this.jpc.suspendedEndpoint;
        }
        if (this.floatingEndpoint) {
          this.floatingEndpoint.detachFromConnection(this.jpc);
        }
        this.instance.deleteConnection(this.jpc, {
          originalEvent: originalEvent,
          force: true
        });
      }
    }, {
      key: "_drop",
      value: function _drop(dropEndpoint, idx, originalEvent, optionalData) {
        this.jpc.endpoints[idx].detachFromConnection(this.jpc);
        if (this.jpc.suspendedEndpoint) {
          this.jpc.suspendedEndpoint.detachFromConnection(this.jpc);
        }
        this.jpc.endpoints[idx] = dropEndpoint;
        dropEndpoint.addConnection(this.jpc);
        if (this.jpc.suspendedEndpoint) {
          var suspendedElementId = this.jpc.suspendedEndpoint.elementId;
          this.instance.fireMoveEvent({
            index: idx,
            originalSourceId: idx === 0 ? suspendedElementId : this.jpc.sourceId,
            newSourceId: idx === 0 ? dropEndpoint.elementId : this.jpc.sourceId,
            originalTargetId: idx === 1 ? suspendedElementId : this.jpc.targetId,
            newTargetId: idx === 1 ? dropEndpoint.elementId : this.jpc.targetId,
            originalEndpoint: this.jpc.suspendedEndpoint,
            connection: this.jpc,
            newEndpoint: dropEndpoint
          }, originalEvent);
        }
        if (idx === 1) {
          this.instance.sourceOrTargetChanged(this.floatingId, this.jpc.targetId, this.jpc, this.jpc.target, 1);
        } else {
          this.instance.sourceOrTargetChanged(this.floatingId, this.jpc.sourceId, this.jpc, this.jpc.source, 0);
        }
        if (this.jpc.endpoints[0].finalEndpoint) {
          var _toDelete = this.jpc.endpoints[0];
          _toDelete.detachFromConnection(this.jpc);
          this.jpc.endpoints[0] = this.jpc.endpoints[0].finalEndpoint;
          this.jpc.endpoints[0].addConnection(this.jpc);
        }
        if (isObject(optionalData)) {
          this.jpc.mergeData(optionalData);
        }
        if (this._originalAnchorSpec) {
          this.jpc.endpoints[0].setAnchor(this._originalAnchorSpec);
          this._originalAnchorSpec = null;
        }
        this.instance._finaliseConnection(this.jpc, null, originalEvent);
        this.instance.setHover(this.jpc, false);
        this.instance.revalidate(this.jpc.endpoints[0].element);
      }
    }, {
      key: "_registerFloatingConnection",
      value: function _registerFloatingConnection(info, conn, ep) {
        this.floatingConnections[info.id] = conn;
        addToDictionary(this.instance.endpointsByElement, info.id, ep);
      }
    }, {
      key: "_getFloatingAnchorIndex",
      value: function _getFloatingAnchorIndex() {
        return this.floatingIndex == null ? 1 : this.floatingIndex;
      }
    }]);
    return EndpointDragHandler;
  }();

  var GroupDragHandler = function (_ElementDragHandler) {
    _inherits$9(GroupDragHandler, _ElementDragHandler);
    var _super = _createSuper$9(GroupDragHandler);
    function GroupDragHandler(instance, dragSelection) {
      var _this;
      _classCallCheck$e(this, GroupDragHandler);
      _this = _super.call(this, instance, dragSelection);
      _this.instance = instance;
      _this.dragSelection = dragSelection;
      _defineProperty$d(_assertThisInitialized$9(_this), "selector", [">", SELECTOR_GROUP, SELECTOR_MANAGED_ELEMENT].join(" "));
      _defineProperty$d(_assertThisInitialized$9(_this), "doRevalidate", void 0);
      _this.doRevalidate = _this._revalidate.bind(_assertThisInitialized$9(_this));
      return _this;
    }
    _createClass$e(GroupDragHandler, [{
      key: "reset",
      value: function reset() {
        this.drag.off(EVENT_REVERT, this.doRevalidate);
      }
    }, {
      key: "_revalidate",
      value: function _revalidate(el) {
        this.instance.revalidate(el);
      }
    }, {
      key: "init",
      value: function init(drag) {
        this.drag = drag;
        drag.on(EVENT_REVERT, this.doRevalidate);
      }
    }, {
      key: "useGhostProxy",
      value: function useGhostProxy(container, dragEl) {
        var group = dragEl._jsPlumbParentGroup;
        return group == null ? false : group.ghost === true;
      }
    }, {
      key: "makeGhostProxy",
      value: function makeGhostProxy(el) {
        var jel = el;
        var newEl = jel.cloneNode(true);
        newEl._jsPlumbParentGroup = jel._jsPlumbParentGroup;
        return newEl;
      }
    }]);
    return GroupDragHandler;
  }(ElementDragHandler);

  var HTMLElementOverlay = function () {
    function HTMLElementOverlay(instance, overlay) {
      _classCallCheck$e(this, HTMLElementOverlay);
      this.instance = instance;
      this.overlay = overlay;
      _defineProperty$d(this, "htmlElementOverlay", void 0);
      this.htmlElementOverlay = overlay;
    }
    _createClass$e(HTMLElementOverlay, null, [{
      key: "getElement",
      value: function getElement(o, component, elementCreator) {
        if (o.canvas == null) {
          if (elementCreator && component) {
            o.canvas = elementCreator(component);
            var cls = o.instance.overlayClass + " " + (o.cssClass ? o.cssClass : "");
            o.instance.addClass(o.canvas, cls);
          } else {
            o.canvas = createElement(ELEMENT_DIV, {}, o.instance.overlayClass + " " + (o.cssClass ? o.cssClass : ""));
          }
          o.instance.setAttribute(o.canvas, "jtk-overlay-id", o.id);
          for (var att in o.attributes) {
            o.instance.setAttribute(o.canvas, att, o.attributes[att]);
          }
          o.canvas.style.position = ABSOLUTE$1;
          o.instance._appendElement(o.canvas, o.instance.getContainer());
          o.instance.getId(o.canvas);
          var ts = "translate(-50%, -50%)";
          o.canvas.style.webkitTransform = ts;
          o.canvas.style.mozTransform = ts;
          o.canvas.style.msTransform = ts;
          o.canvas.style.oTransform = ts;
          o.canvas.style.transform = ts;
          if (!o.isVisible()) {
            o.canvas.style.display = NONE$1;
          }
          o.canvas.jtk = {
            overlay: o
          };
        }
        return o.canvas;
      }
    }, {
      key: "destroy",
      value: function destroy(o) {
        o.canvas && o.canvas.parentNode && o.canvas.parentNode.removeChild(o.canvas);
        delete o.canvas;
        delete o.cachedDimensions;
      }
    }, {
      key: "_getDimensions",
      value: function _getDimensions(o, forceRefresh) {
        if (o.cachedDimensions == null || forceRefresh) {
          o.cachedDimensions = {
            w: 1,
            h: 1
          };
        }
        return o.cachedDimensions;
      }
    }]);
    return HTMLElementOverlay;
  }();

  var SVGElementOverlay = function (_Overlay) {
    _inherits$9(SVGElementOverlay, _Overlay);
    var _super = _createSuper$9(SVGElementOverlay);
    function SVGElementOverlay() {
      var _this;
      _classCallCheck$e(this, SVGElementOverlay);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty$d(_assertThisInitialized$9(_this), "path", void 0);
      return _this;
    }
    _createClass$e(SVGElementOverlay, null, [{
      key: "ensurePath",
      value: function ensurePath(o) {
        if (o.path == null) {
          var atts = extend({
            "jtk-overlay-id": o.id
          }, o.attributes);
          o.path = _node(ELEMENT_PATH, atts);
          var parent = null;
          if (o.component instanceof Connection) {
            var connector = o.component.connector;
            parent = connector != null ? connector.canvas : null;
          } else if (o.component instanceof Endpoint) {
            var endpoint = o.component.endpoint;
            parent = endpoint != null ? endpoint.svg : endpoint;
          }
          if (parent != null) {
            _appendAtIndex(parent, o.path, 1);
          }
          var cls = o.instance.overlayClass + " " + (o.cssClass ? o.cssClass : "");
          o.instance.addClass(o.path, cls);
          o.path.jtk = {
            overlay: o
          };
        }
        return o.path;
      }
    }, {
      key: "paint",
      value: function paint(o, path, params, extents) {
        this.ensurePath(o);
        var offset = [0, 0];
        if (extents.xmin < 0) {
          offset[0] = -extents.xmin;
        }
        if (extents.ymin < 0) {
          offset[1] = -extents.ymin;
        }
        var a = {
          "d": path,
          stroke: params.stroke ? params.stroke : null,
          fill: params.fill ? params.fill : null,
          transform: "translate(" + offset[0] + "," + offset[1] + ")",
          "pointer-events": "visibleStroke"
        };
        _attr(o.path, a);
      }
    }, {
      key: "destroy",
      value: function destroy(o, force) {
        var _o = o;
        if (_o.path != null && _o.path.parentNode != null) {
          _o.path.parentNode.removeChild(_o.path);
        }
        if (_o.bgPath != null && _o.bgPath.parentNode != null) {
          _o.bgPath.parentNode.removeChild(_o.bgPath);
        }
        delete _o.path;
        delete _o.bgPath;
      }
    }]);
    return SVGElementOverlay;
  }(Overlay);

  var SvgComponent = function () {
    function SvgComponent() {
      _classCallCheck$e(this, SvgComponent);
    }
    _createClass$e(SvgComponent, null, [{
      key: "paint",
      value: function paint(connector, useDivWrapper, paintStyle, extents) {
        if (paintStyle != null) {
          var xy = [connector.x, connector.y],
              wh = [connector.w, connector.h],
              p;
          if (extents != null) {
            if (extents.xmin < 0) {
              xy[0] += extents.xmin;
            }
            if (extents.ymin < 0) {
              xy[1] += extents.ymin;
            }
            wh[0] = extents.xmax + (extents.xmin < 0 ? -extents.xmin : 0);
            wh[1] = extents.ymax + (extents.ymin < 0 ? -extents.ymin : 0);
          }
          if (isFinite(wh[0]) && isFinite(wh[1])) {
            if (useDivWrapper) {
              _size(connector.canvas, xy[0], xy[1], wh[0], wh[1]);
              xy[0] = 0;
              xy[1] = 0;
              p = _pos([0, 0]);
              _attr(connector.svg, {
                "style": p,
                "width": "" + (wh[0] || 0),
                "height": "" + (wh[1] || 0)
              });
            } else {
              p = _pos([xy[0], xy[1]]);
              _attr(connector.canvas, {
                "style": p,
                "width": "" + (wh[0] || 0),
                "height": "" + (wh[1] || 0)
              });
            }
          }
        }
      }
    }]);
    return SvgComponent;
  }();

  function paintSvgConnector(instance, connector, paintStyle, extents) {
    getConnectorElement(instance, connector);
    SvgComponent.paint(connector, false, paintStyle, extents);
    var p = "",
        offset = [0, 0];
    if (extents.xmin < 0) {
      offset[0] = -extents.xmin;
    }
    if (extents.ymin < 0) {
      offset[1] = -extents.ymin;
    }
    if (connector.segments.length > 0) {
      p = instance.getPathData(connector);
      var a = {
        d: p,
        transform: "translate(" + offset[0] + "," + offset[1] + ")",
        "pointer-events": "visibleStroke"
      },
          outlineStyle = null;
      if (paintStyle.outlineStroke) {
        var outlineWidth = paintStyle.outlineWidth || 1,
            outlineStrokeWidth = paintStyle.strokeWidth + 2 * outlineWidth;
        outlineStyle = extend({}, paintStyle);
        outlineStyle.stroke = paintStyle.outlineStroke;
        outlineStyle.strokeWidth = outlineStrokeWidth;
        if (connector.bgPath == null) {
          connector.bgPath = _node(ELEMENT_PATH, a);
          instance.addClass(connector.bgPath, instance.connectorOutlineClass);
          _appendAtIndex(connector.canvas, connector.bgPath, 0);
        } else {
          _attr(connector.bgPath, a);
        }
        _applyStyles(connector.canvas, connector.bgPath, outlineStyle);
      }
      var cany = connector;
      if (cany.path == null) {
        cany.path = _node(ELEMENT_PATH, a);
        _appendAtIndex(cany.canvas, cany.path, paintStyle.outlineStroke ? 1 : 0);
      } else {
        if (cany.path.parentNode !== cany.canvas) {
          _appendAtIndex(cany.canvas, cany.path, paintStyle.outlineStroke ? 1 : 0);
        }
        _attr(connector.path, a);
      }
      _applyStyles(connector.canvas, connector.path, paintStyle);
    }
  }
  function getConnectorElement(instance, c) {
    if (c.canvas != null) {
      return c.canvas;
    } else {
      var svg = _node(ELEMENT_SVG, {
        "style": "",
        "width": "0",
        "height": "0",
        "pointer-events": NONE$1,
        "position": ABSOLUTE$1
      });
      c.canvas = svg;
      instance._appendElement(c.canvas, instance.getContainer());
      if (c.cssClass != null) {
        instance.addClass(svg, c.cssClass);
      }
      instance.addClass(svg, instance.connectorClass);
      svg.jtk = svg.jtk || {};
      svg.jtk.connector = c;
      return svg;
    }
  }

  var SvgEndpoint = function () {
    function SvgEndpoint() {
      _classCallCheck$e(this, SvgEndpoint);
    }
    _createClass$e(SvgEndpoint, null, [{
      key: "getEndpointElement",
      value: function getEndpointElement(ep) {
        if (ep.canvas != null) {
          return ep.canvas;
        } else {
          var svg = _node(ELEMENT_SVG, {
            "style": "",
            "width": "0",
            "height": "0",
            "pointer-events": NONE$1,
            "position": ABSOLUTE$1
          });
          ep.svg = svg;
          var canvas = createElement(ELEMENT_DIV, {
            position: ABSOLUTE$1
          });
          ep.canvas = canvas;
          var classes = ep.classes.join(" ");
          ep.instance.addClass(canvas, classes);
          var scopes = ep.endpoint.scope.split(/\s/);
          for (var i = 0; i < scopes.length; i++) {
            ep.instance.setAttribute(canvas, ATTRIBUTE_SCOPE_PREFIX + scopes[i], TRUE$1);
          }
          if (!ep.instance._suspendDrawing) {
            _size(canvas, 0, 0, 1, 1);
          }
          ep.instance._appendElement(canvas, ep.instance.getContainer());
          canvas.appendChild(svg);
          if (ep.cssClass != null) {
            ep.instance.addClass(canvas, ep.cssClass);
          }
          ep.instance.addClass(canvas, ep.instance.endpointClass);
          canvas.jtk = canvas.jtk || {};
          canvas.jtk.endpoint = ep.endpoint;
          canvas.style.display = ep.endpoint.visible !== false ? BLOCK : NONE$1;
          return canvas;
        }
      }
    }, {
      key: "paint",
      value: function paint(ep, handlers, paintStyle) {
        if (ep.endpoint.deleted !== true) {
          this.getEndpointElement(ep);
          SvgComponent.paint(ep, true, paintStyle);
          var s = extend({}, paintStyle);
          if (s.outlineStroke) {
            s.stroke = s.outlineStroke;
          }
          if (ep.node == null) {
            ep.node = handlers.makeNode(ep, s);
            ep.svg.appendChild(ep.node);
          } else if (handlers.updateNode != null) {
            handlers.updateNode(ep, ep.node);
          }
          _applyStyles(ep.canvas, ep.node, s);
        }
      }
    }]);
    return SvgEndpoint;
  }();

  var endpointMap = {};
  function registerEndpointRenderer(name, fns) {
    endpointMap[name] = fns;
  }
  function getPositionOnElement(evt, el, zoom) {
    var jel = el;
    var box = _typeof$1(el.getBoundingClientRect) !== UNDEFINED ? el.getBoundingClientRect() : {
      left: 0,
      top: 0,
      width: 0,
      height: 0
    },
        body = document.body,
        docElem = document.documentElement,
        scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop,
        scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft,
        clientTop = docElem.clientTop || body.clientTop || 0,
        clientLeft = docElem.clientLeft || body.clientLeft || 0,
        pst = 0,
        psl = 0,
        top = box.top + scrollTop - clientTop + pst * zoom,
        left = box.left + scrollLeft - clientLeft + psl * zoom,
        cl = pageLocation(evt),
        w = box.width || jel.offsetWidth * zoom,
        h = box.height || jel.offsetHeight * zoom,
        x = (cl.x - left) / w,
        y = (cl.y - top) / h;
    return {
      x: x,
      y: y
    };
  }
  function isSVGElementOverlay(o) {
    return isArrowOverlay(o) || isDiamondOverlay(o) || isPlainArrowOverlay(o);
  }
  function setVisible(component, v) {
    if (component.canvas) {
      component.canvas.style.display = v ? "block" : "none";
    }
  }
  function cleanup(component) {
    if (component.canvas) {
      component.canvas.parentNode.removeChild(component.canvas);
    }
    delete component.canvas;
    delete component.svg;
  }
  function getEndpointCanvas(ep) {
    return ep.canvas;
  }
  function getLabelElement(o) {
    return HTMLElementOverlay.getElement(o);
  }
  function getCustomElement(o) {
    return HTMLElementOverlay.getElement(o, o.component, function (c) {
      var el = o.create(c);
      o.instance.addClass(el, o.instance.overlayClass);
      return el;
    });
  }
  function groupDragConstrain(desiredLoc, dragEl, constrainRect, size) {
    var x = desiredLoc.x,
        y = desiredLoc.y;
    if (dragEl._jsPlumbParentGroup && dragEl._jsPlumbParentGroup.constrain) {
      x = Math.max(desiredLoc.x, 0);
      y = Math.max(desiredLoc.y, 0);
      x = Math.min(x, constrainRect.w - size.w);
      y = Math.min(y, constrainRect.h - size.h);
    }
    return {
      x: x,
      y: y
    };
  }
  var BrowserJsPlumbInstance = function (_JsPlumbInstance) {
    _inherits$9(BrowserJsPlumbInstance, _JsPlumbInstance);
    var _super = _createSuper$9(BrowserJsPlumbInstance);
    function BrowserJsPlumbInstance(_instanceIndex, defaults) {
      var _this;
      _classCallCheck$e(this, BrowserJsPlumbInstance);
      _this = _super.call(this, _instanceIndex, defaults);
      _this._instanceIndex = _instanceIndex;
      _defineProperty$d(_assertThisInitialized$9(_this), "dragSelection", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "dragManager", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "_connectorClick", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "_connectorDblClick", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "_connectorTap", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "_connectorDblTap", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "_endpointClick", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "_endpointDblClick", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "_overlayClick", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "_overlayDblClick", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "_overlayTap", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "_overlayDblTap", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "_connectorMouseover", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "_connectorMouseout", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "_endpointMouseover", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "_endpointMouseout", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "_connectorContextmenu", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "_connectorMousedown", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "_connectorMouseup", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "_endpointMousedown", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "_endpointMouseup", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "_overlayMouseover", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "_overlayMouseout", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "_elementClick", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "_elementTap", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "_elementDblTap", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "_elementMouseenter", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "_elementMouseexit", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "_elementMousemove", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "_elementMouseup", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "_elementMousedown", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "_elementContextmenu", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "eventManager", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "draggingClass", "jtk-dragging");
      _defineProperty$d(_assertThisInitialized$9(_this), "elementDraggingClass", "jtk-element-dragging");
      _defineProperty$d(_assertThisInitialized$9(_this), "hoverClass", "jtk-hover");
      _defineProperty$d(_assertThisInitialized$9(_this), "sourceElementDraggingClass", "jtk-source-element-dragging");
      _defineProperty$d(_assertThisInitialized$9(_this), "targetElementDraggingClass", "jtk-target-element-dragging");
      _defineProperty$d(_assertThisInitialized$9(_this), "hoverSourceClass", "jtk-source-hover");
      _defineProperty$d(_assertThisInitialized$9(_this), "hoverTargetClass", "jtk-target-hover");
      _defineProperty$d(_assertThisInitialized$9(_this), "dragSelectClass", "jtk-drag-select");
      _defineProperty$d(_assertThisInitialized$9(_this), "managedElementsSelector", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "elementsDraggable", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "elementDragHandler", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "groupDragOptions", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "elementDragOptions", void 0);
      _defineProperty$d(_assertThisInitialized$9(_this), "svg", {
        node: function node(name, attributes) {
          return _node(name, attributes);
        },
        attr: function attr(node, attributes) {
          return _attr(node, attributes);
        },
        pos: function pos(d) {
          return _pos(d);
        }
      });
      _this.elementsDraggable = defaults && defaults.elementsDraggable !== false;
      _this.managedElementsSelector = defaults ? defaults.managedElementsSelector || SELECTOR_MANAGED_ELEMENT : SELECTOR_MANAGED_ELEMENT;
      _this.eventManager = new EventManager();
      _this.dragSelection = new DragSelection(_assertThisInitialized$9(_this));
      _this.dragManager = new DragManager(_assertThisInitialized$9(_this), _this.dragSelection);
      _this.dragManager.addHandler(new EndpointDragHandler(_assertThisInitialized$9(_this)));
      _this.groupDragOptions = {
        constrainFunction: groupDragConstrain
      };
      _this.dragManager.addHandler(new GroupDragHandler(_assertThisInitialized$9(_this), _this.dragSelection), _this.groupDragOptions);
      _this.elementDragHandler = new ElementDragHandler(_assertThisInitialized$9(_this), _this.dragSelection);
      _this.elementDragOptions = defaults && defaults.dragOptions || {};
      _this.dragManager.addHandler(_this.elementDragHandler, _this.elementDragOptions);
      if (defaults && defaults.dragOptions && defaults.dragOptions.filter) {
        _this.dragManager.addFilter(defaults.dragOptions.filter);
      }
      var _connClick = function _connClick(event, e) {
        if (!e.defaultPrevented && e._jsPlumbOverlay == null) {
          var connectorElement = findParent(getEventSource(e), SELECTOR_CONNECTOR, this.getContainer(), true);
          this.fire(event, connectorElement.jtk.connector.connection, e);
        }
      };
      _this._connectorClick = _connClick.bind(_assertThisInitialized$9(_this), EVENT_CONNECTION_CLICK);
      _this._connectorDblClick = _connClick.bind(_assertThisInitialized$9(_this), EVENT_CONNECTION_DBL_CLICK);
      _this._connectorTap = _connClick.bind(_assertThisInitialized$9(_this), EVENT_CONNECTION_TAP);
      _this._connectorDblTap = _connClick.bind(_assertThisInitialized$9(_this), EVENT_CONNECTION_DBL_TAP);
      var _connectorHover = function _connectorHover(state, e) {
        var el = getEventSource(e).parentNode;
        if (el.jtk && el.jtk.connector) {
          var connector = el.jtk.connector;
          var connection = connector.connection;
          this.setConnectorHover(connector, state);
          if (state) {
            this.addClass(connection.source, this.hoverSourceClass);
            this.addClass(connection.target, this.hoverTargetClass);
          } else {
            this.removeClass(connection.source, this.hoverSourceClass);
            this.removeClass(connection.target, this.hoverTargetClass);
          }
          this.fire(state ? EVENT_CONNECTION_MOUSEOVER : EVENT_CONNECTION_MOUSEOUT, el.jtk.connector.connection, e);
        }
      };
      _this._connectorMouseover = _connectorHover.bind(_assertThisInitialized$9(_this), true);
      _this._connectorMouseout = _connectorHover.bind(_assertThisInitialized$9(_this), false);
      var _connectorMouseupdown = function _connectorMouseupdown(state, e) {
        var el = getEventSource(e).parentNode;
        if (el.jtk && el.jtk.connector) {
          this.fire(state ? EVENT_CONNECTION_MOUSEUP : EVENT_CONNECTION_MOUSEDOWN, el.jtk.connector.connection, e);
        }
      };
      _this._connectorMouseup = _connectorMouseupdown.bind(_assertThisInitialized$9(_this), true);
      _this._connectorMousedown = _connectorMouseupdown.bind(_assertThisInitialized$9(_this), false);
      _this._connectorContextmenu = function (e) {
        var el = getEventSource(e).parentNode;
        if (el.jtk && el.jtk.connector) {
          this.fire(EVENT_CONNECTION_CONTEXTMENU, el.jtk.connector.connection, e);
        }
      }.bind(_assertThisInitialized$9(_this));
      var _epClick = function _epClick(event, e, endpointElement) {
        if (!e.defaultPrevented && e._jsPlumbOverlay == null) {
          this.fire(event, endpointElement.jtk.endpoint, e);
        }
      };
      _this._endpointClick = _epClick.bind(_assertThisInitialized$9(_this), EVENT_ENDPOINT_CLICK);
      _this._endpointDblClick = _epClick.bind(_assertThisInitialized$9(_this), EVENT_ENDPOINT_DBL_CLICK);
      var _endpointHover = function _endpointHover(state, e) {
        var el = getEventSource(e);
        if (el.jtk && el.jtk.endpoint) {
          this.setEndpointHover(el.jtk.endpoint, state);
          this.fire(state ? EVENT_ENDPOINT_MOUSEOVER : EVENT_ENDPOINT_MOUSEOUT, el.jtk.endpoint, e);
        }
      };
      _this._endpointMouseover = _endpointHover.bind(_assertThisInitialized$9(_this), true);
      _this._endpointMouseout = _endpointHover.bind(_assertThisInitialized$9(_this), false);
      var _endpointMouseupdown = function _endpointMouseupdown(state, e) {
        var el = getEventSource(e);
        if (el.jtk && el.jtk.endpoint) {
          this.fire(state ? EVENT_ENDPOINT_MOUSEUP : EVENT_ENDPOINT_MOUSEDOWN, el.jtk.endpoint, e);
        }
      };
      _this._endpointMouseup = _endpointMouseupdown.bind(_assertThisInitialized$9(_this), true);
      _this._endpointMousedown = _endpointMouseupdown.bind(_assertThisInitialized$9(_this), false);
      var _oClick = function (method, e) {
        var overlayElement = findParent(getEventSource(e), SELECTOR_OVERLAY, this.getContainer(), true);
        var overlay = overlayElement.jtk.overlay;
        if (overlay) {
          this.fireOverlayMethod(overlay, method, e);
        }
      }.bind(_assertThisInitialized$9(_this));
      _this._overlayClick = _oClick.bind(_assertThisInitialized$9(_this), EVENT_CLICK);
      _this._overlayDblClick = _oClick.bind(_assertThisInitialized$9(_this), EVENT_DBL_CLICK);
      _this._overlayTap = _oClick.bind(_assertThisInitialized$9(_this), EVENT_TAP);
      _this._overlayDblTap = _oClick.bind(_assertThisInitialized$9(_this), EVENT_DBL_TAP);
      var _overlayHover = function _overlayHover(state, e) {
        var overlayElement = findParent(getEventSource(e), SELECTOR_OVERLAY, this.getContainer(), true);
        var overlay = overlayElement.jtk.overlay;
        if (overlay) {
          this.setOverlayHover(overlay, state);
        }
      };
      _this._overlayMouseover = _overlayHover.bind(_assertThisInitialized$9(_this), true);
      _this._overlayMouseout = _overlayHover.bind(_assertThisInitialized$9(_this), false);
      var _elementClick = function _elementClick(event, e, target) {
        if (!e.defaultPrevented) {
          this.fire(e.detail === 1 ? EVENT_ELEMENT_CLICK : EVENT_ELEMENT_DBL_CLICK, target, e);
        }
      };
      _this._elementClick = _elementClick.bind(_assertThisInitialized$9(_this), EVENT_ELEMENT_CLICK);
      var _elementTap = function _elementTap(event, e, target) {
        if (!e.defaultPrevented) {
          this.fire(EVENT_ELEMENT_TAP, target, e);
        }
      };
      _this._elementTap = _elementTap.bind(_assertThisInitialized$9(_this), EVENT_ELEMENT_TAP);
      var _elementDblTap = function _elementDblTap(event, e, target) {
        if (!e.defaultPrevented) {
          this.fire(EVENT_ELEMENT_DBL_TAP, target, e);
        }
      };
      _this._elementDblTap = _elementDblTap.bind(_assertThisInitialized$9(_this), EVENT_ELEMENT_DBL_TAP);
      var _elementHover = function _elementHover(state, e) {
        this.fire(state ? EVENT_ELEMENT_MOUSE_OVER : EVENT_ELEMENT_MOUSE_OUT, getEventSource(e), e);
      };
      _this._elementMouseenter = _elementHover.bind(_assertThisInitialized$9(_this), true);
      _this._elementMouseexit = _elementHover.bind(_assertThisInitialized$9(_this), false);
      _this._elementMousemove = function (e) {
        this.fire(EVENT_ELEMENT_MOUSE_MOVE, getEventSource(e), e);
      }.bind(_assertThisInitialized$9(_this));
      _this._elementMouseup = function (e) {
        this.fire(EVENT_ELEMENT_MOUSE_UP, getEventSource(e), e);
      }.bind(_assertThisInitialized$9(_this));
      _this._elementMousedown = function (e) {
        this.fire(EVENT_ELEMENT_MOUSE_DOWN, getEventSource(e), e);
      }.bind(_assertThisInitialized$9(_this));
      _this._elementContextmenu = function (e) {
        this.fire(EVENT_ELEMENT_CONTEXTMENU, getEventSource(e), e);
      }.bind(_assertThisInitialized$9(_this));
      _this._attachEventDelegates();
      return _this;
    }
    _createClass$e(BrowserJsPlumbInstance, [{
      key: "fireOverlayMethod",
      value: function fireOverlayMethod(overlay, event, e) {
        var stem = overlay.component instanceof Connection ? CONNECTION : ENDPOINT;
        var mappedEvent = compoundEvent(stem, event)
        ;
        e._jsPlumbOverlay = overlay;
        overlay.fire(event, {
          e: e,
          overlay: overlay
        });
        this.fire(mappedEvent, overlay.component, e);
      }
    }, {
      key: "addDragFilter",
      value: function addDragFilter(filter, exclude) {
        this.dragManager.addFilter(filter, exclude);
      }
    }, {
      key: "removeDragFilter",
      value: function removeDragFilter(filter) {
        this.dragManager.removeFilter(filter);
      }
    }, {
      key: "setDragGrid",
      value: function setDragGrid(grid) {
        this.dragManager.setOption(this.elementDragHandler, {
          grid: grid
        });
      }
    }, {
      key: "_removeElement",
      value: function _removeElement(element) {
        element.parentNode && element.parentNode.removeChild(element);
      }
    }, {
      key: "_appendElement",
      value: function _appendElement(el, parent) {
        if (parent) {
          parent.appendChild(el);
        }
      }
    }, {
      key: "_getAssociatedElements",
      value: function _getAssociatedElements(el) {
        var a = [];
        if (el.nodeType !== 3 && el.nodeType !== 8) {
          var els = el.querySelectorAll(SELECTOR_MANAGED_ELEMENT);
          Array.prototype.push.apply(a, els);
        }
        return a.filter(function (_a) {
          return _a.nodeType !== 3 && _a.nodeType !== 8;
        });
      }
    }, {
      key: "shouldFireEvent",
      value: function shouldFireEvent(event, value, originalEvent) {
        return true;
      }
    }, {
      key: "getClass",
      value: function getClass$1(el) {
        return getClass(el);
      }
    }, {
      key: "addClass",
      value: function addClass$1(el, clazz) {
        addClass(el, clazz);
      }
    }, {
      key: "hasClass",
      value: function hasClass$1(el, clazz) {
        return hasClass(el, clazz);
      }
    }, {
      key: "removeClass",
      value: function removeClass$1(el, clazz) {
        removeClass(el, clazz);
      }
    }, {
      key: "toggleClass",
      value: function toggleClass$1(el, clazz) {
        toggleClass(el, clazz);
      }
    }, {
      key: "setAttribute",
      value: function setAttribute(el, name, value) {
        el.setAttribute(name, value);
      }
    }, {
      key: "getAttribute",
      value: function getAttribute(el, name) {
        return el.getAttribute(name);
      }
    }, {
      key: "setAttributes",
      value: function setAttributes(el, atts) {
        for (var i in atts) {
          el.setAttribute(i, atts[i]);
        }
      }
    }, {
      key: "removeAttribute",
      value: function removeAttribute(el, attName) {
        el.removeAttribute && el.removeAttribute(attName);
      }
    }, {
      key: "on",
      value: function on(el, event, callbackOrSelector, callback) {
        var _this2 = this;
        var _one = function _one(_el) {
          if (callback == null) {
            _this2.eventManager.on(_el, event, callbackOrSelector);
          } else {
            _this2.eventManager.on(_el, event, callbackOrSelector, callback);
          }
        };
        if (isNodeList(el)) {
          forEach(el, function (el) {
            return _one(el);
          });
        } else {
          _one(el);
        }
        return this;
      }
    }, {
      key: "off",
      value: function off(el, event, callback) {
        var _this3 = this;
        if (isNodeList(el)) {
          forEach(el, function (_el) {
            return _this3.eventManager.off(_el, event, callback);
          });
        } else {
          this.eventManager.off(el, event, callback);
        }
        return this;
      }
    }, {
      key: "trigger",
      value: function trigger(el, event, originalEvent, payload, detail) {
        this.eventManager.trigger(el, event, originalEvent, payload, detail);
      }
    }, {
      key: "getOffsetRelativeToRoot",
      value: function getOffsetRelativeToRoot(el) {
        return offsetRelativeToRoot(el);
      }
    }, {
      key: "getOffset",
      value: function getOffset(el) {
        var jel = el;
        var container = this.getContainer();
        var out = {
          x: jel.offsetLeft,
          y: jel.offsetTop
        },
            op = el !== container && jel.offsetParent !== container ? jel.offsetParent : null,
            _maybeAdjustScroll = function _maybeAdjustScroll(offsetParent) {
          if (offsetParent != null && offsetParent !== document.body && (offsetParent.scrollTop > 0 || offsetParent.scrollLeft > 0)) {
            out.x -= offsetParent.scrollLeft;
            out.y -= offsetParent.scrollTop;
          }
        };
        while (op != null) {
          out.x += op.offsetLeft;
          out.y += op.offsetTop;
          _maybeAdjustScroll(op);
          op = op.offsetParent === container ? null : op.offsetParent;
        }
        if (container != null && (container.scrollTop > 0 || container.scrollLeft > 0)) {
          var pp = jel.offsetParent != null ? this.getStyle(jel.offsetParent, PROPERTY_POSITION) : STATIC,
              p = this.getStyle(jel, PROPERTY_POSITION);
          if (p !== ABSOLUTE$1 && p !== FIXED && pp !== ABSOLUTE$1 && pp !== FIXED) {
            out.x -= container.scrollLeft;
            out.y -= container.scrollTop;
          }
        }
        return out;
      }
    }, {
      key: "getSize",
      value: function getSize(el) {
        return size(el);
      }
    }, {
      key: "getStyle",
      value: function getStyle(el, prop) {
        if (_typeof$1(window.getComputedStyle) !== UNDEFINED) {
          return getComputedStyle(el, null).getPropertyValue(prop);
        } else {
          return el.currentStyle[prop];
        }
      }
    }, {
      key: "getGroupContentArea",
      value: function getGroupContentArea(group) {
        var da = this.getSelector(group.el, SELECTOR_GROUP_CONTAINER);
        return da && da.length > 0 ? da[0] : group.el;
      }
    }, {
      key: "getSelector",
      value: function getSelector(ctx, spec) {
        var sel = null;
        if (arguments.length === 1) {
          if (!isString(ctx)) {
            var nodeList = document.createDocumentFragment();
            nodeList.appendChild(ctx);
            return fromArray(nodeList.childNodes);
          }
          sel = fromArray(document.querySelectorAll(ctx));
        } else {
          sel = fromArray(ctx.querySelectorAll(spec));
        }
        return sel;
      }
    }, {
      key: "setPosition",
      value: function setPosition(el, p) {
        var jel = el;
        jel.style.left = p.x + "px";
        jel.style.top = p.y + "px";
      }
    }, {
      key: "setDraggable",
      value: function setDraggable(element, draggable) {
        if (draggable) {
          this.removeAttribute(element, ATTRIBUTE_NOT_DRAGGABLE);
        } else {
          this.setAttribute(element, ATTRIBUTE_NOT_DRAGGABLE, TRUE$1);
        }
      }
    }, {
      key: "isDraggable",
      value: function isDraggable(el) {
        var d = this.getAttribute(el, ATTRIBUTE_NOT_DRAGGABLE);
        return d == null || d === FALSE$1;
      }
    }, {
      key: "toggleDraggable",
      value: function toggleDraggable(el) {
        var state = this.isDraggable(el);
        this.setDraggable(el, !state);
        return !state;
      }
    }, {
      key: "_attachEventDelegates",
      value: function _attachEventDelegates() {
        var currentContainer = this.getContainer();
        this.eventManager.on(currentContainer, EVENT_CLICK, SELECTOR_OVERLAY, this._overlayClick);
        this.eventManager.on(currentContainer, EVENT_DBL_CLICK, SELECTOR_OVERLAY, this._overlayDblClick);
        this.eventManager.on(currentContainer, EVENT_TAP, SELECTOR_OVERLAY, this._overlayTap);
        this.eventManager.on(currentContainer, EVENT_DBL_TAP, SELECTOR_OVERLAY, this._overlayDblTap);
        this.eventManager.on(currentContainer, EVENT_CLICK, SELECTOR_CONNECTOR, this._connectorClick);
        this.eventManager.on(currentContainer, EVENT_DBL_CLICK, SELECTOR_CONNECTOR, this._connectorDblClick);
        this.eventManager.on(currentContainer, EVENT_TAP, SELECTOR_CONNECTOR, this._connectorTap);
        this.eventManager.on(currentContainer, EVENT_DBL_TAP, SELECTOR_CONNECTOR, this._connectorDblTap);
        this.eventManager.on(currentContainer, EVENT_CLICK, SELECTOR_ENDPOINT, this._endpointClick);
        this.eventManager.on(currentContainer, EVENT_DBL_CLICK, SELECTOR_ENDPOINT, this._endpointDblClick);
        this.eventManager.on(currentContainer, EVENT_CLICK, this.managedElementsSelector, this._elementClick);
        this.eventManager.on(currentContainer, EVENT_TAP, this.managedElementsSelector, this._elementTap);
        this.eventManager.on(currentContainer, EVENT_DBL_TAP, this.managedElementsSelector, this._elementDblTap);
        this.eventManager.on(currentContainer, EVENT_MOUSEOVER, SELECTOR_CONNECTOR, this._connectorMouseover);
        this.eventManager.on(currentContainer, EVENT_MOUSEOUT, SELECTOR_CONNECTOR, this._connectorMouseout);
        this.eventManager.on(currentContainer, EVENT_CONTEXTMENU, SELECTOR_CONNECTOR, this._connectorContextmenu);
        this.eventManager.on(currentContainer, EVENT_MOUSEUP, SELECTOR_CONNECTOR, this._connectorMouseup);
        this.eventManager.on(currentContainer, EVENT_MOUSEDOWN, SELECTOR_CONNECTOR, this._connectorMousedown);
        this.eventManager.on(currentContainer, EVENT_MOUSEOVER, SELECTOR_ENDPOINT, this._endpointMouseover);
        this.eventManager.on(currentContainer, EVENT_MOUSEOUT, SELECTOR_ENDPOINT, this._endpointMouseout);
        this.eventManager.on(currentContainer, EVENT_MOUSEUP, SELECTOR_ENDPOINT, this._endpointMouseup);
        this.eventManager.on(currentContainer, EVENT_MOUSEDOWN, SELECTOR_ENDPOINT, this._endpointMousedown);
        this.eventManager.on(currentContainer, EVENT_MOUSEOVER, SELECTOR_OVERLAY, this._overlayMouseover);
        this.eventManager.on(currentContainer, EVENT_MOUSEOUT, SELECTOR_OVERLAY, this._overlayMouseout);
        this.eventManager.on(currentContainer, EVENT_MOUSEOVER, SELECTOR_MANAGED_ELEMENT, this._elementMouseenter);
        this.eventManager.on(currentContainer, EVENT_MOUSEOUT, SELECTOR_MANAGED_ELEMENT, this._elementMouseexit);
        this.eventManager.on(currentContainer, EVENT_MOUSEMOVE, SELECTOR_MANAGED_ELEMENT, this._elementMousemove);
        this.eventManager.on(currentContainer, EVENT_MOUSEUP, SELECTOR_MANAGED_ELEMENT, this._elementMouseup);
        this.eventManager.on(currentContainer, EVENT_MOUSEDOWN, SELECTOR_MANAGED_ELEMENT, this._elementMousedown);
        this.eventManager.on(currentContainer, EVENT_CONTEXTMENU, SELECTOR_MANAGED_ELEMENT, this._elementContextmenu);
      }
    }, {
      key: "_detachEventDelegates",
      value: function _detachEventDelegates() {
        var currentContainer = this.getContainer();
        if (currentContainer) {
          this.eventManager.off(currentContainer, EVENT_CLICK, this._connectorClick);
          this.eventManager.off(currentContainer, EVENT_DBL_CLICK, this._connectorDblClick);
          this.eventManager.off(currentContainer, EVENT_TAP, this._connectorTap);
          this.eventManager.off(currentContainer, EVENT_DBL_TAP, this._connectorDblTap);
          this.eventManager.off(currentContainer, EVENT_CLICK, this._endpointClick);
          this.eventManager.off(currentContainer, EVENT_DBL_CLICK, this._endpointDblClick);
          this.eventManager.off(currentContainer, EVENT_CLICK, this._overlayClick);
          this.eventManager.off(currentContainer, EVENT_DBL_CLICK, this._overlayDblClick);
          this.eventManager.off(currentContainer, EVENT_TAP, this._overlayTap);
          this.eventManager.off(currentContainer, EVENT_DBL_TAP, this._overlayDblTap);
          this.eventManager.off(currentContainer, EVENT_CLICK, this._elementClick);
          this.eventManager.off(currentContainer, EVENT_TAP, this._elementTap);
          this.eventManager.off(currentContainer, EVENT_DBL_TAP, this._elementDblTap);
          this.eventManager.off(currentContainer, EVENT_MOUSEOVER, this._connectorMouseover);
          this.eventManager.off(currentContainer, EVENT_MOUSEOUT, this._connectorMouseout);
          this.eventManager.off(currentContainer, EVENT_CONTEXTMENU, this._connectorContextmenu);
          this.eventManager.off(currentContainer, EVENT_MOUSEUP, this._connectorMouseup);
          this.eventManager.off(currentContainer, EVENT_MOUSEDOWN, this._connectorMousedown);
          this.eventManager.off(currentContainer, EVENT_MOUSEOVER, this._endpointMouseover);
          this.eventManager.off(currentContainer, EVENT_MOUSEOUT, this._endpointMouseout);
          this.eventManager.off(currentContainer, EVENT_MOUSEUP, this._endpointMouseup);
          this.eventManager.off(currentContainer, EVENT_MOUSEDOWN, this._endpointMousedown);
          this.eventManager.off(currentContainer, EVENT_MOUSEOVER, this._overlayMouseover);
          this.eventManager.off(currentContainer, EVENT_MOUSEOUT, this._overlayMouseout);
          this.eventManager.off(currentContainer, EVENT_MOUSEENTER, this._elementMouseenter);
          this.eventManager.off(currentContainer, EVENT_MOUSEEXIT, this._elementMouseexit);
          this.eventManager.off(currentContainer, EVENT_MOUSEMOVE, this._elementMousemove);
          this.eventManager.off(currentContainer, EVENT_MOUSEUP, this._elementMouseup);
          this.eventManager.off(currentContainer, EVENT_MOUSEDOWN, this._elementMousedown);
          this.eventManager.off(currentContainer, EVENT_CONTEXTMENU, this._elementContextmenu);
        }
      }
    }, {
      key: "setContainer",
      value: function setContainer(newContainer) {
        var _this4 = this;
        if (newContainer === document || newContainer === document.body) {
          throw new Error("Cannot set document or document.body as container element");
        }
        this._detachEventDelegates();
        var dragFilters;
        if (this.dragManager != null) {
          dragFilters = this.dragManager.reset();
        }
        this.setAttribute(newContainer, ATTRIBUTE_CONTAINER, uuid().replace("-", ""));
        var currentContainer = this.getContainer();
        if (currentContainer != null) {
          currentContainer.removeAttribute(ATTRIBUTE_CONTAINER);
          var children = fromArray(currentContainer.childNodes).filter(function (cn) {
            return cn != null && (_this4.hasClass(cn, CLASS_CONNECTOR) || _this4.hasClass(cn, CLASS_ENDPOINT) || _this4.hasClass(cn, CLASS_OVERLAY) || cn.getAttribute && cn.getAttribute(ATTRIBUTE_MANAGED) != null);
          });
          forEach(children, function (el) {
            newContainer.appendChild(el);
          });
        }
        _get$3(_getPrototypeOf$9(BrowserJsPlumbInstance.prototype), "setContainer", this).call(this, newContainer);
        if (this.eventManager != null) {
          this._attachEventDelegates();
        }
        if (this.dragManager != null) {
          this.dragManager.addHandler(new EndpointDragHandler(this));
          this.dragManager.addHandler(new GroupDragHandler(this, this.dragSelection), this.groupDragOptions);
          this.elementDragHandler = new ElementDragHandler(this, this.dragSelection);
          this.dragManager.addHandler(this.elementDragHandler, this.elementDragOptions);
          if (dragFilters != null) {
            this.dragManager.setFilters(dragFilters);
          }
        }
      }
    }, {
      key: "reset",
      value: function reset() {
        _get$3(_getPrototypeOf$9(BrowserJsPlumbInstance.prototype), "reset", this).call(this);
        var container = this.getContainer();
        var els = container.querySelectorAll([SELECTOR_MANAGED_ELEMENT, SELECTOR_ENDPOINT, SELECTOR_CONNECTOR, SELECTOR_OVERLAY].join(","));
        forEach(els, function (el) {
          return el.parentNode && el.parentNode.removeChild(el);
        });
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this._detachEventDelegates();
        if (this.dragManager != null) {
          this.dragManager.reset();
        }
        this.clearDragSelection();
        _get$3(_getPrototypeOf$9(BrowserJsPlumbInstance.prototype), "destroy", this).call(this);
      }
    }, {
      key: "unmanage",
      value: function unmanage(el, removeElement) {
        this.removeFromDragSelection(el);
        _get$3(_getPrototypeOf$9(BrowserJsPlumbInstance.prototype), "unmanage", this).call(this, el, removeElement);
      }
    }, {
      key: "addToDragSelection",
      value: function addToDragSelection() {
        var _this5 = this;
        for (var _len = arguments.length, el = new Array(_len), _key = 0; _key < _len; _key++) {
          el[_key] = arguments[_key];
        }
        forEach(el, function (_el) {
          return _this5.dragSelection.add(_el);
        });
      }
    }, {
      key: "clearDragSelection",
      value: function clearDragSelection() {
        this.dragSelection.clear();
      }
    }, {
      key: "removeFromDragSelection",
      value: function removeFromDragSelection() {
        var _this6 = this;
        for (var _len2 = arguments.length, el = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          el[_key2] = arguments[_key2];
        }
        forEach(el, function (_el) {
          return _this6.dragSelection.remove(_el);
        });
      }
    }, {
      key: "toggleDragSelection",
      value: function toggleDragSelection() {
        var _this7 = this;
        for (var _len3 = arguments.length, el = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          el[_key3] = arguments[_key3];
        }
        forEach(el, function (_el) {
          return _this7.dragSelection.toggle(_el);
        });
      }
    }, {
      key: "addToDragGroup",
      value: function addToDragGroup(spec) {
        var _this$elementDragHand;
        for (var _len4 = arguments.length, els = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
          els[_key4 - 1] = arguments[_key4];
        }
        (_this$elementDragHand = this.elementDragHandler).addToDragGroup.apply(_this$elementDragHand, [spec].concat(els));
      }
    }, {
      key: "removeFromDragGroup",
      value: function removeFromDragGroup() {
        var _this$elementDragHand2;
        (_this$elementDragHand2 = this.elementDragHandler).removeFromDragGroup.apply(_this$elementDragHand2, arguments);
      }
    }, {
      key: "setDragGroupState",
      value: function setDragGroupState(state) {
        var _this$elementDragHand3;
        for (var _len5 = arguments.length, els = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
          els[_key5 - 1] = arguments[_key5];
        }
        (_this$elementDragHand3 = this.elementDragHandler).setDragGroupState.apply(_this$elementDragHand3, [state].concat(els));
      }
    }, {
      key: "consume",
      value: function consume$1(e, doNotPreventDefault) {
        consume(e, doNotPreventDefault);
      }
    }, {
      key: "rotate",
      value: function rotate(element, rotation, doNotRepaint) {
        var elementId = this.getId(element);
        if (this._managedElements[elementId]) {
          this._managedElements[elementId].el.style.transform = "rotate(" + rotation + "deg)";
          this._managedElements[elementId].el.style.transformOrigin = "center center";
          return _get$3(_getPrototypeOf$9(BrowserJsPlumbInstance.prototype), "rotate", this).call(this, element, rotation, doNotRepaint);
        }
        return {
          c: new Set(),
          e: new Set()
        };
      }
    }, {
      key: "addOverlayClass",
      value: function addOverlayClass(o, clazz) {
        if (isLabelOverlay(o)) {
          o.instance.addClass(getLabelElement(o), clazz);
        } else if (isSVGElementOverlay(o)) {
          o.instance.addClass(SVGElementOverlay.ensurePath(o), clazz);
        } else if (isCustomOverlay(o)) {
          o.instance.addClass(getCustomElement(o), clazz);
        } else {
          throw "Could not add class to overlay of type [" + o.type + "]";
        }
      }
    }, {
      key: "removeOverlayClass",
      value: function removeOverlayClass(o, clazz) {
        if (isLabelOverlay(o)) {
          o.instance.removeClass(getLabelElement(o), clazz);
        } else if (isSVGElementOverlay(o)) {
          o.instance.removeClass(SVGElementOverlay.ensurePath(o), clazz);
        } else if (isCustomOverlay(o)) {
          o.instance.removeClass(getCustomElement(o), clazz);
        } else {
          throw "Could not remove class from overlay of type [" + o.type + "]";
        }
      }
    }, {
      key: "_paintOverlay",
      value: function _paintOverlay(o, params, extents) {
        if (isLabelOverlay(o)) {
          getLabelElement(o);
          var XY = o.component.getXY();
          o.canvas.style.left = XY.x + params.d.minx + "px";
          o.canvas.style.top = XY.y + params.d.miny + "px";
        } else if (isSVGElementOverlay(o)) {
          var path = isNaN(params.d.cxy.x) || isNaN(params.d.cxy.y) ? "M 0 0" : "M" + params.d.hxy.x + "," + params.d.hxy.y + " L" + params.d.tail[0].x + "," + params.d.tail[0].y + " L" + params.d.cxy.x + "," + params.d.cxy.y + " L" + params.d.tail[1].x + "," + params.d.tail[1].y + " L" + params.d.hxy.x + "," + params.d.hxy.y;
          SVGElementOverlay.paint(o, path, params, extents);
        } else if (isCustomOverlay(o)) {
          getCustomElement(o);
          var _XY = o.component.getXY();
          o.canvas.style.left = _XY.x + params.d.minx + "px";
          o.canvas.style.top = _XY.y + params.d.miny + "px";
        } else {
          throw "Could not paint overlay of type [" + o.type + "]";
        }
      }
    }, {
      key: "setOverlayVisible",
      value: function setOverlayVisible(o, visible) {
        var d = visible ? "block" : "none";
        function s(el) {
          if (el != null) {
            el.style.display = d;
          }
        }
        if (isLabelOverlay(o)) {
          s(getLabelElement(o));
        } else if (isCustomOverlay(o)) {
          s(getCustomElement(o));
        } else if (isSVGElementOverlay(o)) {
          s(o.path);
        }
      }
    }, {
      key: "reattachOverlay",
      value: function reattachOverlay(o, c) {
        if (isLabelOverlay(o)) {
          o.instance._appendElement(getLabelElement(o), this.getContainer());
        } else if (isCustomOverlay(o)) {
          o.instance._appendElement(getCustomElement(o), this.getContainer());
        } else if (isSVGElementOverlay(o)) {
          this._appendElement(SVGElementOverlay.ensurePath(o), c.connector.canvas);
        }
      }
    }, {
      key: "setOverlayHover",
      value: function setOverlayHover(o, hover) {
        var canvas;
        if (isLabelOverlay(o)) {
          canvas = getLabelElement(o);
        } else if (isCustomOverlay(o)) {
          canvas = getCustomElement(o);
        } else if (isSVGElementOverlay(o)) {
          canvas = SVGElementOverlay.ensurePath(o);
        }
        if (canvas != null) {
          if (this.hoverClass != null) {
            if (hover) {
              this.addClass(canvas, this.hoverClass);
            } else {
              this.removeClass(canvas, this.hoverClass);
            }
          }
          this.setHover(o.component, hover);
        }
      }
    }, {
      key: "destroyOverlay",
      value: function destroyOverlay(o) {
        if (isLabelOverlay(o)) {
          var el = getLabelElement(o);
          el.parentNode.removeChild(el);
          delete o.canvas;
          delete o.cachedDimensions;
        } else if (isArrowOverlay(o) || isDiamondOverlay(o) || isPlainArrowOverlay(o)) {
          SVGElementOverlay.destroy(o);
        } else if (isCustomOverlay(o)) {
          var _el2 = getCustomElement(o);
          _el2.parentNode.removeChild(_el2);
          delete o.canvas;
          delete o.cachedDimensions;
        }
      }
    }, {
      key: "drawOverlay",
      value: function drawOverlay(o, component, paintStyle, absolutePosition) {
        if (isLabelOverlay(o) || isCustomOverlay(o)) {
          var td = HTMLElementOverlay._getDimensions(o);
          if (td != null && td.w != null && td.h != null) {
            var cxy = {
              x: 0,
              y: 0
            };
            if (absolutePosition) {
              cxy = {
                x: absolutePosition.x,
                y: absolutePosition.y
              };
            } else if (component instanceof EndpointRepresentation) {
              var locToUse = Array.isArray(o.location) ? o.location : [o.location, o.location];
              cxy = {
                x: locToUse[0] * component.w,
                y: locToUse[1] * component.h
              };
            } else {
              var loc = o.location,
                  absolute = false;
              if (isString(o.location) || o.location < 0 || o.location > 1) {
                loc = parseInt("" + o.location, 10);
                absolute = true;
              }
              cxy = component.pointOnPath(loc, absolute);
            }
            var minx = cxy.x - td.w / 2,
                miny = cxy.y - td.h / 2;
            return {
              component: o,
              d: {
                minx: minx,
                miny: miny,
                td: td,
                cxy: cxy
              },
              xmin: minx,
              xmax: minx + td.w,
              ymin: miny,
              ymax: miny + td.h
            };
          } else {
            return {
              xmin: 0,
              xmax: 0,
              ymin: 0,
              ymax: 0
            };
          }
        } else if (isArrowOverlay(o) || isDiamondOverlay(o) || isPlainArrowOverlay(o)) {
          return o.draw(component, paintStyle, absolutePosition);
        } else {
          throw "Could not draw overlay of type [" + o.type + "]";
        }
      }
    }, {
      key: "updateLabel",
      value: function updateLabel(o) {
        if (isFunction(o.label)) {
          var lt = o.label(this);
          if (lt != null) {
            getLabelElement(o).innerText = lt;
          } else {
            getLabelElement(o).innerText = "";
          }
        } else {
          if (o.labelText == null) {
            o.labelText = o.label;
            if (o.labelText != null) {
              getLabelElement(o).innerText = o.labelText;
            } else {
              getLabelElement(o).innerText = "";
            }
          }
        }
      }
    }, {
      key: "setHover",
      value: function setHover(component, hover) {
        component._hover = hover;
        if (component instanceof Endpoint && component.endpoint != null) {
          this.setEndpointHover(component, hover, -1);
        } else if (component instanceof Connection && component.connector != null) {
          this.setConnectorHover(component.connector, hover);
        }
      }
    }, {
      key: "paintConnector",
      value: function paintConnector(connector, paintStyle, extents) {
        paintSvgConnector(this, connector, paintStyle, extents);
      }
    }, {
      key: "setConnectorHover",
      value: function setConnectorHover(connector, hover, sourceEndpoint) {
        if (hover === false || !this.currentlyDragging && !this.isHoverSuspended()) {
          var canvas = connector.canvas;
          if (canvas != null) {
            if (connector.hoverClass != null) {
              if (hover) {
                this.addClass(canvas, connector.hoverClass);
              } else {
                this.removeClass(canvas, connector.hoverClass);
              }
            }
            if (hover) {
              this.addClass(canvas, this.hoverClass);
            } else {
              this.removeClass(canvas, this.hoverClass);
            }
          }
          if (connector.connection.hoverPaintStyle != null) {
            connector.connection.paintStyleInUse = hover ? connector.connection.hoverPaintStyle : connector.connection.paintStyle;
            if (!this._suspendDrawing) {
              this._paintConnection(connector.connection);
            }
          }
          if (connector.connection.endpoints[0] !== sourceEndpoint) {
            this.setEndpointHover(connector.connection.endpoints[0], hover, 0, true);
          }
          if (connector.connection.endpoints[1] !== sourceEndpoint) {
            this.setEndpointHover(connector.connection.endpoints[1], hover, 1, true);
          }
        }
      }
    }, {
      key: "destroyConnector",
      value: function destroyConnector(connection) {
        if (connection.connector != null) {
          cleanup(connection.connector);
        }
      }
    }, {
      key: "addConnectorClass",
      value: function addConnectorClass(connector, clazz) {
        if (connector.canvas) {
          this.addClass(connector.canvas, clazz);
        }
      }
    }, {
      key: "removeConnectorClass",
      value: function removeConnectorClass(connector, clazz) {
        if (connector.canvas) {
          this.removeClass(connector.canvas, clazz);
        }
      }
    }, {
      key: "getConnectorClass",
      value: function getConnectorClass(connector) {
        if (connector.canvas) {
          return connector.canvas.className.baseVal;
        } else {
          return "";
        }
      }
    }, {
      key: "setConnectorVisible",
      value: function setConnectorVisible(connector, v) {
        setVisible(connector, v);
      }
    }, {
      key: "applyConnectorType",
      value: function applyConnectorType(connector, t) {
        if (connector.canvas && t.cssClass) {
          var classes = Array.isArray(t.cssClass) ? t.cssClass : [t.cssClass];
          this.addClass(connector.canvas, classes.join(" "));
        }
      }
    }, {
      key: "addEndpointClass",
      value: function addEndpointClass(ep, c) {
        var canvas = getEndpointCanvas(ep.endpoint);
        if (canvas != null) {
          this.addClass(canvas, c);
        }
      }
    }, {
      key: "applyEndpointType",
      value: function applyEndpointType(ep, t) {
        if (t.cssClass) {
          var canvas = getEndpointCanvas(ep.endpoint);
          if (canvas) {
            var classes = Array.isArray(t.cssClass) ? t.cssClass : [t.cssClass];
            this.addClass(canvas, classes.join(" "));
          }
        }
      }
    }, {
      key: "destroyEndpoint",
      value: function destroyEndpoint(ep) {
        var anchorClass = this.endpointAnchorClassPrefix + (ep.currentAnchorClass ? "-" + ep.currentAnchorClass : "");
        this.removeClass(ep.element, anchorClass);
        cleanup(ep.endpoint);
      }
    }, {
      key: "renderEndpoint",
      value: function renderEndpoint(ep, paintStyle) {
        var renderer = endpointMap[ep.endpoint.type];
        if (renderer != null) {
          SvgEndpoint.paint(ep.endpoint, renderer, paintStyle);
        } else {
          log("jsPlumb: no endpoint renderer found for type [" + ep.endpoint.type + "]");
        }
      }
    }, {
      key: "removeEndpointClass",
      value: function removeEndpointClass(ep, c) {
        var canvas = getEndpointCanvas(ep.endpoint);
        if (canvas != null) {
          this.removeClass(canvas, c);
        }
      }
    }, {
      key: "getEndpointClass",
      value: function getEndpointClass(ep) {
        var canvas = getEndpointCanvas(ep.endpoint);
        if (canvas != null) {
          return canvas.className;
        } else {
          return "";
        }
      }
    }, {
      key: "setEndpointHover",
      value: function setEndpointHover(endpoint, hover, endpointIndex, doNotCascade) {
        if (endpoint != null && (hover === false || !this.currentlyDragging && !this.isHoverSuspended())) {
          var canvas = getEndpointCanvas(endpoint.endpoint);
          if (canvas != null) {
            if (endpoint.hoverClass != null) {
              if (hover) {
                this.addClass(canvas, endpoint.hoverClass);
              } else {
                this.removeClass(canvas, endpoint.hoverClass);
              }
            }
            if (endpointIndex === 0 || endpointIndex === 1) {
              var genericHoverClass = endpointIndex === 0 ? this.hoverSourceClass : this.hoverTargetClass;
              if (hover) {
                this.addClass(canvas, genericHoverClass);
              } else {
                this.removeClass(canvas, genericHoverClass);
              }
            }
          }
          if (endpoint.hoverPaintStyle != null) {
            endpoint.paintStyleInUse = hover ? endpoint.hoverPaintStyle : endpoint.paintStyle;
            if (!this._suspendDrawing) {
              this.renderEndpoint(endpoint, endpoint.paintStyleInUse);
            }
          }
          if (!doNotCascade) {
            for (var i = 0; i < endpoint.connections.length; i++) {
              this.setConnectorHover(endpoint.connections[i].connector, hover, endpoint);
            }
          }
        }
      }
    }, {
      key: "setEndpointVisible",
      value: function setEndpointVisible(ep, v) {
        setVisible(ep.endpoint, v);
      }
    }, {
      key: "setGroupVisible",
      value: function setGroupVisible(group, state) {
        var m = group.el.querySelectorAll(SELECTOR_MANAGED_ELEMENT);
        for (var i = 0; i < m.length; i++) {
          if (state) {
            this.show(m[i], true);
          } else {
            this.hide(m[i], true);
          }
        }
      }
    }, {
      key: "deleteConnection",
      value: function deleteConnection(connection, params) {
        if (connection != null && connection.deleted !== true) {
          if (connection.endpoints[0].deleted !== true) {
            this.setEndpointHover(connection.endpoints[0], false, 0, true);
          }
          if (connection.endpoints[1].deleted !== true) {
            this.setEndpointHover(connection.endpoints[1], false, 1, true);
          }
          return _get$3(_getPrototypeOf$9(BrowserJsPlumbInstance.prototype), "deleteConnection", this).call(this, connection, params);
        } else {
          return false;
        }
      }
    }, {
      key: "addSourceSelector",
      value: function addSourceSelector(selector, params, exclude) {
        this.addDragFilter(selector);
        return _get$3(_getPrototypeOf$9(BrowserJsPlumbInstance.prototype), "addSourceSelector", this).call(this, selector, params, exclude);
      }
    }, {
      key: "removeSourceSelector",
      value: function removeSourceSelector(selector) {
        this.removeDragFilter(selector.selector);
        _get$3(_getPrototypeOf$9(BrowserJsPlumbInstance.prototype), "removeSourceSelector", this).call(this, selector);
      }
    }]);
    return BrowserJsPlumbInstance;
  }(JsPlumbInstance);

  var CIRCLE = "circle";
  var register$2 = function register() {
    registerEndpointRenderer(DotEndpoint.type, {
      makeNode: function makeNode(ep, style) {
        return _node(CIRCLE, {
          "cx": ep.w / 2,
          "cy": ep.h / 2,
          "r": ep.radius
        });
      },
      updateNode: function updateNode(ep, node) {
        _attr(node, {
          "cx": "" + ep.w / 2,
          "cy": "" + ep.h / 2,
          "r": "" + ep.radius
        });
      }
    });
  };

  var RECT = "rect";
  var register$1 = function register() {
    registerEndpointRenderer(RectangleEndpoint.type, {
      makeNode: function makeNode(ep, style) {
        return _node(RECT, {
          "width": ep.w,
          "height": ep.h
        });
      },
      updateNode: function updateNode(ep, node) {
        _attr(node, {
          "width": ep.w,
          "height": ep.h
        });
      }
    });
  };

  var BLANK_ATTRIBUTES = {
    "width": 10,
    "height": 0,
    "fill": "transparent",
    "stroke": "transparent"
  };
  var register = function register() {
    registerEndpointRenderer(BlankEndpoint.type, {
      makeNode: function makeNode(ep, style) {
        return _node("rect", BLANK_ATTRIBUTES);
      },
      updateNode: function updateNode(ep, node) {
        _attr(node, BLANK_ATTRIBUTES);
      }
    });
  };

  register$2();
  register();
  register$1();
  var _jsPlumbInstanceIndex = 0;
  function getInstanceIndex() {
    var i = _jsPlumbInstanceIndex + 1;
    _jsPlumbInstanceIndex++;
    return i;
  }
  function newInstance$1(defaults) {
    return new BrowserJsPlumbInstance(getInstanceIndex(), defaults);
  }

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck$d(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$d(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$d(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$d(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$d(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty$c(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _inherits$8(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf$8(subClass, superClass);
  }

  function _getPrototypeOf$8(o) {
    _getPrototypeOf$8 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$8(o);
  }

  function _setPrototypeOf$8(o, p) {
    _setPrototypeOf$8 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$8(o, p);
  }

  function _isNativeReflectConstruct$8() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _assertThisInitialized$8(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn$8(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }

    return _assertThisInitialized$8(self);
  }

  function _createSuper$8(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$8();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf$8(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$8(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn$8(this, result);
    };
  }

  function _superPropBase$2(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf$8(object);
      if (object === null) break;
    }

    return object;
  }

  function _get$2(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get$2 = Reflect.get;
    } else {
      _get$2 = function _get(target, property, receiver) {
        var base = _superPropBase$2(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };
    }

    return _get$2(target, property, receiver || target);
  }

  var Cluster = /*#__PURE__*/function () {
    function Cluster(seed) {
      _classCallCheck$d(this, Cluster);

      _defineProperty$c(this, "vertices", void 0);

      this.vertices = [seed];
    }

    _createClass$d(Cluster, [{
      key: "addVertex",
      value: function addVertex(v) {
        this.vertices.push(v);
      }
    }]);

    return Cluster;
  }();

  function floydWarshall(params) {
    var graph = params.graph,
        n = graph.getVertexCount(),
        path = {},
        next = {},
        i,
        j,
        k; // init

    for (i = 0; i < n; i++) {
      var v = graph.getVertexAt(i);
      if (!path[v.id]) path[v.id] = {};
      if (!next[v.id]) next[v.id] = {};
      path[v.id][v.id] = 0;

      for (j = 0; j < n; j++) {
        if (i != j) {
          var v2 = graph.getVertexAt(j);
          if (!path[v.id][v2.id]) path[v.id][v2.id] = Infinity;
          if (!next[v.id][v2.id]) next[v.id][v2.id] = [];
        }
      }

      var edges = v.getEdges();

      for (k = 0; k < edges.length; k++) {
        if (edges[k].source == v) {
          path[v.id][edges[k].target.id] = edges[k].getCost();
        } else {
          if (!path[edges[k].source.id]) {
            path[edges[k].source.id] = {};
            next[edges[k].source.id] = {};
          }

          path[v.id][edges[k].source.id] = edges[k].getCost();
        }
      }
    } //


    for (k = 0; k < n; k++) {
      for (i = 0; i < n; i++) {
        for (j = 0; j < n; j++) {
          if (i != j && j != k && i != k) {
            var id1 = graph.getVertexAt(i).id,
                id2 = graph.getVertexAt(j).id,
                id3 = graph.getVertexAt(k).id;

            if (path[id1][id3] + path[id3][id2] <= path[id1][id2] && path[id1][id3] + path[id3][id2] != Infinity) {
              path[id1][id2] = path[id1][id3] + path[id3][id2];
              if (!next[id1][id2]) next[id1][id2] = [];
              next[id1][id2].unshift([graph.getVertexAt(k), path[id1][id2]]);
            }
          }
        }
      }
    } //return [ path, pathsThroughFocus ]


    return {
      paths: path,
      parents: next
    };
  }

  /**
   * Extract a value from, or set a value into, an object. This static method can be used outside of Knockle.
   * @param inObj Object to extract value from or insert value into
   * @param path Path to the value to extract/insert, in dotted notation. This syntax also supports array indices,
   * such as `foo.bar[3]`.
   * @param value If provided, this method sets the value. Otherwise it extracts the current value.
   * @static
   * @returns Value for the given path, null if not found.
   */

  function data(inObj, path, value) {
    if (inObj == null) {
      return null;
    }

    if (path === "$data" || path == null) {
      return inObj;
    } // if path is actually an object spec,


    var objectSpec = path.match(/^\{(.*)\}$/);

    if (objectSpec) {
      var out = {},
          parts = objectSpec[1].split(",");

      for (var i = 0; i < parts.length; i++) {
        var pp = parts[i].split(":"),
            v = data(inObj, pp[1]);
        out[fastTrim(pp[0])] = v || pp[1].replace(/'/g, "");
      }

      return out;
    } // replace any quoted accessors with dotted syntax


    path = path.replace(/\['([^']*)'\]/g, ".$1");
    var q = inObj,
        t = q,
        o = null;
    path.replace(/([^\.])+/g, function (term, lc, pos, str) {
      if (o != null) {
        return;
      }

      var array = term.match(/([^\[0-9]+){1}(\[)([0-9+])/),
          last = pos + term.length >= str.length,
          _getArray = function _getArray() {
        return t[array[1]] || function () {
          t[array[1]] = [];
          return t[array[1]];
        }();
      };

      if (last) {
        if (array) {
          var _a = _getArray(),
              idx = array[3];

          if (value == null) {
            o = _a[idx];
          } else {
            _a[idx] = value;
          }
        } else {
          if (value == null) {
            o = t[term];
          } else {
            t[term] = value;
          }
        }
      } else {
        // set to current t[term], creating t[term] if necessary.
        if (array) {
          var a = _getArray();

          t = a[array[3]] || function () {
            a[array[3]] = {};
            return a[array[3]];
          }();
        } else t = t[term] || function () {
          t[term] = {};
          return t[term];
        }();
      }
    });
    return o;
  }
  /**
   * Partitions a list into two lists - one for which the supplied partitioner returns true (the `left` list), and the other, the
   * `right` list, for which the supplied partitioner does not return true.
   * @param l List to partition
   * @param partitioner Function to use to partition the list.
   * @public
   */

  function partition(l, partitioner) {
    var out = {
      left: [],
      right: []
    };
    forEach(l, function (candidate) {
      if (partitioner(candidate)) {
        out.left.push(candidate);
      } else {
        out.right.push(candidate);
      }
    });
    return out;
  }

  /**
   * for the given vertex, resolves the id of the node/group it belongs to - the vertex might be a port, which has
   * a parent node or group.
   * @param v
   * @internal
   */
  function resolveNodeId(v) {
    return isPort(v) ? v.getParent().id : v.getFullId();
  }
  /**
   * For the given vertex, resolves the node/group it pertains to. If the vertex is already a node/group, it is returned. Otherwise, if
   * it is a port, the parent of the port is returned.
   * @param v
   */

  function resolveNode(v) {
    return isPort(v) ? v.getParent() : v;
  }
  /**
   * For the given vertex, resolve its port id. If it is not a port, null is returned. If it is a port, its id is returned (without the parent vertex's id prefixed to it)
   * @param v
   */

  function resolvePortId(v) {
    return isPort(v) ? v.id : null;
  }
  function isNode(obj) {
    return obj != null && obj.objectType === Node.objectType;
  }
  function isNodeInsideAGroup(obj) {
    return isNode(obj) && obj.group != null;
  }
  function isGroup(obj) {
    return obj != null && obj.objectType === Group.objectType;
  }
  function isNestedGroup(obj) {
    return isGroup(obj) && obj.group != null;
  }
  function isEdge(obj) {
    return obj != null && obj.objectType === Edge.objectType;
  }
  function isPort(obj) {
    return obj != null && obj.objectType === Port.objectType;
  }
  function isNodeVertex(v) {
    return v.objectType === Node.objectType || v.objectType === Group.objectType;
  }
  function defaultIdFunction(obj) {
    return obj.id;
  }
  var DEFAULT_PORT_SEPARATOR = ".";
  var Graph = /*#__PURE__*/function () {
    function Graph(params) {
      _classCallCheck$d(this, Graph);

      _defineProperty$c(this, "nodes", []);

      _defineProperty$c(this, "id", void 0);

      _defineProperty$c(this, "edges", []);

      _defineProperty$c(this, "groups", []);

      _defineProperty$c(this, "_nodeMap", new Map());

      _defineProperty$c(this, "_edgeMap", new Map());

      _defineProperty$c(this, "_groupMap", new Map());

      _defineProperty$c(this, "defaultDirected", void 0);

      _defineProperty$c(this, "defaultCost", void 0);

      _defineProperty$c(this, "_defaultIdFunction", void 0);

      _defineProperty$c(this, "typeFunction", void 0);

      _defineProperty$c(this, "enableSubgraphs", void 0);

      _defineProperty$c(this, "portSeparator", void 0);

      _defineProperty$c(this, "_topLevelCache", {});

      params = params || {};
      this.nodes = [];
      this.edges = [];
      this.groups = [];
      this.id = params.id;
      this.defaultDirected = !(params.defaultDirected === false);
      this.defaultCost = params.defaultCost || 1;
      this._defaultIdFunction = params.defaultIdFunction || defaultIdFunction;

      this.typeFunction = params.typeFunction || function (d) {
        return d.type || "default";
      };

      this.enableSubgraphs = params.enableSubgraphs === true;
      this.portSeparator = params.portSeparator || DEFAULT_PORT_SEPARATOR;
    }

    _createClass$d(Graph, [{
      key: "_removeFromTopLevelCache",
      value: function _removeFromTopLevelCache(v) {
        delete this._topLevelCache[v.id];
      }
    }, {
      key: "_addToTopLevelCache",
      value: function _addToTopLevelCache(v) {
        this._topLevelCache[v.id] = v;
      }
    }, {
      key: "_clearTopLevelCache",
      value: function _clearTopLevelCache() {
        this._topLevelCache = {};
      }
    }, {
      key: "getIdFunction",
      value: function getIdFunction() {
        return this._defaultIdFunction;
      }
    }, {
      key: "setIdFunction",
      value: function setIdFunction(f) {
        this._defaultIdFunction = f;
      }
    }, {
      key: "setTypeFunction",
      value: function setTypeFunction(f) {
        this.typeFunction = f;
      }
      /**
       * Gets the type for some data, by running it through the current typeFunction.
       * @param data Object to get type from.
       * @returns The calculated type for the given object.
       */

    }, {
      key: "getType",
      value: function getType(data) {
        return this.typeFunction(data);
      }
    }, {
      key: "getId",
      value: function getId(data, idFunction) {
        if (data == null) {
          return uuid();
        } else if (typeof data === 'string') {
          return data;
        } else {
          var idf = idFunction || this.getIdFunction();
          return idf(data) || uuid();
        }
      }
    }, {
      key: "getTopLevelElements",
      value: function getTopLevelElements() {
        return this._topLevelCache;
      }
      /**
       * Sets whether or not Nodes are Graphs themselves, and can have child Nodes. If you enable this
       * then you cannot use slashes (/) in your Node ids, as they will be treated as components of a path
       * to a Node in a nested Graph.
       * @param enable True to enable, false to disable.
       */

    }, {
      key: "setEnableSubgraphs",
      value: function setEnableSubgraphs(enable) {
        this.enableSubgraphs = enable;
      }
      /**
       * Sets the character(s) used to separate ports from nodes in port ids. By default this is '.', ie a
       * port is addressed as `nodeId.portId`. This may need to be changed depending on the data in your model.
       * @param separator Separator to use.
       */

    }, {
      key: "setPortSeparator",
      value: function setPortSeparator(separator) {
        this.portSeparator = separator;
      }
      /**
       * Gets the current port separator.
       * @returns Port separator string. Default is "."
       */

    }, {
      key: "getPortSeparator",
      value: function getPortSeparator() {
        return this.portSeparator;
      }
      /**
       * Splits the given port id using the current portSeparator.
       * @param portId Port ID to split.
       * @returns An array of [ vertexId, portId], or [] if the portId was null.
       */

    }, {
      key: "splitPortId",
      value: function splitPortId(portId) {
        return portId != null ? portId.split(this.portSeparator) : [];
      }
      /**
       * Looks up a vertex identified by the port id, which is in full port id (vertexId.portId) format, returning null if nothing found.
       * (Note that we show full port id format as vertexId.portId, but the '.' is just the default portSeparator; it is possible to change that
       * to some other character)
       * @param portId ID of the port to find a vertex for.
       */

    }, {
      key: "getVertexByPortId",
      value: function getVertexByPortId(portId) {
        var parts = this.splitPortId(portId);

        if (parts.length === 2) {
          return this._nodeMap.get(parts[0]) || this._groupMap.get(parts[0]);
        }
      }
    }, {
      key: "getVertex",
      value: function getVertex(e, createPortsIfMissing) {
        var _this = this;

        if (e == null) return null;
        var es; // if not a string, check if its an object

        if (typeof e != "string") {
          if (e.constructor === Port || e.constructor === Node || e.constructor === Group) return e;
          var orig = e; // if its an object from which we could get something that looks like an id, get the id and continue with the id lookup code.

          es = this._defaultIdFunction(e); // otherwise, return.

          if (typeof es != "string") {
            return orig;
          }
        }

        es = e;

        var path = this.enableSubgraphs ? es.split("/") : [es],
            _one = function _one(_id) {
          if (_this._nodeMap.has(_id)) {
            return _this._nodeMap.get(_id);
          }

          if (_this._groupMap.has(_id)) {
            return _this._groupMap.get(_id);
          } // otherwise, look for a node by assuming dotted notation.


          var np = _id.split(_this.portSeparator),
              nodeId = np[0],
              node = _this._nodeMap.get(nodeId) || _this._groupMap.get(nodeId);

          if (np.length === 2 && node != null) {
            var p = node.getPort(np[1]);
            if (p == null && createPortsIfMissing) p = node.addPort(np[1]);
            return p;
          } else return node;
        };

        if (path.length == 1) return _one(path[0]);else if (path.length > 1 && path.length % 2 == 0) throw "Subgraph path format error.";else {
          // if path empty then this is a node/port lookup on the root. otherwise path should have an
          // odd number of components, since it consists of a series of node/graph entries followed by
          // a final node id.
          var currentNode = null,
              currentGraph = null;

          for (var i = 0; i < path.length - 1; i += 2) {
            currentNode = _one(path[i]);
            currentGraph = currentNode.getGraph(path[i + 1]);
          }

          return currentGraph.getVertex(path[path.length - 1]);
        }
      }
    }, {
      key: "clear",
      value: function clear() {
        this.nodes.length = 0;
        this.groups.length = 0;

        this._nodeMap.clear();

        this._edgeMap.clear();

        this._groupMap.clear();

        this._clearTopLevelCache();
      }
      /**
       * Gets all the nodes in the Graph.
       */

    }, {
      key: "getVertices",
      value: function getVertices() {
        return this.nodes;
      }
      /**
       * Gets the count of nodes in the Graph.
       */

    }, {
      key: "getVertexCount",
      value: function getVertexCount() {
        return this.nodes.length;
      }
      /**
       * Returns the vertex at the given index (used for bulk init type purposes)
       * @param index Index of the Node to retrieve
       * @returns vertex at the given index.
       */

    }, {
      key: "getVertexAt",
      value: function getVertexAt(index) {
        return this.nodes[index];
      }
      /**
       * Returns the total number of Edges in the graph.
       * @returns The total number of Edges.
       */

    }, {
      key: "getEdgeCount",
      value: function getEdgeCount() {
        return this._edgeMap.size;
      }
      /**
       * Adds an edge to the graph.
       * @param params
       * @param idFunction
       * @param connectableFilterFunction
       */

    }, {
      key: "addEdge",
      value: function addEdge(params, idFunction, connectableFilterFunction) {
        var directed = params.directed == null ? this.defaultDirected === true : !(params.directed === false),
            cost = params.cost || this.defaultCost,
            id = this.getId(params.data, idFunction),
            source = this.getVertex(params.source, true),
            target = this.getVertex(params.target, true);
        if (source == null || source.objectType == null) throw new TypeError("Unknown source node [" + params.source + "]");
        if (target == null || target.objectType == null) throw new TypeError("Unknown target node [" + params.target + "]");

        if (connectableFilterFunction && !connectableFilterFunction(source, target)) {
          return null;
        }

        var edge = new Edge({
          source: source,
          target: target,
          cost: cost,
          directed: directed,
          data: params.data || {},
          id: id,
          graph: this
        });
        edge.source.addEdge(edge);

        if (edge.source !== edge.target) {
          edge.target.addEdge(edge);
        }

        this._edgeMap.set(id, edge);

        if (params.geometry != null) {
          edge.geometry = params.geometry;
        }

        return edge;
      }
    }, {
      key: "addNode",
      value: function addNode(data, idFunction) {
        var v = new Node(this, data, idFunction || this._defaultIdFunction);

        if (!this._nodeMap.has(v.id)) {
          this.nodes.push(v);

          this._nodeMap.set(v.id, v);

          v._id = this._nodeMap.size;

          this._addToTopLevelCache(v);

          return v;
        }

        return null;
      }
      /**
       * Adds a list of Nodes to the Graph
       * @param data List of data objects, one for each Node to be added.
       * @param idFunction Optional function to use to retrieve ID from backing data. Defaults to retrieving `id` from data object.
       */

    }, {
      key: "addNodes",
      value: function addNodes(data, idFunction) {
        for (var i = 0; i < data.length; i++) {
          this.addNode(data[i], idFunction || this._defaultIdFunction);
        }
      }
      /**
       * Adds a Group to the Graph.
       * @param data
       * @param idFunction
       */

    }, {
      key: "addGroup",
      value: function addGroup(data, idFunction) {
        var g = new Group(this, data, idFunction || this._defaultIdFunction);

        if (!this._groupMap.has(g.id)) {
          this.groups.push(g);

          this._groupMap.set(g.id, g);

          g._id = this._groupMap.size;

          this._addToTopLevelCache(g);

          return g;
        }

        return this._groupMap.get(g.id);
      }
    }, {
      key: "getGroupCount",
      value: function getGroupCount() {
        return this.groups.length;
      }
      /**
       * Returns the Group at the given index.
       * @param idx Index into group list
       * @returns a Group, or null if not found.
       */

    }, {
      key: "getGroupAt",
      value: function getGroupAt(idx) {
        return this.groups[idx];
      }
      /**
       * Gets the Groups in the graph.
       * @returns All the groups in the Graph.
       */

    }, {
      key: "getGroups",
      value: function getGroups() {
        return this.groups;
      }
    }, {
      key: "addMemberToGroup",
      value: function addMemberToGroup(v, g) {
        var gg = typeof g === "string" ? this._groupMap.get(g) : g;
        var vv = this.getVertex(v);

        if (vv && gg) {
          gg.addMember(vv);

          this._removeFromTopLevelCache(vv);
        }
      }
    }, {
      key: "addMembersToGroup",
      value: function addMembersToGroup(v, g) {
        for (var i = 0; i < v.length; i++) {
          this.addMemberToGroup(v[i], g);
        }
      }
    }, {
      key: "removeMemberFromGroup",
      value: function removeMemberFromGroup(v) {
        var vv = this.getVertex(v);

        if (vv && vv.group) {
          vv.group.removeMember(vv);

          this._addToTopLevelCache(vv);
        }
      }
    }, {
      key: "removeMembersFromGroup",
      value: function removeMembersFromGroup(v) {
        for (var i = 0; i < v.length; i++) {
          this.removeMemberFromGroup(v[i]);
        }
      }
    }, {
      key: "getGroup",
      value: function getGroup(group) {
        return typeof group === "string" ? this._groupMap.get(group) : group;
      }
      /**
       * Deletes a Group
       * @param g Either a Group, or a Group id.
       * @param removeMembers If true, also remove all the Nodes/Groups that are members of the Group.
       */

    }, {
      key: "deleteGroup",
      value: function deleteGroup(g, removeMembers) {
        var _this2 = this;

        var out = {
          group: typeof g === "string" ? this._groupMap.get(g) : g,
          edges: [],
          nodes: [],
          nestedGroups: [],
          children: []
        };

        if (out.group) {
          out.parentGroup = out.group.group;
          out.children = out.group.members.slice();
          var i;

          if (removeMembers) {
            var _partition = partition(out.group.getMembers(), function (v) {
              return isGroup(v);
            }),
                left = _partition.left,
                right = _partition.right;

            left.forEach(function (g) {
              out.nestedGroups.push(_this2.deleteGroup(g, true));
            });
            right.forEach(function (n) {
              out.nodes.push(_this2.deleteNode(n));
            });
          } else {
            out.group.getMembers().forEach(function (v) {
              return delete v.group;
            });
          }

          out.group.members.length = 0; // remove group edges last.

          out.edges = out.group.getAllDirectEdges().slice();
          var edgeCount = out.edges.length;

          for (i = 0; i < edgeCount; i++) {
            this.deleteEdge(out.edges[i]);
          }

          var ports = out.group.getPorts();

          for (var k = 0; k < ports.length; k++) {
            this.deletePort(ports[k]);
          }

          this._groupMap["delete"](out.group.id);

          var idx = -1;

          for (var _i = 0; _i < this.groups.length; _i++) {
            if (this.groups[_i].id === out.group.id) {
              idx = _i;
              break;
            }
          }

          if (idx > -1) {
            this.groups.splice(idx, 1);
          }

          if (out.group.group != null) {
            out.group.group.removeMember(g);
          }

          this._removeFromTopLevelCache(out.group);
        }

        return out;
      }
      /**
       * @internal
       * @param port
       */

    }, {
      key: "deletePort",
      value: function deletePort(port) {
        var edges = port.getEdges();

        for (var j = 0; j < edges.length; j++) {
          this.deleteEdge(edges[j]);
        }

        return edges;
      }
      /**
       * Deletes a Node
       * @param vertex a Node
       * @internal
       */

    }, {
      key: "deleteNode",
      value: function deleteNode(vertex) {
        var v = this.getVertex(vertex),
            out = {
          node: null,
          edges: [],
          parentGroup: null
        };

        if (v) {
          out.node = v;
          out.parentGroup = v.group;
          var ports = v.getPorts();

          for (var k = 0; k < ports.length; k++) {
            this.deletePort(ports[k]);
          }

          var vnode = v;
          var idx = -1;

          for (var i = 0; i < this.nodes.length; i++) {
            if (this.nodes[i].id === v.id) {
              idx = i;
              break;
            }
          }

          if (idx > -1) {
            this.nodes.splice(idx, 1);

            if (vnode.group != null) {
              vnode.group.removeMember(vnode);
            }
          } // common between node and group


          out.edges = v.getEdges().slice();

          for (var j = 0; j < out.edges.length; j++) {
            this.deleteEdge(out.edges[j]);
          }

          this._nodeMap["delete"](v.getFullId());

          this._removeFromTopLevelCache(v);
        }

        return out;
      }
      /**
       * Deletes an Edge.
       * @param edge Edge, or ID of Edge, to delete.
       */

    }, {
      key: "deleteEdge",
      value: function deleteEdge(edge) {
        edge = this.getEdge(edge);
        if (edge == null) return;
        var v = this.getVertex(edge.source);

        if (v) {
          v.deleteEdge(edge);
        }

        var v2 = this.getVertex(edge.target);

        if (v2) {
          v2.deleteEdge(edge);
        }

        this._edgeMap["delete"](edge.getId());
      }
      /**
       * Gets an Edge by id, or if the given object is already an Edge, hands that back.
       * @param e ID of the Edge to retrieve, or an actual Edge, or some data from which an ID could be derived.
       * @returns The requested Edge, if found, otherwise null.
       */

    }, {
      key: "getEdge",
      value: function getEdge(e) {
        if (e == null) return;

        if (typeof e !== "string") {
          if (e.constructor === Edge) {
            return e;
          }

          var orig = e; // if its an object from which we could get something that looks like an id, get the id and continue with the id lookup code.

          e = this._defaultIdFunction(e); // otherwise, return.

          if (typeof e !== "string") {
            return orig;
          }
        }

        return this._edgeMap.get(e);
      }
      /**
       * For some given node, get a subset of edges that match the given filter function.
       * @param params Method parameters
       * @param params.source If true, only match edges for which this node is the source.
       * @param params.target If true, only match edges for which this node is the target.
       * @param params.filter Optional edge filter.
       */

    }, {
      key: "getEdges",
      value: function getEdges(params) {
        params = params || {};

        var matchSource = params.source != null,
            matchTarget = params.target != null,
            v = params.node ? this.getVertex(params.node) : null,
            f = params.filter || function () {
          return true;
        },
            fe = function fe(e) {
          return (!matchSource || (params.source === true ? e.source === v : e.source !== v)) && (!matchTarget || (params.target === true ? e.target === v : e.target !== v));
        },
            out = [],
            match = function match(e) {
          if (f(e) && fe(e)) {
            out.push(e);
          }
        },
            i;

        if (params.node) {
          var node = this.getVertex(params.node);

          var _e = node.getAllEdges();

          for (i = 0; i < _e.length; i++) {
            match(_e[i]);
          }
        } else {
          this._edgeMap.forEach(function (e, id) {
            return match(e);
          });
        }

        return out;
      }
      /**
       * Gets every edge in the Graph.
       */

    }, {
      key: "getAllEdges",
      value: function getAllEdges() {
        var a = [];

        this._edgeMap.forEach(function (e, id) {
          return a.push(e);
        });

        return a;
      }
    }, {
      key: "renamePort",
      value: function renamePort(port, newId) {
        if (port.getParent().renamePort(port, newId)) {
          port.id = newId;
          return true;
        } else {
          return false;
        }
      }
      /**
       * Gets a list of groups that are ancestors of the given node/group. The list of ancestors is ordered in terms of their
       * proximity to the focus, ie. the first entry is the focus vertex's immediate parent.
       * @param vertex
       */

    }, {
      key: "getAncestors",
      value: function getAncestors(vertex) {
        var ancestors = [];
        var p = vertex.group;

        while (p != null) {
          ancestors.push(p);
          p = p.group;
        }

        return ancestors;
      }
      /**
       * Returns whether or not `possibleAncestor` is in fact an ancestor of the given focus node/group
       * @param focus
       * @param possibleAncestor
       */

    }, {
      key: "isAncestor",
      value: function isAncestor(focus, possibleAncestor) {
        if (focus == null || possibleAncestor == null) {
          return false;
        }

        return this.getAncestors(focus).indexOf(possibleAncestor) !== -1;
      }
      /**
       * Finds the shortest path from source to target, using the Djikstra algorithm.
       * @param source Source Node or Node ID.
       * @param target Target Node or Node ID.
       * @param strict Defaults to true. Sets whether or not paths are searched strictly by the given source/target. If, for instance, you supply a node as the source, but there are only edges connected to ports on that node, by default these edges will be ignored. Switching `strict` to false will mean these edges are considered.
       * @param nodeFilter Optional function that is given each Node's backing data and asked to return true or false - true means include the Node, false means exclude it.
       * @param edgeFilter Optional function that is given each Edge's backing data and asked to return true or false - true means include the Edge, false means exclude it.
       * @returns A ShortestPathResult object.
       */

    }, {
      key: "findPath",
      value: function findPath(source, target, strict, nodeFilter, edgeFilter) {
        var vsource = this.getVertex(source);
        var vtarget = this.getVertex(target);
        return djikstra({
          graph: this,
          source: vsource,
          target: vtarget,
          strict: !(strict === false),
          nodeFilter: nodeFilter,
          edgeFilter: edgeFilter
        });
      }
      /**
       * Finds the distance between source and target.
       * @param source Source vertex or vertex ID.
       * @param target Target vertex or vertex ID.
       * @param strict Defauls to true. Sets whether or not paths are searched strictly by the given source/target. If, for instance, you supply a node as the source, but there are only edges connected to ports on that node, by default these edges will be ignored. Switching `strict` to false will mean these edges are considered.
       * @returns Distance from the source to the target.
       */

    }, {
      key: "getDistance",
      value: function getDistance(source, target, strict) {
        var info = this.findPath(source, target, strict);
        return info.pathDistance;
      }
      /**
       * Sets the target Group/Node/Port for some Edge.
       * @param edge The Edge to change the target for
       * @param o group/Node/Port/id for new Edge target
       */

    }, {
      key: "setTarget",
      value: function setTarget(edge, o) {
        var vo = this.getVertex(o);
        if (vo == null) return {
          success: false
        };
        var old = edge.target;
        edge.target.deleteEdge(edge);
        edge.target = vo;
        vo.addEdge(edge);
        return {
          old: old,
          edge: edge,
          "new": vo,
          success: true
        };
      }
      /**
       * Sets the source Group/Node/Port for some Edge.
       * @param edge The Edge to change the source for
       * @param o Group/Node/Port or id for new Edge source
       */

    }, {
      key: "setSource",
      value: function setSource(edge, o) {
        var vo = this.getVertex(o);
        if (vo == null) return {
          success: false
        };
        var old = edge.source;
        edge.source.deleteEdge(edge);
        edge.source = vo;
        vo.addEdge(edge);
        return {
          old: old,
          edge: edge,
          "new": vo,
          success: true
        };
      }
      /**
       * Returns the path from source to target as a string.
       * @returns Printed path. Mostly useful for debugging.
       */

    }, {
      key: "printPath",
      value: function printPath(source, target) {
        var vsource = this.getVertex(source);
        var vtarget = this.getVertex(target);
        var path = this.findPath(vsource, vtarget).path;
        var s = "[" + vsource.id + " - " + vtarget.id + "] : ";

        for (var i = 0; i < path.length; i++) {
          s = s + "{ vertex:" + path[i].vertex.id + ", cost:" + path[i].cost + ", edge: " + (path[i].edge && path[i].edge.getId()) + " } ";
        }

        return s;
      }
      /**
       * Returns the `diameter` of the Graph.
       * @param dontUseMax Whether or not to return Infinity if there is at least one pair of nodes for which there is no available path. Defaults to false.
       * @returns Diameter of the Graph.
       */

    }, {
      key: "getDiameter",
      value: function getDiameter(dontUseMax) {
        var diameter = 0;

        for (var i = 0; i < this.nodes.length; i++) {
          for (var j = 0; j < this.nodes.length; j++) {
            if (j != i) {
              var info = djikstra({
                graph: this,
                source: this.nodes[i],
                target: this.nodes[j]
              });

              if (info.path == null || info.path.length == 0) {
                if (!dontUseMax) return Infinity;
              } else diameter = Math.max(diameter, info.pathDistance);
            }
          }
        }

        return diameter;
      }
    }, {
      key: "getCentrality",
      value: function getCentrality(node) {
        var vnode = this.getVertex(node);
        return (vnode.getIndegreeCentrality() + vnode.getOutdegreeCentrality()) / (this.getVertexCount() - 1);
      }
      /**
       * Returns the indegree centrality of the given vertex (number of connections entering the vertex)
       * @param vertex Vertex, or Vertex ID, to retrieve indegree centrality for.
       * @returns Vertex's indegree centrality.
       */

    }, {
      key: "getIndegreeCentrality",
      value: function getIndegreeCentrality(vertex) {
        var vnode = this.getVertex(vertex);
        return vnode.getIndegreeCentrality() / (this.getVertexCount() - 1);
      }
      /**
       * Returns the outdegree centrality of the given vertex (number of connections exiting the vertex)
       * @param vertex Vertex, or Vertex ID, to retrieve outdegree centrality for.
       * @returns Vertex's indegree centrality.
       */

    }, {
      key: "getOutdegreeCentrality",
      value: function getOutdegreeCentrality(vertex) {
        var vnode = this.getVertex(vertex);
        return vnode.getOutdegreeCentrality() / (this.getVertexCount() - 1);
      }
      /**
       * Returns the Closeness centrality of the given vertex. This is the inverse of the vertex's farness.
       * @param vertex Vertex, or Vertex ID, to retrieve closeness for.
       * @returns Node's "closeness".
       * @see getFarness
       */

    }, {
      key: "getCloseness",
      value: function getCloseness(vertex) {
        return 1 / this.getFarness(vertex);
      }
      /**
       * Returns the farness centrality of the given node, ie. the sum of its distance from all other nodes, where the distance from one vertex to another is given by the associated cost of the Edge joining the two nodes.
       * @param vertex Vertex, or Vertex ID, to retrieve farness for.
       * @returns Vertex's "farness".
       */

    }, {
      key: "getFarness",
      value: function getFarness(vertex) {
        var vnode = this.getVertex(vertex); // sum all of its paths to every other node.

        var info = djikstra({
          graph: this,
          source: vnode,
          target: vnode,
          processAll: true
        });
        var total = 0;

        for (var i in info.dist) {
          total += info.dist[i];
        }

        return total / (this.getVertexCount() - 1);
      }
      /**
       * Returns the betweenness centrality of the given node.
       * @param vertex Vertex, or Vertex ID, to retrieve betweenness centrality for.
       * @returns Vertex's "betweenness" centrality.
       */

    }, {
      key: "getBetweenness",
      value: function getBetweenness(vertex) {
        var n = this.getVertexCount(),
            denominator = (n - 1) * (n - 2) / 2,
            betweenness = 0,
            processNode = function processNode(source, target, info, pathFromTarget, paths) {
          var parents = info.parents[source][target];

          if (parents.length == 0) {
            var p = pathFromTarget.slice();
            p.unshift(source);
            paths.push(p);
          } else {
            for (var i = 0; i < parents.length; i++) {
              if (pathFromTarget.indexOf(parents[i][0].id) == -1) {
                var _p = pathFromTarget.slice();

                _p.unshift(parents[i][0].id);

                processNode(source, parents[i][0].id, info, _p, paths);
              }
            }
          }
        };

        var vnode = this.getVertex(vertex);
        var info = floydWarshall({
          graph: this,
          focus: vnode
        }); // for each vertex pair, retrieve the actual paths.  there may be multiple shortest paths for one given vertex
        // pair, and we use the 'parents' array to help with this. its a 2d array containing null for [v1,v1],
        // and an array of N entries for every [v1,vX]. N may be zero, which indicates that vN is adjacent to
        // v1. if it is greater than zero then it tells you how many nodes adjacent to vN are on shortest paths,
        // but note that it _does not_ tell you how many shortest paths join to vN.  we have to recurse back from
        // vN to each parent in this array, and look at that parent's entry; it will also be an array of N entries where
        // N may be zero or more.  we recurse up this parent array until we hit the trivial case - that N = 0.
        // as we go up the tree we can compare each vertex to see if it is the vertex for which we are computing
        // betweenness. remember that it only counts if the vertex is on the path, not the source or target.

        for (var v1 in info.paths) {
          for (var v2 in info.paths[v1]) {
            // v1 and v2 are the ids of our two nodes
            if (v1 != v2) {
              var pathsForPair = [];
              var pathsUsingFocusNode = 0;
              processNode(v1, v2, info, [v2], pathsForPair);

              for (var i = 0; i < pathsForPair.length; i++) {
                var idx = pathsForPair[i].indexOf(vnode.id);

                if (idx > 0 && idx < pathsForPair[i].length - 1) {
                  pathsUsingFocusNode++;
                }
              }

              betweenness += pathsUsingFocusNode / pathsForPair.length;
            }
          }
        }

        return betweenness / denominator;
      }
    }, {
      key: "inspect",
      value: function inspect() {
        var r = "";

        for (var i = 0; i < this.nodes.length; i++) {
          r += this.nodes[i].inspect() + "\n";
        }

        return r;
      }
    }, {
      key: "serialize",
      value: function serialize() {
        var out = {
          nodes: [],
          edges: [],
          ports: [],
          groups: []
        },
            n,
            e,
            p,
            g;

        for (var i = 0; i < this.nodes.length; i++) {
          n = this.nodes[i];
          out.nodes.push(extend({}, n.data));
          e = n.getAllEdges();
          p = n.getPorts();

          for (var j = 0; j < e.length; j++) {
            if (e[j].source == n || e[j].source.objectType === Port.objectType && e[j].source.getParent() == n) {
              var ee = {
                source: e[j].source.getFullId(),
                target: e[j].target.getFullId()
              };

              if (e[j].data) {
                ee.data = extend({}, e[j].data);
              }

              if (e[j].geometry) {
                ee.geometry = extend({}, e[j].geometry);
              }

              out.edges.push(ee);
            }
          }

          for (var l = 0; l < p.length; l++) {
            var le = {};

            for (var m in p[l].data) {
              le[m] = p[l].data[m];
            }

            le.id = p[l].getFullId();
            out.ports.push(le);
          }
        }

        for (var _i2 = 0; _i2 < this.groups.length; _i2++) {
          g = this.groups[_i2];
          out.groups.push(extend({}, g.data));
          e = g.getEdges();

          for (var _j = 0; _j < e.length; _j++) {
            if (e[_j].source === g) {
              var _ee = {
                source: g.getFullId(),
                target: e[_j].target.getFullId()
              };

              if (e[_j].data) {
                _ee.data = extend({}, e[_j].data);
              }

              if (e[_j].geometry) {
                _ee.geometry = extend({}, e[_j].geometry);
              }

              out.edges.push(_ee);
            }
          }
        }

        return out;
      }
      /**
       * Calculates "clusters" of nodes (and groups), where a 'cluster' is a set of Nodes/Groups that
       * are connected. Direction of connections is not taken into account. Nodes that are children of Groups are
       * included in all cluster calculations, which might cause some weird situations, but this functionality
       * is mostly intended just for Nodes anyway.
       * @returns An array of arrays, each entry being a list of nodes in the cluster.
       */

    }, {
      key: "getClusters",
      value: function getClusters() {
        var clusters = [],
            visited = {},
            n;

        var _one = function _one(seed, cluster) {
          if (seed == null || visited[seed.id]) return;

          if (cluster == null) {
            cluster = new Cluster(seed);
            clusters.push(cluster);
          } else {
            cluster.addVertex(seed);
          }

          visited[seed.id] = true;
          var e = seed.getAllEdges();

          for (var i = 0; i < e.length; i++) {
            var _o = e[i].source === seed ? e[i].target : e[i].source;

            _one(_o, cluster);
          }
        };

        for (n = 0; n < this.nodes.length; n++) {
          _one(this.nodes[n]);
        }

        for (n = 0; n < this.groups.length; n++) {
          _one(this.groups[n]);
        }

        return clusters;
      }
    }]);

    return Graph;
  }();
  var Base = /*#__PURE__*/function () {
    function Base(graph, data) {
      _classCallCheck$d(this, Base);

      this.graph = graph;
      this.data = data;

      _defineProperty$c(this, "atts", new Map());

      _defineProperty$c(this, "type", void 0);

      _defineProperty$c(this, "objectType", void 0);

      this.data = this.data || {};
      this.type = graph.getType(this.data);
    }

    _createClass$d(Base, [{
      key: "setAttribute",
      value: function setAttribute(key, value) {
        this.atts.set(key, value);
      }
    }, {
      key: "getAttribute",
      value: function getAttribute(key) {
        return this.atts.get(key);
      }
    }, {
      key: "getType",
      value: function getType() {
        return this.type;
      }
    }, {
      key: "setType",
      value: function setType(t) {
        this.type = t;
      }
    }]);

    return Base;
  }();
  var Vertex = /*#__PURE__*/function (_Base) {
    _inherits$8(Vertex, _Base);

    var _super = _createSuper$8(Vertex);

    /**
     * The vertex's id. A string.
     */

    /**
     * The vertex's internal id. not part of the API.
     */

    /**
     * Data associated with the vertex.
     */
    function Vertex(graph, data, idFunction) {
      var _this3;

      _classCallCheck$d(this, Vertex);

      _this3 = _super.call(this, graph, data);
      _this3.graph = graph;
      _this3.idFunction = idFunction;

      _defineProperty$c(_assertThisInitialized$8(_this3), "id", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this3), "_id", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this3), "data", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this3), "edges", []);

      _defineProperty$c(_assertThisInitialized$8(_this3), "indegreeCentrality", 0);

      _defineProperty$c(_assertThisInitialized$8(_this3), "outdegreeCentrality", 0);

      _defineProperty$c(_assertThisInitialized$8(_this3), "nestedGraphs", []);

      _defineProperty$c(_assertThisInitialized$8(_this3), "graphs", []);

      _this3.id = graph.getId(data, idFunction);
      _this3.data = typeof data === 'string' ? {
        id: data
      } : data;
      return _this3;
    }

    _createClass$d(Vertex, [{
      key: "getIndegreeCentrality",
      value: function getIndegreeCentrality() {
        return this.indegreeCentrality;
      }
    }, {
      key: "getOutdegreeCentrality",
      value: function getOutdegreeCentrality() {
        return this.outdegreeCentrality;
      }
      /**
       * Adds a sub-graph to this vertex. If you provide an existing Graph instance that does not have
       * an id, one will be assigned.
            * @param Graph|string g Either a Graph instance, or the id you wish to assign to a new Graph.
       * @returns The Graph that was added.
       */

    }, {
      key: "addGraph",
      value: function addGraph(g) {
        g = typeof g === "string" ? new Graph({
          id: g
        }) : g;
        this.graphs.push(g);
        if (!g.id) g.id = "" + this.graphs.length;
        return g;
      }
      /**
       * Retrieves a sub-graph by id.
            * @returns Sub-graph with the given id, null if not found.
       */

    }, {
      key: "getGraph",
      value: function getGraph(id) {
        for (var i = 0; i < this.graphs.length; i++) {
          if (this.graphs[i].id === id) return this.graphs[i];
        }
      }
      /**
       * Gets the Vertex's id, which, for Nodes and Groups, is just the `id` property. This method is overridden by Ports.
            * @returns Vertex id
       */

    }, {
      key: "getFullId",
      value: function getFullId() {
        return this.id;
      }
      /**
       * Gets all Edges where this Vertex is either the source or the target of the Edge.
       * Note that this does *not* retrieve Edges on any Ports associated with this Vertex - for that, @see #getAllEdges.
       * @param params.filter Optional function to test whether a given edge should be included.
       * @returns List of matching edges.
       */

    }, {
      key: "getEdges",
      value: function getEdges(params) {
        if (params == null || params.filter == null) return this.edges;else {
          var out = [];

          for (var i = 0; i < this.edges.length; i++) {
            if (params.filter(this.edges[i])) {
              out.push(this.edges[i]);
            }
          }

          return out;
        }
      }
    }, {
      key: "getAllEdges",
      value: function getAllEdges(params) {
        return this.getEdges(params);
      }
      /**
       * Gets all Edges where this Vertex is the source.
       */

    }, {
      key: "getSourceEdges",
      value: function getSourceEdges() {
        var _this4 = this;

        return this.getEdges({
          filter: function filter(e) {
            return e.source == _this4;
          }
        });
      }
      /**
       * Gets all Edges where this Vertex is the target.
       */

    }, {
      key: "getTargetEdges",
      value: function getTargetEdges() {
        var _this5 = this;

        return this.getEdges({
          filter: function filter(e) {
            return e.target == _this5;
          }
        });
      }
      /**
       * Adds an Edge to the vertex.
            * @param edge The Edge to add.
       */

    }, {
      key: "addEdge",
      value: function addEdge(edge) {
        this.edges.push(edge);

        if (edge.source === this || !edge.isDirected()) {
          this.outdegreeCentrality++;
        }

        if (edge.target === this || !edge.isDirected()) {
          this.indegreeCentrality++;
        }
      }
      /**
       * Deletes an Edge from the Vertex.
            * @param edge The Edge to delete.
       */

    }, {
      key: "deleteEdge",
      value: function deleteEdge(edge) {
        var idx = -1;

        for (var i = 0; i < this.edges.length; i++) {
          if (this.edges[i].getId() === edge.getId()) {
            idx = i;
            break;
          }
        }

        if (idx > -1) {
          this.edges.splice(idx, 1);

          if (edge.source === this || !edge.isDirected()) {
            this.outdegreeCentrality--;
          }

          if (edge.target === this || !edge.isDirected()) {
            this.indegreeCentrality--;
          }

          return true;
        }

        return false;
      }
      /**
       * Returns a string representation of the Vertex.
            * @returns Vertex dumped to a string.
       */

    }, {
      key: "inspect",
      value: function inspect() {
        var i = "{ id:" + this.id + ", edges:[\n";

        for (var j = 0; j < this.edges.length; j++) {
          i += this.edges[j].inspect() + "\n";
        }

        i += "]}";
        return i;
      }
    }, {
      key: "isChildOf",
      value: function isChildOf(v) {
        return false;
      }
    }]);

    return Vertex;
  }(Base);
  var Node = /*#__PURE__*/function (_Vertex) {
    _inherits$8(Node, _Vertex);

    var _super2 = _createSuper$8(Node);

    function Node(graph, data, idFunction) {
      var _this6;

      _classCallCheck$d(this, Node);

      _this6 = _super2.call(this, graph, data, idFunction);

      _defineProperty$c(_assertThisInitialized$8(_this6), "objectType", Node.objectType);

      _defineProperty$c(_assertThisInitialized$8(_this6), "ports", []);

      _defineProperty$c(_assertThisInitialized$8(_this6), "group", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this6), "portMap", {});

      _defineProperty$c(_assertThisInitialized$8(_this6), "defaultInternalCost", 0);

      _defineProperty$c(_assertThisInitialized$8(_this6), "internalEdges", {});

      return _this6;
    }
    /**
     * Gets all of the Edges connected to this Node, both on the Node itself and on all of its Ports.
     * @param params Method parameters.
     * @param params.filter Optional Edge filter.
     */


    _createClass$d(Node, [{
      key: "getAllEdges",
      value: function getAllEdges(params) {
        var e = this.getEdges(params).slice(0);

        for (var i = 0; i < this.ports.length; i++) {
          e.push.apply(e, this.ports[i].getEdges(params));
        }

        return e;
      }
      /**
       * Gets all of the Edges connected to this Node, both on the Node itself and on all of its Ports, where this node/port is the source of edge
       */

    }, {
      key: "getAllSourceEdges",
      value: function getAllSourceEdges() {
        var e = this.getSourceEdges().slice(0);

        for (var i = 0; i < this.ports.length; i++) {
          e.push.apply(e, this.ports[i].getSourceEdges());
        }

        return e;
      }
      /**
       * Gets all of the Edges connected to this Node, both on the Node itself and on all of its Ports, where this node/port is the target of edge
       */

    }, {
      key: "getAllTargetEdges",
      value: function getAllTargetEdges() {
        var e = this.getTargetEdges().slice(0);

        for (var i = 0; i < this.ports.length; i++) {
          e.push.apply(e, this.ports[i].getTargetEdges());
        }

        return e;
      }
      /**
       * Gets all Edges directly connected to this Vertex, ie. not to one of the Ports on the Vertex. This is an alias for `getEdges`.
       * @param params Method parameters.
       * @param params.filter Optional Edge filter.
       */

    }, {
      key: "getDirectEdges",
      value: function getDirectEdges(params) {
        return this.getEdges(params);
      }
      /**
       * Gets all Edges directly connected to this Vertex, ie. not to one of the Ports on the Vertex, where this Vertex is the source.
       * This is an alias for `getSourceEdges`.
       */

    }, {
      key: "getDirectSourceEdges",
      value: function getDirectSourceEdges() {
        return this.getSourceEdges();
      }
      /**
       * Gets all Edges directly connected to this Vertex, ie. not to one of the Ports on the Vertex, where this Vertex is the target.
       * This is an alias for `getTargetEdges`.
       */

    }, {
      key: "getDirectTargetEdges",
      value: function getDirectTargetEdges() {
        return this.getTargetEdges();
      }
      /**
       * Gets all Edges that are connected to Ports on this Node, not directly to the Node itself.
       * @param params
       */

    }, {
      key: "getPortEdges",
      value: function getPortEdges(params) {
        var e = [];

        for (var i = 0; i < this.ports.length; i++) {
          e.push.apply(e, this.ports[i].getEdges(params));
        }

        return e;
      }
      /**
       * Gets all Edges that are connected to Ports on this Node, not directly to the Node itself, where the Port on this Node is the source of the edge.
       */

    }, {
      key: "getPortSourceEdges",
      value: function getPortSourceEdges() {
        var e = [];

        for (var i = 0; i < this.ports.length; i++) {
          e.push.apply(e, this.ports[i].getSourceEdges());
        }

        return e;
      }
      /**
       * Gets all Edges that are connected to Ports on this Node, not directly to the Node itself, where the Port on this Node is the target of the edge.
       */

    }, {
      key: "getPortTargetEdges",
      value: function getPortTargetEdges() {
        var e = [];

        for (var i = 0; i < this.ports.length; i++) {
          e.push.apply(e, this.ports[i].getTargetEdges());
        }

        return e;
      }
      /**
       * Gets this Node's "indegree" centrality; a measure of how many other Nodes are connected to this Node as the target of some Edge.
       */

    }, {
      key: "getIndegreeCentrality",
      value: function getIndegreeCentrality() {
        var pc = 0;

        for (var i = 0; i < this.ports.length; i++) {
          pc += this.ports[i].getIndegreeCentrality();
        }

        return this.indegreeCentrality + pc;
      }
      /**
       * Gets this Node's "outdegree" centrality; a measure of how many other Nodes this Node is connected to as the source of some Edge.
       */

    }, {
      key: "getOutdegreeCentrality",
      value: function getOutdegreeCentrality() {
        var pc = 0;

        for (var i = 0; i < this.ports.length; i++) {
          pc += this.ports[i].getOutdegreeCentrality();
        }

        return this.outdegreeCentrality + pc;
      }
      /**
       * Gets all Ports associated with this Node.
       */

    }, {
      key: "getPorts",
      value: function getPorts() {
        return this.ports;
      }
      /**
       * Adds a Port to the Node.
       * @param data Optional data backing the Port. This object can be of any type you like.
       * @param idFunction Optional function that can take a Port's data and return its ID. By default this looks for an `id` member in the backing data.
       */

    }, {
      key: "addPort",
      value: function addPort(data, idFunction) {
        var id = this.graph.getId(data, idFunction),
            p = this.getPort(id);

        if (p == null) {
          p = new Port(this, data, idFunction);
          this.ports.push(p);
          this.portMap[p.id] = p;
        }

        return p;
      }
      /**
       * Sets the underlying data for the Port with the given id.  If the Port does not yet exist, it is created.
       * @param id Id of the Port for which to set data.
       * @param data Data to set for the Port.
       */

    }, {
      key: "setPort",
      value: function setPort(id, data) {
        var p = this.getPort(id);

        if (!p) {
          p = this.addPort({
            id: id
          });
        }

        p.data = data;
        p.setType(this.graph.getType(data));
        return p;
      }
      /**
       * Gets the Port with the given id, null if nothing found.
       * @param portId Port id.
       */

    }, {
      key: "getPort",
      value: function getPort(portId) {
        return this.portMap[portId];
      }
    }, {
      key: "_portId",
      value: function _portId(port) {
        return port instanceof Port ? port.id : port;
      }
    }, {
      key: "renamePort",
      value: function renamePort(port, newId) {
        if (this.portMap[port.id]) {
          this.portMap[newId] = this.portMap[port.id];
          delete this.portMap[port.id];
          return true;
        } else {
          return false;
        }
      }
      /**
       * Removes the given Port.
       * @param port Either a Port, or a port id.
       */

    }, {
      key: "removePort",
      value: function removePort(port) {
        var exists = false;

        if (port) {
          var id = this._portId(port),
              idx = -1;

          for (var i = 0; i < this.ports.length; i++) {
            if (this.ports[i].id === id) {
              idx = i;
              break;
            }
          }

          if (idx != -1) {
            var p = this.ports[idx];
            this.graph.deletePort(p);
            this.ports.splice(idx, 1);
            exists = true;
          }

          delete this.portMap[id];
        }

        return exists;
      }
      /**
       * Sets the default cost of travelling from one Port to another inside some Node. When a Node is created, this value is set to 1.
       * @param cost Default internal cost.
       */

    }, {
      key: "setDefaultInternalCost",
      value: function setDefaultInternalCost(cost) {
        this.defaultInternalCost = cost;
      }
      /**
       * Gets an "internal" Edge from one Port to another.
       * @param source Source Port.
       * @param target Target Port.
       */

    }, {
      key: "getInternalEdge",
      value: function getInternalEdge(source, target) {
        var spid = this._portId(source),
            tpid = this._portId(target),
            out = {
          source: this.portMap[spid],
          target: this.portMap[tpid],
          cost: Infinity
        };

        if (out.source && out.target) {
          var ie = this.internalEdges[spid + "-" + tpid] || {
            cost: this.defaultInternalCost,
            directed: false
          };

          for (var i in ie) {
            out[i] = ie[i];
          }
        }

        return out;
      }
      /**
       * Sets the cost and directedness of some internal Edge.
       * @param source Source Port.
       * @param target Target Port.
       * @param cost Cost to set. If you leave this as null, the default will be used.
       * @param directed Whether or not the internal Edge is directed.
       */

    }, {
      key: "setInternalEdge",
      value: function setInternalEdge(source, target, cost, directed) {
        var spid = this._portId(source),
            tpid = this._portId(target);

        this.internalEdges[spid + "-" + tpid] = {
          cost: cost || this.defaultInternalCost,
          directed: directed
        };
        return this.getInternalEdge(source, target);
      }
    }]);

    return Node;
  }(Vertex);

  _defineProperty$c(Node, "objectType", "Node");

  var Port = /*#__PURE__*/function (_Vertex2) {
    _inherits$8(Port, _Vertex2);

    var _super3 = _createSuper$8(Port);

    function Port(parent, data, idFunction) {
      var _this7;

      _classCallCheck$d(this, Port);

      _this7 = _super3.call(this, parent.graph, data, idFunction);
      _this7.parent = parent;

      _defineProperty$c(_assertThisInitialized$8(_this7), "objectType", Port.objectType);

      return _this7;
    }
    /**
     * Gets the vertex this Port belongs to. Remember that Group extends Node, so this could be a Group, but Ports cannot have child Ports.
     */


    _createClass$d(Port, [{
      key: "getParent",
      value: function getParent() {
        return this.parent;
      }
      /**
       * Overrides the `getFullId` of Node to return a value in dotted notation of the form `nodeId.portId`.
       */

    }, {
      key: "getFullId",
      value: function getFullId() {
        return this.parent.id + this.graph.getPortSeparator() + this.id;
      }
      /**
       * Returns whether or not this port is a child of the given object.
       * @param v Object to test if this is a child.
       */

    }, {
      key: "isChildOf",
      value: function isChildOf(v) {
        return this.parent === v;
      }
    }]);

    return Port;
  }(Vertex);

  _defineProperty$c(Port, "objectType", "Port");

  var Group = /*#__PURE__*/function (_Node) {
    _inherits$8(Group, _Node);

    var _super4 = _createSuper$8(Group);

    function Group(graph, data, idFunction) {
      var _this8;

      _classCallCheck$d(this, Group);

      _this8 = _super4.call(this, graph, data, idFunction);

      _defineProperty$c(_assertThisInitialized$8(_this8), "objectType", Group.objectType);

      _defineProperty$c(_assertThisInitialized$8(_this8), "members", []);

      _defineProperty$c(_assertThisInitialized$8(_this8), "_memberMap", {});

      return _this8;
    }

    _createClass$d(Group, [{
      key: "addMember",
      value: function addMember(v) {
        if (this._memberMap[v.id] != null) {
          return false;
        } else {
          this.members.push(v);
          this._memberMap[v.id] = v;
          v.group = this;
          return true;
        }
      }
    }, {
      key: "getMemberCount",
      value: function getMemberCount() {
        return this.members.length;
      }
    }, {
      key: "getMembers",
      value: function getMembers() {
        return this.members;
      }
    }, {
      key: "removeMember",
      value: function removeMember(v) {
        var n = typeof v === "string" ? this._memberMap[v] : v;

        if (n) {
          var idx = this.members.indexOf(n);

          if (idx != -1) {
            this.members.splice(idx, 1);
            delete this._memberMap[n.id];
          }

          delete n.group;
          return true;
        } else {
          return false;
        }
      }
    }, {
      key: "getAllDirectEdges",
      value: function getAllDirectEdges(params) {
        var e = [],
            i;
        e.push.apply(e, this.getEdges(params).slice(0));
        var ports = this.getPorts();

        for (i = 0; i < ports.length; i++) {
          e.push.apply(e, ports[i].getEdges(params));
        }

        return e;
      }
      /**
       * Gets all the edges from the Group, any Ports the Group has, and any Edges from any Nodes contained in
       * the Group.
            * @param params
       * @returns
       */

    }, {
      key: "getAllEdges",
      value: function getAllEdges(params) {
        var e = [],
            eMap = {};

        for (var i = 0; i < this.members.length; i++) {
          Array.prototype.push.apply(e, this.members[i].getAllEdges(params).filter(function (ve) {
            var eid = ve.getId(),
                ok = eMap[eid] == null;
            eMap[eid] = true;
            return ok;
          }));
        } // now edges on this object itself


        e.push.apply(e, this.getAllDirectEdges(params));
        return e;
      }
    }]);

    return Group;
  }(Node);

  _defineProperty$c(Group, "objectType", "Group");

  var Edge = /*#__PURE__*/function (_Base2) {
    _inherits$8(Edge, _Base2);

    var _super5 = _createSuper$8(Edge);

    /**
     * Source of the Edge.
     */

    /**
     * Target of the Edge.
     */

    /**
     * Edge cost
     */
    function Edge(params) {
      var _this9;

      _classCallCheck$d(this, Edge);

      _this9 = _super5.call(this, params.graph, params.data);

      _defineProperty$c(_assertThisInitialized$8(_this9), "objectType", Edge.objectType);

      _defineProperty$c(_assertThisInitialized$8(_this9), "source", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this9), "target", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this9), "cost", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this9), "directed", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this9), "id", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this9), "connectionId", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this9), "geometry", void 0);

      _this9.source = params.source;
      _this9.target = params.target;
      _this9.cost = params.cost || 1;
      _this9.directed = !(params.directed === false);
      _this9.id = params.id;
      return _this9;
    }
    /**
     * Gets the cost for this edge. Defaults to 1.
          * @returns Edge cost.
     */


    _createClass$d(Edge, [{
      key: "getCost",
      value: function getCost() {
        return this.cost;
      }
      /**
       * Sets the cost for this edge.
       * @param c Edge cost.
       */

    }, {
      key: "setCost",
      value: function setCost(c) {
        this.cost = c;
      }
      /**
       * Gets the id for this Edge.
            * @returns Edge id.
       */

    }, {
      key: "getId",
      value: function getId() {
        return this.id == null ? this.source.id + "_" + this.target.id : this.id;
      }
    }, {
      key: "getFullId",
      value: function getFullId() {
        return this.getId();
      }
    }, {
      key: "setId",
      value: function setId(id) {
        this.id = id;
      }
      /**
       * Gets whether or not the Edge is directed.
            * @returns True if the Edge is directed (unidirectional), false otherwise.
       */

    }, {
      key: "isDirected",
      value: function isDirected() {
        return this.directed;
      }
      /**
       * Sets whether or not the Edge is directed.
            */

    }, {
      key: "setDirected",
      value: function setDirected(directed) {
        this.directed = directed;
      }
      /**
       * Returns a string representation of the Edge.
            * @returns Edge dumped to a string.
       */

    }, {
      key: "inspect",
      value: function inspect() {
        if (this.id != null) return "{ id:" + this.id + ", connectionId:" + this.connectionId + ", cost:" + this.cost + ", directed:" + this.directed + ", source:" + this.source.id + ", target:" + this.target.id + "}";
      }
    }]);

    return Edge;
  }(Base);

  _defineProperty$c(Edge, "objectType", "Edge");

  // https://www.redblobgames.com/pathfinding/a-star/introduction.html
  // for instance, the A* algorithm, which is much faster than Djikstra, on that page, and note that I havent at all looked into how
  // it could be ported to these DAGs

  // TODO don't use Record<string, ...> in here, use Map.
  function djikstra(params) {
    var graph = params.graph,
        source = params.source,
        target = params.target,
        nodeFilter = params.nodeFilter,
        edgeFilter = params.edgeFilter,
        dist = {},
        previous = {},
        edges = {},
        retVal = {
      dist: dist,
      previous: previous,
      edges: edges,
      path: []
    },
        processAll = params.processAll,
        portMap = {},
        nodeFromPortMap = {},
        strict = !(params.strict === false),
        _getId = function _getId(n) {
      return n.getFullId ? n.getFullId() : n.id;
    },
        _vertices = [],
        _getRelatedPorts = function _getRelatedPorts(p) {
      var n = nodeFromPortMap[p.getFullId()];
      return portMap[n.v.id];
    },
        _setDist = function _setDist(o, v) {
      var pp, i; // if o is a node, v is applied to all ports also. otherwise, all other ports
      // for the node that is the parent of o are given v + internalEdgeCost, which may
      // vary by port.

      if (o.objectType === Port.objectType) {
        dist[o.getFullId()] = v; // it's a port.

        pp = _getRelatedPorts(o);

        for (i = 0; i < pp.length; i++) {
          if (pp[i].p != o) {
            dist[pp[i].p.getFullId()] = v + o.getParent().getInternalEdge(o, pp[i].p).cost;
          }
        }

        if (!strict) {
          dist[o.getParent().id] = v;
        }
      } else {
        dist[o.id] = v;
        pp = portMap[o.id];

        for (i = 0; i < pp.length; i++) {
          dist[pp[i].p.getFullId()] = v;
        }
      }
    },
        _getDist = function _getDist(o) {
      if (nodeFilter && !nodeFilter(o)) return Infinity;
      return dist[_getId(o)];
    },
        _setPrevious = function _setPrevious(n, nId, prevInfo) {
      if (n.objectType === Port.objectType) {
        var pp = _getRelatedPorts(n);

        for (var i = 0; i < pp.length; i++) {
          previous[pp[i].p.getFullId()] = prevInfo.node;
        }

        if (!strict) previous[n.getParent().id] = prevInfo.node;
      }

      previous[nId] = prevInfo.node;
    },
        _setEdge = function _setEdge(n, nId, edge) {
      if (n.objectType === Port.objectType) {
        var pp = _getRelatedPorts(n);

        for (var i = 0; i < pp.length; i++) {
          edges[pp[i].p.getFullId()] = edge;
        }

        if (!strict) edges[n.getParent().id] = edge;
      }

      edges[nId] = edge;
    },
        _findSmallestDist = function _findSmallestDist(vertices, usedVertices, dist, idFunc, _getDist) {
      var idx = -1,
          node = null,
          smallest = Infinity;

      for (var i = 0; i < vertices.length; i++) {
        if (!usedVertices[i]) {
          var d = _getDist(vertices[i]);

          if (d < smallest) {
            smallest = d;
            idx = i;
            node = vertices[i];
          } else if (d === smallest) {
            // here if the current smallest is a node, but we find a port that has the same distance as that node,
            // we prefer the port.
            if (vertices[i].objectType === Port.objectType && vertices[i].getParent() === node) {
              idx = i;
              node = vertices[i];
            }
          }
        }
      }

      return {
        node: node,
        index: idx
      };
    },
        _findPrev = function _findPrev(previous, obj) {
      var id = obj.getFullId(),
          p = previous[id];

      if (p == null) {
        id = obj.getParent ? obj.getParent().id : obj.id;
        p = previous[id];
      }

      return p == null ? null : {
        p: p,
        id: id
      };
    },

    /**
     assembles a path to the given target, using data from the 'dist' and 'previous' tables.  the source of the path is the source that was most recently passed in to the
     Djikstra.compute method.
     */
    _findPath = function _findPath(dist, previous, edges, target, idFunc, strict) {
      var path = [],
          u = target; //, uid = idFunc(u)

      var p = _findPrev(previous, u);

      while (p != null) {
        path.splice(0, 0, {
          vertex: u,
          cost: dist[p.id],
          edge: edges[p.id]
        });
        u = p.p; //uid = idFunc(u)

        p = _findPrev(previous, u); //uid = u.getNode ? u.getNode().id : u.id
      } // insert start vertex.


      path.splice(0, 0, {
        vertex: u,
        cost: 0,
        edge: null
      });
      return path;
    };

    for (var i = 0; i < graph.nodes.length; i++) {
      var v = graph.nodes[i],
          p = v.getPorts();

      _vertices.push(v);

      var nodeData = {
        v: v,
        i: _vertices.length - 1
      };
      portMap[v.id] = [];

      _setDist(v, Infinity);

      for (var j = 0; j < p.length; j++) {
        _vertices.push(p[j]);

        nodeFromPortMap[p[j].getFullId()] = nodeData;
        portMap[v.id].push({
          p: p[j],
          i: _vertices.length - 1
        });

        _setDist(p[j], Infinity);
      }
    }

    if (source == null) {
      source = graph.getVertex(params.sourceId);
    }

    if (target == null) {
      target = graph.getVertex(params.targetId);
    }

    if (source == null || target == null) {
      return retVal;
    }

    _setDist(source, 0);

    var completedNodes = new Array(graph.nodes.length),
        completed = 0,
        processEdges = function processEdges(nodeInfo, _edges, edgeSelector, neighbourSelector) {
      for (var _i = 0; _i < _edges.length; _i++) {
        var edge = _edges[_i];

        if (edgeSelector(edge)) {
          var neighbour = neighbourSelector(edge),
              neighbourObject = neighbour.tp || neighbour.tn,
              nid = _getId(neighbourObject);

          var alt = _getDist(nodeInfo.node) + edge.getCost(),
              d = _getDist(neighbourObject);

          if (alt < d) {
            _setDist(neighbourObject, alt);

            _setPrevious(neighbourObject, nid, nodeInfo);

            _setEdge(neighbourObject, nid, edge);
          }
        }
      }
    };

    var _loop = function _loop() {
      var curNodeInfo = _findSmallestDist(_vertices, completedNodes, dist, _getId, _getDist),
          curObjectId = curNodeInfo.node ? _getId(curNodeInfo.node) : null;

      if (!curNodeInfo.node || _getDist(curNodeInfo.node) == Infinity) return "break";

      if (target && (curObjectId == _getId(target) || !strict && curNodeInfo.node.objectType === Port.objectType && curNodeInfo.node.isChildOf(target))) {
        retVal.path = _findPath(dist, previous, edges, target);
        retVal.pathDistance = retVal.path[retVal.path.length - 1].cost;
        if (!processAll) return "break";
      }

      completedNodes[curNodeInfo.index] = true;
      completed = completed + 1; // here we get all edges for the node - port and all, and the edge selector function
      // filters out edges for which this node is not the source. It also uses the current
      // edgeFilter function, if one is set.

      processEdges(curNodeInfo, curNodeInfo.node.getAllEdges(), function (e) {
        if (edgeFilter && !edgeFilter(e)) return false;
        return !e.isDirected() || curNodeInfo.node == e.source || !strict && e.source.objectType === Port.objectType && e.source.isChildOf(curNodeInfo.node);
      }, // this is the neighbourSelector for some edge. it returns [targetNode, targetPort]
      // if the current node/port is the source, or source info otherwise.
      function (e) {
        var sn = e.source.objectType === Port.objectType ? e.source.getParent() : e.source,
            sp = e.source.objectType === Port.objectType ? e.source : null,
            tn = e.target.objectType === Port.objectType ? e.target.getParent() : e.target,
            tp = e.target.objectType === Port.objectType ? e.target : null;
        return e.source == curNodeInfo.node || !strict && e.source.objectType === Port.objectType && e.source.isChildOf(curNodeInfo.node) ? {
          tn: tn,
          tp: tp
        } : {
          tn: sn,
          tp: sp
        };
      });
    };

    while (completed < _vertices.length) {
      var _ret = _loop();

      if (_ret === "break") break;
    } // the shortcut exit does not get here; this function returns two different types of value!


    return retVal;
  }

  /**
   * Base interface a for data model.
   * @internal
   */

  /**
   * @internal
   */
  var DataModel = /*#__PURE__*/function () {
    function DataModel(toolkit, def) {
      _classCallCheck$d(this, DataModel);

      this.toolkit = toolkit;

      _defineProperty$c(this, "nodeDefinitions", new Map());

      _defineProperty$c(this, "groupDefinitions", new Map());

      _defineProperty$c(this, "portDefinitions", new Map());

      if (def != null) {
        var n = def.nodes || {};

        for (var k in n) {
          this.nodeDefinitions.set(k, n[k]);
        }

        var g = def.groups || {};

        for (var _k in g) {
          this.groupDefinitions.set(_k, g[_k]);
        }

        var p = def.ports || {};

        for (var _k2 in p) {
          this.portDefinitions.set(_k2, p[_k2]);
        }
      }
    }

    _createClass$d(DataModel, [{
      key: "getNodeDefinition",
      value: function getNodeDefinition(type) {
        return this.nodeDefinitions.get(type) || {};
      }
    }, {
      key: "getGroupDefinition",
      value: function getGroupDefinition(type) {
        return this.groupDefinitions.get(type) || {};
      }
    }, {
      key: "getPortDefinition",
      value: function getPortDefinition(type) {
        return this.portDefinitions.get(type) || {};
      }
    }]);

    return DataModel;
  }();

  /**
   * Models the path between two Nodes/Ports, which consists of a series of [Group/Node/Port, Edge] pairs.
   */
  var Path = /*#__PURE__*/function () {
    /**
     * @param toolkit toolkit instance from which to get the path info.
     * @param params Path specification
     */
    function Path(toolkit, params) {
      _classCallCheck$d(this, Path);

      this.toolkit = toolkit;

      _defineProperty$c(this, "result", void 0);

      _defineProperty$c(this, "vertices", []);

      _defineProperty$c(this, "vertexMap", {});

      this.result = toolkit.getGraph().findPath(params.source, params.target, params.strict, params.nodeFilter, params.edgeFilter);

      for (var _i = 0; _i < this.result.path.length; _i++) {
        this.vertices.push(this.result.path[_i].vertex);
        this.vertexMap[this.result.path[_i].vertex.getFullId()] = [this.result.path[_i].vertex, _i];
      }
    }
    /**
     * Remove all of the edges in this path from the underlying Toolkit instance.
     */


    _createClass$d(Path, [{
      key: "deleteEdges",
      value: function deleteEdges() {
        // detach all edges in the path
        for (var _i2 = 0; _i2 < this.result.path.length; _i2++) {
          if (this.result.path[_i2].edge) {
            this.toolkit.removeEdge(this.result.path[_i2].edge);
          }
        }

        return this;
      }
      /**
       * Deletes all the nodes/groups in the path. As with the `contains` method, there is a special consideration here: if
       * a path passes through ports on a node/group, then that node/group will be, for the purposes of this method,
       * considered to be part of the path and it will be deleted.  If you instead wish to delete only the ports in a
       * path, use `deletePorts`.  Note that this method will, of course, have the effect of also deleting all the edges,
       * since the nodes/groups for those edges will no longer exist.
       */

    }, {
      key: "deleteVertices",
      value: function deleteVertices() {
        for (var _i3 = 0; _i3 < this.result.path.length; _i3++) {
          this.toolkit.removeNode(this.result.path[_i3].vertex);
        }

        return this;
      }
      /**
       * Returns true if the path contains the given object (a node, group, port or edge), false otherwise.
       * @param obj Node/Port/Edge, or object id, of the element to test for.
       * @param doNotFuzzyMatchNodes By default,
       * if you pass a node/group in to this method and the path passes through a port on that node/group, this method
       * returns true. But if you set `doNotFuzzyMatchNodes` to true, then this method will return true only if the node/group itself is on the path.
       * @returns True if Path contains the object, false otherwise.
       */

    }, {
      key: "contains",
      value: function contains(obj, doNotFuzzyMatchNodes) {
        var gObj = this.toolkit.findGraphObject(obj),
            c = false;

        if (gObj) {
          for (var _i4 = 0; _i4 < this.result.path.length; _i4++) {
            if (this.result.path[_i4].vertex == gObj || this.result.path[_i4].edge == gObj || !doNotFuzzyMatchNodes && this.result.path[_i4].vertex.objectType == Port.objectType && this.result.path[_i4].vertex.isChildOf(gObj)) {
              c = true;
              break;
            }
          }
        }

        return c;
      }
      /**
       * Get all the vertices in the path.
       */

    }, {
      key: "getVertices",
      value: function getVertices() {
        return this.vertices;
      }
      /**
       * Retrieve the specified vertex from the path
       * @param obj Either a vertex ID or a node/group/port.
       * @returns A Vertex, if the given vertex is in the path, otherwise null.
       */

    }, {
      key: "getVertex",
      value: function getVertex(obj) {
        return this.vertexMap[typeof obj === "string" ? obj : obj.id][0];
      }
      /**
       * Gets all the edges in the path that are connected to the given vertex.
       * @param v Vertex to get edges for.
       */

    }, {
      key: "getAllEdgesFor",
      value: function getAllEdgesFor(v) {
        var idx = this.vertexMap[v.id][1];

        if (idx < this.result.path.length - 1) {
          return [this.result.path[idx + 1].edge];
        } else return [];
      }
    }, {
      key: "filter",
      value: function filter(spec, includePartials) {
        console.log("not implemented.");
      }
    }, {
      key: "_each",
      value: function _each(dispatcher, startAt) {
        for (var _i5 = startAt || 0; _i5 < this.result.path.length; _i5++) {
          try {
            dispatcher(_i5, this.result.path[_i5]);
          } catch (e) {
            console.log("Path iterator function failed", e);
          }
        }
      }
      /**
       * Iterates through the path one step at a time. Each step consists of an object containing a
       * `vertex`, and, for all entries except the first, an `edge` member, which supplies the Edge that links
       * to the Vertex (which is why it is null for the first entry).
       * @param fn Function to call for each step.
       */

    }, {
      key: "each",
      value: function each(fn) {
        this._each(function (i, p) {
          fn(i, p);
        });
      }
      /**
       * Iterates through the Nodes/Groups/Ports in the path one step at a time.
       * @param fn Function to call for each step.
       */

    }, {
      key: "eachVertex",
      value: function eachVertex(fn) {
        this._each(function (i, p) {
          fn(i, p.vertex);
        });
      }
      /**
       * Iterates through the Edges in the path one step at a time. There is always one fewer Edges than Nodes/Ports.
       * @param fn Function to call for each step.
       */

    }, {
      key: "eachEdge",
      value: function eachEdge(fn) {
        this._each(function (i, p) {
          fn(i, p.edge);
        }, 1);
      }
      /**
       * Iterates through the Nodes in the path one step at a time.
       * @param fn Function to call for each step.
       */

    }, {
      key: "eachNode",
      value: function eachNode(fn) {
        this._each(function (i, p) {
          if (isNode(p.vertex)) {
            fn(i, p.vertex);
          }
        });
      }
      /**
       * Iterates through the Groups in the path one step at a time.
       * @param fn Function to call for each step.
       */

    }, {
      key: "eachGroup",
      value: function eachGroup(fn) {
        this._each(function (i, p) {
          if (isGroup(p.vertex)) {
            fn(i, p.vertex);
          }
        });
      }
      /**
       * Counts the number of vertices in the Path (including the start and end nodes/groups).  Note that for the
       * purposes of this calculation, a Port is considered a vertex, as is a Group.
       */

    }, {
      key: "getVertexCount",
      value: function getVertexCount() {
        return this.result.path.length;
      }
      /**
       * Gets the Vertex at the given index in the path.
       * @param idx Index of the vertex to retrieve.
       * @returns vertex at the given index, or null if no vertex exists at the given index.
       */

    }, {
      key: "getNodeAt",
      value: function getNodeAt(idx) {
        return this.result.path[idx].vertex;
      }
      /**
       * Counts the number of edges in the path.  This may be zero, if the given path spec did not select a valid path in the Toolkit instance.
       */

    }, {
      key: "getEdgeCount",
      value: function getEdgeCount() {
        return this.result.path.length == 0 ? 0 : this.result.path.length - 1;
      }
      /**
       * Gets the Edge at the given index in the Path.
       * @param idx Index of the Edge to retrieve. You can use negative numbers here: an index of -1 means get the last edge.
       * An index of -2 means get the last but one. etc.
       */

    }, {
      key: "getEdgeAt",
      value: function getEdgeAt(idx) {
        if (idx < 0) idx = this.result.path.length - 1 + idx;
        return this.result.path.length > idx + 1 ? this.result.path[idx + 1].edge : null;
      }
      /**
       * Removes all vertices and edges in this path from the underlying Toolkit. This is an alias for `deleteVertices`, since
       * deleting a vertex causes its edges to also be deleted.
       */

    }, {
      key: "deleteAll",
      value: function deleteAll() {
        this.deleteVertices();
      }
      /**
       * Returns whether or not a given path is empty
       * @returns True if path is empty, false otherwise.
       */

    }, {
      key: "isEmpty",
      value: function isEmpty() {
        return this.result.path.length == 0;
      }
      /**
       * Gets the cost of the given path.  Edges in the Toolkit can have a cost associated with them (the default is 1), and so the cost of any given path is the sum of the cost of all of the edges in the path.
       * @returns Total cost of the Path. Null if path does not exist.
       */

    }, {
      key: "getCost",
      value: function getCost() {
        return this.result.pathDistance;
      }
      /**
       * Returns whether or not a given path exists.
       * @returns True if path exists, false otherwise.
       */

    }, {
      key: "exists",
      value: function exists() {
        return this.result.pathDistance != null;
      }
    }]);

    return Path;
  }();

  function _isOnEdge(r, axis, dim, v) {
    return r[axis] <= v && v <= r[axis] + r[dim];
  }

  var _xAdj = [function (r1, r2) {
    return r1.x + r1.w - r2.x;
  }, function (r1, r2) {
    return r1.x - (r2.x + r2.w);
  }],
      _yAdj = [function (r1, r2) {
    return r1.y + r1.h - r2.y;
  }, function (r1, r2) {
    return r1.y - (r2.y + r2.h);
  }],
      _adj = [null, [_xAdj[0], _yAdj[1]], [_xAdj[0], _yAdj[0]], [_xAdj[1], _yAdj[0]], [_xAdj[1], _yAdj[1]]],
      _genAdj = function _genAdj(r1, r2, m, b, s) {
    if (isNaN(m)) m = 0;
    var y = r2.y + r2.h,
        x = m == Infinity || m == -Infinity ? r2.x + r2.w / 2 : (y - b) / m,
        theta = Math.atan(m),
        rise,
        hyp,
        run;

    if (_isOnEdge(r2, "x", "w", x)) {
      rise = _adj[s][1](r1, r2);
      hyp = rise / Math.sin(theta);
      run = hyp * Math.cos(theta);
      return {
        x: run,
        y: rise
      };
    } else {
      run = _adj[s][0](r1, r2);
      hyp = run / Math.cos(theta);
      rise = hyp * Math.sin(theta);
      return {
        x: run,
        y: rise
      };
    }
  };

  function calculateSpacingAdjustment(r1, r2) {
    var c1 = r1.center || {
      x: r1.x + r1.w / 2,
      y: r1.y + r1.h / 2
    },
        c2 = r2.center || {
      x: r2.x + r2.w / 2,
      y: r2.y + r2.h / 2
    },
        m = gradient(c1, c2),
        s = quadrant(c1, c2),
        b = m == Infinity || m == -Infinity || isNaN(m) ? 0 : c1.y - m * c1.x;
    return _genAdj(r1, r2, m, b, s);
  }
  /**
   * Creates a rectangle centered around the point `o`, whose width and height are padded by `padding`.
   * @param origin
   * @param s
   * @param padding
   * @internal
   */

  function _paddedRectangle(origin, s, padding) {
    var w = s.w + 2 * padding.x;
    var h = s.h + 2 * padding.y;
    return {
      x: origin.x - w / 2,
      y: origin.y - h / 2,
      w: w,
      h: h
    };
  }

  function _convertElements(l) {
    var o = [];

    if (l == null) {
      return null;
    } else if (Array.isArray(l)) {
      var a = [];
      a.push.apply(a, l);
      return a;
    } else {
      for (var i in l) {
        o.push(l[i]);
      }
    }

    return o;
  }

  var DEFAULT_PADDING$2 = {
    x: 20,
    y: 20
  };
  /**
   * Offers a means to apply 'magnetization' to some list of elements, pushing them apart so that they do not overlap. For a given run of the magnetizer there
   * is the concept of a "focus" rectangle. The center of this rectangle is the point from which magnetization occurs, with elements being pushed out radially from this
   * point.  There are a few different scenarios:
   *
   * - execute magnetizer with a given origin, and affect all elements
   * - execute magnetizer on all elements, having first computed the center of them
   * - execute magnetizer using a specific element as the focus
   *
   */

  var Magnetizer = /*#__PURE__*/function () {
    function Magnetizer(params) {
      _classCallCheck$d(this, Magnetizer);

      _defineProperty$c(this, "origin", void 0);

      _defineProperty$c(this, "elements", void 0);

      _defineProperty$c(this, "debug", void 0);

      _defineProperty$c(this, "container", void 0);

      _defineProperty$c(this, "getContainerPosition", void 0);

      _defineProperty$c(this, "originDebugMarker", void 0);

      _defineProperty$c(this, "constrain", void 0);

      _defineProperty$c(this, "padding", void 0);

      _defineProperty$c(this, "filter", void 0);

      _defineProperty$c(this, "exclude", void 0);

      _defineProperty$c(this, "currentFocus", void 0);

      _defineProperty$c(this, "focusElement", null);

      _defineProperty$c(this, "getSize", void 0);

      _defineProperty$c(this, "getId", void 0);

      _defineProperty$c(this, "getPosition", void 0);

      _defineProperty$c(this, "setPosition", void 0);

      _defineProperty$c(this, "positionArray", []);

      _defineProperty$c(this, "positions", new Map());

      _defineProperty$c(this, "originalPositions", new Map());

      _defineProperty$c(this, "sizes", new Map());

      this.getPosition = params.getPosition;
      this.setPosition = params.setPosition;
      this.getId = params.getId;
      this.getSize = params.getSize;
      this.elements = _convertElements(params.elements || []);
      this.debug = params.debug === true;
      this.padding = params.padding || DEFAULT_PADDING$2;

      this.filter = params.filter || function (_) {
        return true;
      };

      this.exclude = params.exclude || function (_) {
        return false;
      };

      this.container = params.container;
      this.getContainerPosition = params.getContainerPosition;

      this.constrain = params.constrain || function (id, current, delta) {
        return delta;
      };
    }
    /**
     * Run the magnetizer using the specified origin.
     * @param origin
     * @param options
     */


    _createClass$d(Magnetizer, [{
      key: "executeAtPoint",
      value: function executeAtPoint(origin, options) {
        if (this.elements.length > 0) {
          this._updatePositions();

          this.setOrigin(origin);
          this.focusElement = null;
          return this._run(options);
        } else {
          return {};
        }
      }
      /**
       * Run the magnetizer using an origin computed to be the center of all elements.
       * @param options
       */

    }, {
      key: "executeAtCenter",
      value: function executeAtCenter(options) {
        if (this.elements.length > 0) {
          var extents = this._updatePositions();

          this.setOrigin({
            x: (extents[0] + extents[1]) / 2,
            y: (extents[2] + extents[3]) / 2
          });
          this.focusElement = null;
          return this._run(options);
        } else {
          return {};
        }
      }
      /**
       * Run the magnetizer with the given element as its focus - the focus element will not be shifted.
       * @param focus
       * @param options
       */

    }, {
      key: "executeWithFocus",
      value: function executeWithFocus(focus, options) {
        if (this.elements.length > 0) {
          this._updatePositions();

          this.focusElement = {
            id: focus,
            bounds: this.positions.get(focus)
          };
          this.setOrigin(this.focusElement.bounds.center);
          return this._run(options);
        } else {
          return {};
        }
      }
      /**
       * Snaps all elements to a grid. Returns a map of element IDs, representing all the elements that were moved.
       * @param grid
       */

    }, {
      key: "snapToGrid",
      value: function snapToGrid(grid) {
        var out = {};

        this._updatePositions();

        for (var i = 0; i < this.positionArray.length; i++) {
          var original = this.positions.get(this.positionArray[i].id);

          var _this$_snapPositionTo = this._snapPositionToGrid(this.positionArray[i].bounds, grid),
              moved = _this$_snapPositionTo.moved,
              pos = _this$_snapPositionTo.pos;

          if (moved) {
            out[this.positionArray[i].id] = {
              original: original,
              current: pos
            };
          }
        }

        this._positionElements(out);

        return out;
      }
    }, {
      key: "setElements",
      value: function setElements(_els) {
        this.elements = _convertElements(_els);
        return this;
      }
    }, {
      key: "addElement",
      value: function addElement(el, doNotTestForDuplicates) {
        if (el != null && (doNotTestForDuplicates || this.elements.indexOf(el) === -1)) {
          this.elements.push(el);
        }

        return this;
      }
    }, {
      key: "addElements",
      value: function addElements(els, doNotTestForDuplicates) {
        if (doNotTestForDuplicates) {
          Array.prototype.push.apply(this.elements, els);
        } else {
          for (var i = 0; i < els.length; i++) {
            this.addElement(els[i]);
          }
        }

        return this;
      }
    }, {
      key: "removeElement",
      value: function removeElement(el) {
        var idx = -1;

        for (var i = 0; i < this.elements.length; i++) {
          if (this.elements[i] === el) {
            idx = i;
            break;
          }
        }

        if (idx !== -1) this.elements.splice(idx, 1);
        return this;
      }
    }, {
      key: "reset",
      value: function reset() {
        this.elements.length = 0;
      }
    }, {
      key: "setOrigin",
      value: function setOrigin(o) {
        if (o != null) {
          this.origin = o;
        }
      }
    }, {
      key: "_updatePositions",
      value: function _updatePositions() {
        this.positionArray.length = 0;
        this.positions.clear();
        this.originalPositions.clear();
        this.sizes.clear();
        return this._computeExtents(this.elements);
      }
    }, {
      key: "_computeExtents",
      value: function _computeExtents(els) {
        var minx, miny, maxx, maxy;
        minx = miny = Infinity;
        maxx = maxy = -Infinity;

        for (var i = 0; i < els.length; i++) {
          var _p = this.getPosition(els[i]),
              s = this.getSize(els[i]),
              _id = this.getId(els[i]);

          var location = {
            x: _p.x,
            y: _p.y,
            w: s.w,
            h: s.h,
            center: {
              x: _p.x + s.w / 2,
              y: _p.y + s.h / 2
            }
          };
          this.positions.set(_id, location);
          this.originalPositions.set(_id, extend({}, location));
          this.positionArray.push({
            bounds: location,
            id: _id,
            element: els[i]
          });
          this.sizes.set(_id, s);
          minx = Math.min(minx, _p.x);
          miny = Math.min(miny, _p.y);
          maxx = Math.max(maxx, _p.x + s.w);
          maxy = Math.max(maxy, _p.y + s.h);
        }

        return [minx, maxx, miny, maxy];
      }
    }, {
      key: "_run",
      value: function _run(options) {
        var _movedElements = {};

        if (this.elements.length > 1) {
          options = options || {};
          var f = options.filter || this.filter;

          var _p2 = options.padding || DEFAULT_PADDING$2;

          var i = options.iterations;
          var e = options.exclude || this.exclude;

          if (options.gather) {
            extend(_movedElements, this._gather(_p2, this.constrain, f, e));
          }

          extend(_movedElements, this._magnetize(_p2, this.constrain, f, i, e, options.grid));
        }

        var out = {};

        for (var _id2 in _movedElements) {
          out[_id2] = {
            original: this.originalPositions.get(_id2),
            current: _movedElements[_id2]
          };
        }

        this._positionElements(out);

        return out;
      }
      /**
       * Snap the given box to the given grid, returning true if the box was moved.
       * @param pos
       * @param grid
       * @internal
       */

    }, {
      key: "_snapPositionToGrid",
      value: function _snapPositionToGrid(pos, grid) {
        var orig = {
          x: pos.x,
          y: pos.y
        };

        if (grid != null) {
          var snapped = snapToGrid(pos, grid);
          pos.x = snapped.x;
          pos.y = snapped.y;
          pos.center.x = pos.x + pos.w / 2;
          pos.center.y = pos.y + pos.h / 2;
        }

        return {
          moved: orig.x !== pos.x || orig.y !== pos.y,
          pos: pos
        };
      }
    }, {
      key: "_gather",
      value: function _gather(padding, constrain, filter, exclude) {
        var _this = this;

        var out = {};

        var focus = _paddedRectangle(this.origin, {
          w: 0,
          h: 0
        }, padding);

        var distanceCache = {}; //
        // sort the elements by their distance from the origin. note that right now this is the distance from a point, but ideally this
        // distance would be from the element to the focus, which can be an element. keep that in mind when doing the other gather cases.
        //

        this.positionArray.sort(function (a, b) {
          var distA = distanceCache[a.id] || Math.min(lineLength(a.bounds, _this.origin), lineLength(add(a.bounds, {
            x: a.bounds.w,
            y: 0
          }), _this.origin), lineLength(add(a.bounds, {
            x: a.bounds.w,
            y: a.bounds.h
          }), _this.origin), lineLength(add(a.bounds, {
            x: 0,
            y: a.bounds.h
          }), _this.origin));
          var distB = distanceCache[b.id] || Math.min(lineLength(b.bounds, _this.origin), lineLength(add(b.bounds, {
            x: b.bounds.w,
            y: 0
          }), _this.origin), lineLength(add(b.bounds, {
            x: b.bounds.w,
            y: b.bounds.h
          }), _this.origin), lineLength(add(b.bounds, {
            x: 0,
            y: b.bounds.h
          }), _this.origin));
          distanceCache[a.id] = distA;
          distanceCache[b.id] = distB;
          return distA === distB ? 0 : distA < distB ? -1 : 1;
        });
        var placedElements = {};

        var findRadialIntersections = function findRadialIntersections(candidateOrigin) {
          var radial = [_this.origin, candidateOrigin];
          var out = [];
          Array.prototype.push.apply(out, lineRectangleIntersection(radial, focus).map(function (i) {
            return [focus, i, null];
          }));

          var _loop = function _loop(_id3) {
            var otherRect = _this.positions.get(_id3);

            Array.prototype.push.apply(out, lineRectangleIntersection(radial, otherRect).map(function (i) {
              return [otherRect, i, _id3];
            }));
          };

          for (var _id3 in placedElements) {
            _loop(_id3);
          }

          return out.filter(function (o) {
            return o != null;
          });
        };

        var _loop2 = function _loop2(i) {
          if (exclude(_this.positionArray[i].id, _this.positionArray[i].element)) {
            return "continue";
          }

          var o1 = _this.positionArray[i].bounds,
              s1 = _this.positionArray[i].bounds,
              r1 = _paddedRectangle(o1.center, s1, padding);

          if (filter(_this.positionArray[i].id, _this.positionArray[i].element)) {
            var radialIntersections = findRadialIntersections(o1.center);

            if (radialIntersections.length > 0) {
              radialIntersections.sort(function (r, r2) {
                var l1 = lineLength(r[1], o1),
                    l2 = lineLength(r2[1], o1);
                return l1 < l2 ? -1 : 1;
              });
              var elementToAvoid = radialIntersections[0][0];
              var adjustBy = calculateSpacingAdjustment(elementToAvoid, r1);
              o1.x += adjustBy.x;
              o1.y += adjustBy.y;
              o1.center.x += adjustBy.x;
              o1.center.y += adjustBy.y;
              out[_this.positionArray[i].id] = o1;
              placedElements[_this.positionArray[i].id] = true;
            }
          }
        };

        for (var i = 0; i < this.positionArray.length; i++) {
          var _ret = _loop2(i);

          if (_ret === "continue") continue;
        }

        return out;
      }
    }, {
      key: "_magnetize",
      value: function _magnetize(padding, constrain, filter, iterations, exclude, grid) {
        var _this2 = this;

        iterations = iterations || 2;
        var focus, focusId;

        if (this.focusElement != null) {
          focus = _paddedRectangle(this.origin, this.focusElement.bounds, {
            x: 0,
            y: 0
          });
          focusId = this.focusElement.id;
        } else {
          focus = _paddedRectangle(this.origin, {
            w: 0,
            h: 0
          }, padding);
        }

        var iteration = 1,
            uncleanRun = true,
            adjustBy,
            constrainedAdjustment,
            _movedElements = {},
            _move = function _move(id, o, x, y) {
          o.x += x;
          o.y += y;
          o.center.x += x;
          o.center.y += y;
          _movedElements[id] = o;
        },
            // for the given position and delta, adjust the delta so that the new location would be snapped
        // to the current grid, if there is one. note that we adjust the delta, returning what the delta would be
        // in order to move `pos` to a position on the grid; we don't return the position on the grid itself.
        // if there's no current grid we just return the delta.
        _snapDeltaToGrid = function _snapDeltaToGrid(pos, delta) {
          if (grid == null) {
            return delta;
          } else {
            // p2 gives us where the element would end
            var p2 = add(pos, delta),
                _x = p2.x / grid.w,
                _y = p2.y / grid.h,
                _xMod = delta.x >= 0 ? Math.ceil(_x) : Math.floor(_x),
                _yMod = delta.y >= 0 ? Math.ceil(_y) : Math.floor(_y),
                snapped = {
              x: grid.w * _xMod,
              y: grid.h * _yMod
            };

            return subtract(snapped, pos);
          }
        },
            step = function step() {
          var currentPosition, otherPosition;

          for (var i = 0; i < _this2.positionArray.length; i++) {
            currentPosition = _this2.positionArray[i]; // if this element is excluded from computation, or is the current focus, skip it

            if (currentPosition.id === focusId || exclude(currentPosition.id, currentPosition.element)) {
              continue;
            }

            var o1 = currentPosition.bounds,
                // create a rectangle for first element: this encompasses the element and padding on each side
            r1 = _paddedRectangle(o1.center, o1, padding);

            if (filter(currentPosition.id, currentPosition.element) && intersects(focus, r1)) {
              adjustBy = calculateSpacingAdjustment(focus, r1); // first modify the delta to make it conform to the current grid, if there is one. we do this
              // _before_ the constrain function is applied, so the constrain function can in fact override the
              // grid. i think in most cases the two would likely not be used at the same time; they cover different
              // use cases. although of course snap to grid is in itself a constrain function.

              adjustBy = _snapDeltaToGrid(o1, adjustBy);
              constrainedAdjustment = constrain(currentPosition.id, o1, adjustBy);

              _move(currentPosition.id, o1, constrainedAdjustment.x, constrainedAdjustment.y); // reset rectangle for node after move


              r1 = _paddedRectangle(o1.center, o1, padding);
            } // now move others to account for this one, if necessary.


            for (var j = 0; j < _this2.positionArray.length; j++) {
              if (i !== j) {
                otherPosition = _this2.positionArray[j];

                if (otherPosition.id === focusId || exclude(otherPosition.id, otherPosition.element)) {
                  continue;
                }

                if (filter(otherPosition.id, otherPosition.element)) {
                  var o2 = otherPosition.bounds,
                      // create a rectangle for the second element, again by putting padding of the desired
                  // amount around the bounds of the element.
                  r2 = _paddedRectangle(o2.center, o2, padding); // if the two rectangles intersect then figure out how much to move the second one by.


                  if (intersects(r1, r2)) {
                    // TODO (?), instead of moving neither, the other node should move.
                    uncleanRun = true;
                    adjustBy = calculateSpacingAdjustment(r1, r2);
                    adjustBy = _snapDeltaToGrid(o2, adjustBy);
                    constrainedAdjustment = constrain(otherPosition.id, o2, adjustBy);

                    _move(otherPosition.id, o2, constrainedAdjustment.x, constrainedAdjustment.y);
                  }
                }
              }
            }
          }

          if (uncleanRun && iteration < iterations) {
            uncleanRun = false;
            iteration++;
            step();
          }
        };

        step();
        return _movedElements;
      }
    }, {
      key: "_positionElements",
      value: function _positionElements(_movedElements) {
        for (var i = 0; i < this.elements.length; i++) {
          var _id4 = this.getId(this.elements[i]);

          if (_movedElements[_id4]) {
            this.setPosition(this.elements[i], _movedElements[_id4].current);
          }
        }
      }
    }]);

    return Magnetizer;
  }();

  /**
   * @internal
   */

  var DEFAULT_MAGNETIZE_ITERATIONS = 10;

  function _addSorted(arr, val, prop) {
    arr.push(val);
    var i = arr.length - 1;
    var item = arr[i];

    while (i > 0 && item[prop] < arr[i - 1][prop]) {
      arr[i] = arr[i - 1];
      i -= 1;
    }

    arr[i] = item;
    return i;
  }
  /**
   * Base class for all layouts.
   * @public
   */


  var AbstractLayout = /*#__PURE__*/function () {
    function AbstractLayout(params) {
      _classCallCheck$d(this, AbstractLayout);

      _defineProperty$c(this, "toolkit", void 0);

      _defineProperty$c(this, "adapter", void 0);

      _defineProperty$c(this, "_vertices", []);

      _defineProperty$c(this, "magnetizer", void 0);

      _defineProperty$c(this, "magnetizerIterations", void 0);

      _defineProperty$c(this, "positions", new Map());

      _defineProperty$c(this, "sizes", new Map());

      _defineProperty$c(this, "positionArray", []);

      _defineProperty$c(this, "parameters", void 0);

      _defineProperty$c(this, "done", void 0);

      _defineProperty$c(this, "_minx", Infinity);

      _defineProperty$c(this, "_miny", Infinity);

      _defineProperty$c(this, "_maxx", -Infinity);

      _defineProperty$c(this, "_maxy", -Infinity);

      _defineProperty$c(this, "entries", {});

      _defineProperty$c(this, "xmax", []);

      _defineProperty$c(this, "ymax", []);

      _defineProperty$c(this, "xmin", []);

      _defineProperty$c(this, "ymin", []);

      _defineProperty$c(this, "width", void 0);

      _defineProperty$c(this, "height", void 0);

      _defineProperty$c(this, "container", void 0);

      _defineProperty$c(this, "containerSize", void 0);

      _defineProperty$c(this, "padding", void 0);

      _defineProperty$c(this, "negativeValuesAllowed", void 0);

      _defineProperty$c(this, "_locationFunction", void 0);

      _defineProperty$c(this, "_vertexMap", {});

      _defineProperty$c(this, "defaultMagnetized", void 0);

      _defineProperty$c(this, "type", void 0);

      this._locationFunction = params.options.locationFunction;
      this.adapter = params.adapter;
      this.initialiseMagnetizer(params.options);
      this.negativeValuesAllowed = params.negativeValuesAllowed !== false;
      this.toolkit = params.toolkit;
      this.container = params.container;
      this.containerSize = this.adapter.getSize(this.container);
      this.width = params.options.width || this.containerSize.w;
      this.height = params.options.height || this.containerSize.h;
      this.padding = params.options.padding;
      this.done = false;
      this.parameters = params.options || {};
    }

    _createClass$d(AbstractLayout, [{
      key: "_reset",
      value: function _reset() {
        this.done = false;
        this._minx = Infinity;
        this._maxx = -Infinity;
        this._miny = Infinity;
        this._maxy = -Infinity;
        this.positions.clear();
        this.positionArray.splice(0);
        this.entries = {};
        this.xmin.length = 0;
        this.ymin.length = 0;
        this.xmax.length = 0;
        this.ymax.length = 0;
        this._vertices.length = 0;
        this.sizes.clear();
        this.magnetizer.reset();
        this.reset();
      }
      /**
       * Subclasses that use `defaultMagnetized` may wish to override this to filter out candidates for the magnetizer.
       * @param id
       * @private
       */

    }, {
      key: "_magnetizerFilter",
      value: function _magnetizerFilter(id) {
        return true;
      }
    }, {
      key: "_prepareParameters",
      value: function _prepareParameters() {
        var p = extend(AbstractLayout._defaultParameters(), this.getDefaultParameters() || {});
        extend(p, this.parameters || {});
        this.parameters = p;
        return this.parameters;
      }
    }, {
      key: "_getEntry",
      value: function _getEntry(id, pos) {
        if (!this.entries[id]) {
          var p = pos || {
            x: 0,
            y: 0
          };
          this.entries[id] = {
            id: id,
            size: this._getSize(id),
            position: p,
            xmax: p.x,
            ymax: p.y,
            xmin: p.x,
            ymin: p.y
          };
        }

        return this.entries[id];
      }
    }, {
      key: "_cleanupEntry",
      value: function _cleanupEntry(id) {
        delete this.entries[id];
      }
    }, {
      key: "_calculateExtents",
      value: function _calculateExtents() {
        this.xmax.length = 0;
        this.xmin.length = 0;
        this.ymax.length = 0;
        this.ymin.length = 0;

        for (var _id in this.entries) {
          _addSorted(this.xmax, this.entries[_id], "xmax");

          _addSorted(this.ymax, this.entries[_id], "ymax");

          _addSorted(this.xmin, this.entries[_id], "xmin");

          _addSorted(this.ymin, this.entries[_id], "ymin");
        }

        this._minx = this.xmin.length > 0 ? this.xmin[0].xmin : 0;
        this._maxx = this.xmax.length > 0 ? this.xmax[this.xmax.length - 1].xmax : 0;
        this._miny = this.ymin.length > 0 ? this.ymin[0].ymin : 0;
        this._maxy = this.ymax.length > 0 ? this.ymax[this.ymax.length - 1].ymax : 0;

        if (!this.negativeValuesAllowed && (this._minx < 0 || this._miny < 0)) {
          var dx = this._minx < 0 ? this._minx : 0,
              dy = this._miny < 0 ? this._miny : 0;

          if (dx < 0 || dy < 0) {
            this.positions.forEach(function (pos, id) {
              pos.x -= dx;
              pos.y -= dy;
            });

            for (var e in this.entries) {
              this.entries[e].position.x -= dx;
              this.entries[e].xmin -= dx;
              this.entries[e].xmax -= dx;
              this.entries[e].position.y -= dy;
              this.entries[e].ymin -= dy;
              this.entries[e].ymax -= dy;
            }

            this._minx -= dx;
            this._miny -= dy;
            this._maxx -= dx;
            this._maxy -= dy;
          }
        }
      }
      /**
       * Uses the magnetizer to snap either all the elements in the layout, or a single element, to a grid.
       * @param grid - Definition of the grid to snap to.
       * @param elementId - If provided, only this element will be snapped to the grid.
       */

    }, {
      key: "snapToGrid",
      value: function snapToGrid(grid, elementId) {
        if (elementId != null) {
          this.magnetizer.setElements([elementId]);
        } else {
          this.magnetizer.setElements(this._vertices.map(function (v) {
            return v.id;
          }));
        }

        return this.magnetizer.snapToGrid(grid);
      }
      /**
       * Run the magnetizer.
       * @param params - Options for the magnetizer.
       * @param internal - whether or not the magnetize call was made by the layout itself.
       */

    }, {
      key: "magnetize",
      value: function magnetize(params, internal) {
        var _this = this;

        params = params || {};
        params.options = params.options || {};
        params.options.iterations = params.options.iterations || this.magnetizerIterations;
        var magnetizeResult = {}; // if an internal layout call, invoke the magnetizerFilter if set. otherwise ignore the magnetizerFilter.

        this.magnetizer.setElements(this._vertices.map(function (v) {
          return v.id;
        }).filter(function (id) {
          return internal ? _this._magnetizerFilter(id) : true;
        }));

        if (params.origin) {
          magnetizeResult = this.magnetizer.executeAtPoint(params.origin, params.options);
        } else if (params.focus) {
          magnetizeResult = this.magnetizer.executeWithFocus(params.focus, params.options);
        } else {
          magnetizeResult = this.magnetizer.executeAtCenter(params.options);
        }

        return magnetizeResult;
      }
      /**
       * Called by components to inform a layout that a new Node was added. You should never
       * call this method directly. Also, you should not override this method in a custom layout: if your layout
       * needs to track Node addition, implement `_nodeAdded` instead.
       *
       * This method is only ever called after a layout has been run and some change has been made to the data model. When the layout is run again,
       * the layout's list of vertices is completely refreshed.
       * @param params - Method args
       * @param params.vertex - Vertex that was added
       * @param params.el - The DOM element associated with the vertex.
       * @param eventInfo - Optional information associated with the Event that the host system needs to pass through without adding to the data model.
       */

    }, {
      key: "vertexAdded",
      value: function vertexAdded(params, eventInfo) {
        if (this.adapter.filter(params.vertex)) {
          // stash position and size for this vertex.
          var up = eventInfo && eventInfo.position ? eventInfo.position : params.vertex.data && params.vertex.data.left && params.vertex.data.top ? {
            x: params.vertex.data.left,
            y: params.vertex.data.top
          } : this.adapter.getOffset(params.el);

          var newPosition = this._vertexAdded(params, eventInfo);

          if (newPosition && !isNaN(newPosition.x) && !isNaN(newPosition.y)) {
            up.x = newPosition.x;
            up.y = newPosition.y;
          }

          this._vertices.push(params.vertex);

          this._vertexMap[params.vertex.id] = params.vertex;

          this._setPosition(params.vertex.id, up);

          this._getSize(params.vertex.id);

          this.magnetizer.addElement(params.vertex.id);
          return up;
        }
      }
      /**
       * Called by components to inform a layout that a given vertex was removed. You should never
       * call this method directly.
       * @param vertex - Vertex that was removed
       */

    }, {
      key: "vertexRemoved",
      value: function vertexRemoved(vertex) {
        this.positions["delete"](vertex.id);
        this.sizes["delete"](vertex.id);
        this._vertices = this._vertices.filter(function (v) {
          return v !== vertex;
        });
        delete this._vertexMap[vertex.id];

        this._cleanupEntry(vertex.id);

        this._vertexRemoved(vertex);

        this.magnetizer.removeElement(vertex.id);
      }
      /**
       * Gets the size of the vertex with the given id, retrieving from the viewport and caching it for later use if not
       * found locally. It is cached only for the duration of one run of the layout.
       * @param id - ID of the vertex whose size to retrieve
       * @returns Width and height of vertex
       */

    }, {
      key: "_getSize",
      value: function _getSize(id) {
        var _this2 = this;

        return getsert(this.sizes, id, function () {
          var vel = _this2.adapter.getViewportPositionById(id);

          return vel != null ? {
            w: vel.w,
            h: vel.h
          } : {
            w: 0,
            h: 0
          };
        });
      }
    }, {
      key: "_getPosition",
      value: function _getPosition(id, x, y, doNotRandomize) {
        var p = this.positions.get(id);

        if (!p) {
          if (x != null && y != null) p = {
            x: x,
            y: y
          };else if (!doNotRandomize) p = {
            x: Math.floor(Math.random() * (this.width + 1)),
            y: Math.floor(Math.random() * (this.height + 1))
          };else return null;

          this._setPosition(id, p);
        }

        return p;
      }
      /**
       * Update internal position information for the vertex with the given id.
       * @param id
       * @param x
       * @param y
       * @internal
       */

    }, {
      key: "_doSetPosition",
      value: function _doSetPosition(id, x, y) {
        if (id != null) {
          if (isNaN(x)) {
            x = 0;
          }

          if (isNaN(y)) {
            y = 0;
          }

          var p = this.positions.get(id);

          if (!p) {
            p = {
              x: x,
              y: y
            };
            this.positions.set(id, p);
            this.positionArray.push([p, id]);
          }

          var entry = this._getEntry(id, {
            x: x,
            y: y
          });

          entry.position.x = x;
          entry.position.y = y;
          this.updateEntry(entry);
          this.positions.set(id, {
            x: x,
            y: y
          });
        }
      }
      /**
       * Internal method that is used to notify interested subclasses, via the `_vertexMoved`
       * method, that some vertex has been moved.
       * @param id
       * @param x
       * @param y
       * @internal
       */

    }, {
      key: "_doUpdateAfterMove",
      value: function _doUpdateAfterMove(id, x, y) {
        if (this._vertexMap[id]) {
          this._vertexMoved(id, x, y);
        }
      }
      /**
       * Subclasses can override this method to take action when a vertex is reported as having been moved. For internal use only. Not part of the public API.
       * @param id
       * @param x
       * @param y
       * @internal
       */

    }, {
      key: "_vertexMoved",
      value: function _vertexMoved(id, x, y) {}
      /**
       * Subclasses can override this method to take action when a vertex is reported as having been added. For internal use only. Not part of the public API.
       * @param params
       * @param eventInfo
       * @internal
       */

    }, {
      key: "_vertexAdded",
      value: function _vertexAdded(params, eventInfo) {
        return null;
      }
      /**
       * Subclasses can override this method to take action when a vertex is reported as having been removed. For internal use only. Not part of the public API.
       * @param v
       * @internal
       */

    }, {
      key: "_vertexRemoved",
      value: function _vertexRemoved(v) {}
      /**
       * Sets the position of the given element, and then runs the magnetizer. By default, the element whose position was just
       * set will retain its position and everything else will move around it. If `dontMoveFocusVertex` is set, it will be the
       * element that was just dragged that will be repositioned.
       *
       * This method is not something that users of the API should call. It is called by the Surface.
       *
       * @param id Vertex that should be moved
       * @param x X position to move to
       * @param y Y position to move to
       * @param dontMoveFocusVertex If true, the vertex being moved stays where it was placed and other vertices move. Otherwise the repositioned vertex can move.
       * @internal
       */

    }, {
      key: "setMagnetizedPosition",
      value: function setMagnetizedPosition(id, x, y, dontMoveFocusVertex, grid) {
        var _this3 = this;

        this._doSetPosition(id, x, y);

        var magnetizeResult = this.magnetize({
          focus: dontMoveFocusVertex === true ? id : null,
          options: {
            filter: function filter(nodeId) {
              // is this the vertex we are setting the position for?
              var isCurrentVertex = nodeId !== id;
              return dontMoveFocusVertex !== true ? !isCurrentVertex : isCurrentVertex;
            },
            exclude: function exclude(id, el) {
              return _this3._vertexMap[id] == null ? false : _this3._vertexMap[id].group != null;
            },
            grid: grid
          }
        }, false);

        var p = this._getPosition(id);

        this._doUpdateAfterMove(id, p.x, p.y);

        return magnetizeResult;
      }
      /**
       * Sets the Position of the vertex with the given ID.
       * @param id ID of the vertex to set the position for.
       * @param pos X/y location for the vertex.
       * @internal
       */

    }, {
      key: "_setPosition",
      value: function _setPosition(id, pos) {
        this._doSetPosition(id, pos.x, pos.y);

        this._doUpdateAfterMove(id, pos.x, pos.y);
      }
      /*
       * Gets a random position for the vertex with the given ID.
       * @param id ID of the vertex to get a random position for
       * @param w Optional max width constraint for the value. Defaults to 10.
       * @param h Optional max height constraint for the value. Defaults to 10.
       * @returns Position for the vertex.
       * @internal
       */

    }, {
      key: "_getRandomPosition",
      value: function _getRandomPosition(id, w, h, doNotCalculateExtents) {
        w = w || 10;
        h = h || 10;
        var x = Math.floor(Math.random() * w);
        var y = Math.floor(Math.random() * h);

        var e = this._getEntry(id, {
          x: x,
          y: y
        });

        e.position = {
          x: x,
          y: y
        };
        this.updateEntry(e, doNotCalculateExtents !== true);
        this.positions.set(id, {
          x: x,
          y: y
        });
        return {
          x: x,
          y: y
        };
      }
    }, {
      key: "dumpPos",
      value: function dumpPos() {
        this.positions.forEach(function (pos, id) {
          console.log(id, pos.x, pos.y);
        });
      }
    }, {
      key: "initialiseMagnetizer",
      value: function initialiseMagnetizer(params) {
        var _this4 = this;

        this.magnetizer = new Magnetizer({
          getPosition: function getPosition(o) {
            return _this4.positions.get(o);
          },
          getSize: function getSize(o) {
            return _this4.sizes.get(o);
          },
          getId: function getId(o) {
            return o;
          },
          setPosition: function setPosition(o, p) {
            var vp = _this4.adapter.getViewportPositionById(o);

            if (vp.r !== 0) {
              // if the element is rotated we take the {left, top } position requested by the magnetizer, flesh out a full bounding box
              // for the element from that point, using the width and height reported by the viewport, then rotate every point
              var tl = p,
                  tr = {
                x: p.x + vp.w,
                y: p.y
              },
                  br = {
                x: p.x + vp.w,
                y: p.y + vp.h
              },
                  bl = {
                x: p.x,
                y: p.y + vp.h
              },
                  c = {
                x: (tl.x + tr.x) / 2,
                y: (tl.y + bl.y) / 2
              },
                  tl2 = rotatePoint(tl, c, -vp.r),
                  tr2 = rotatePoint(tr, c, -vp.r),
                  bl2 = rotatePoint(bl, c, -vp.r),
                  br2 = rotatePoint(br, c, -vp.r),
                  l = Math.min(tl2.x, tr2.x, bl2.x, br2.x),
                  t = Math.min(tl2.y, tr2.y, bl2.y, br2.y);

              _this4.setPosition(o, l, t);
            } else {
              _this4.setPosition(o, p.x, p.y);
            }
          },
          padding: params.padding,
          filter: function filter(id) {
            // if a node in a group, ignore it.
            // if (this._nodes[id] && this._nodes[id].group) {
            //     return false
            // }
            // // if a group in a group, ignore it.
            // if (this._groups[id] && this._groups[id].group) {
            //     return false
            // }
            if (_this4._vertexMap[id] && _this4._vertexMap[id].group) {
              return false;
            } // otherwise if layout wants to tell us, allow it, otherwise it gets included.


            return _this4.canMagnetize(id);
          }
        });
        this.magnetizerIterations = params.magnetizer ? params.magnetizer.iterations || DEFAULT_MAGNETIZE_ITERATIONS : DEFAULT_MAGNETIZE_ITERATIONS;
      }
      /**
       * Sets the position of the node/group with the given id, and recalculates the extents.
       * @param id ID of the node/group to move
       * @param x Left position
       * @param y Top position.
       * @param doNotCalculateExtents If true, do not recalculate the layout extents. we use this during a layout run, as
       * we dont need to calculate the extents until it is finished. But for a single setPosition call, we do want to recalculate extents.
       */

    }, {
      key: "setPosition",
      value: function setPosition(id, x, y) {
        var doNotCalculateExtents = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
        var out = {};
        out[id] = {
          original: this.positions.get(id) || {
            x: 0,
            y: 0
          },
          current: {
            x: x,
            y: y
          }
        };

        this._setPosition(id, {
          x: x,
          y: y
        });

        if (!doNotCalculateExtents) {
          this._calculateExtents();
        }

        return out;
      }
      /**
       * Gets the current positions held by the layout.
       */

    }, {
      key: "getPositions",
      value: function getPositions() {
        return this.positions;
      }
      /**
       * Get the current position for the vertex with the given ID.
       * @param id
       */

    }, {
      key: "getPosition",
      value: function getPosition(id) {
        return this.positions.get(id);
      }
      /**
       * Gets the layout's extents.
       * @internal
       */

    }, {
      key: "_getExtents",
      value: function _getExtents() {
        return {
          xmin: this._minx,
          ymin: this._miny,
          xmax: this._maxx,
          ymax: this._maxy
        };
      }
      /**
       * Sets what the layout considers to be the size of the node with the given id. This method is not
       * generally necessary if you use the `layout` methods on the surface widget.
       * @param id ID of the Node to set the size for.
       * @param s Size of the node.
       */

    }, {
      key: "setSize",
      value: function setSize(id, s) {
        this.sizes.set(id, s);

        var e = this._getEntry(id);

        e.size = s;
        this.updateEntry(e, true);
      }
    }, {
      key: "getSizes",
      value: function getSizes() {
        return this.sizes;
      }
    }, {
      key: "updateEntry",
      value: function updateEntry(entry, andCalculateExtents) {
        entry.xmax = entry.position.x + entry.size.w;
        entry.ymax = entry.position.y + entry.size.h;
        entry.xmin = entry.position.x;
        entry.ymin = entry.position.y;

        if (andCalculateExtents) {
          this._calculateExtents();
        }
      } // ------------------------------- life cycle --------------------------

      /**
       * This is an abstract function that subclasses may implement if they wish. It will be called at the beginning of a layout.
       * @param toolkit The associated jsPlumbToolkit instance
       * @param parameters Parameters configured for the layout.
       */

    }, {
      key: "_layout",
      value:
      /**
       * private method to run the layout.
       */
      function _layout(onComplete, magnetizeAfterLayout) {
        var _this5 = this;

        if (this.toolkit == null) {
          return;
        }

        this.containerSize = this.adapter.getSize(this.container);
        this.width = this.containerSize.w;
        this.height = this.containerSize.h;

        var params = this._prepareParameters();

        this._vertices = this.adapter.getElements().slice();
        this.begin(this.toolkit, params);

        var _end = function _end() {
          if (magnetizeAfterLayout || _this5.defaultMagnetized) {
            _this5.magnetize({}, true);
          }

          _this5._calculateExtents();

          _this5.end(_this5.toolkit, params, magnetizeAfterLayout);

          onComplete && onComplete({
            positions: _this5.positions,
            bounds: {
              xmin: _this5._minx,
              ymin: _this5._miny,
              xmax: _this5._maxx,
              ymax: _this5._maxy
            },
            sizes: _this5.sizes
          });
        };

        while (!this.done) {
          this.step(this.toolkit, params);
        }

        _end();
      }
      /**
       * Runs the layout, first doing a reset of element positions. Next, if the subclass has defined a `begin` method, that will
       * be called first.  Then, the subclass's `step` method will be called repeatedly, until the subclass makes a call to `_super.setDone`.
       * Use the `layout` method to run the layout incrementally without first resetting everything.
       * @param newParameters  Optional new set of parameters to apply.
       * @param onComplete Optional function to call on completion of relayout.
       * @param magnetizeAfterLayout Defaults to false. If true, the magnetizer will be run after the layout has completed.
       */

    }, {
      key: "relayout",
      value: function relayout(newParameters, onComplete, magnetizeAfterLayout) {
        this._reset();

        if (newParameters != null) {
          this.parameters = newParameters;
        }

        this._layout(onComplete, magnetizeAfterLayout);
      }
      /**
       * Runs the layout, without resetting calculated or user-provided positions beforehand.
       * If the subclass has defined a `begin` method, that will be called first.  Then, the subclass's
       * `step` method will be called repeatedly, until the subclass makes a call to `_super.setDone`.
       */

    }, {
      key: "layout",
      value: function layout(onComplete, magnetizeAfterLayout) {
        this.done = false;

        this._layout(onComplete, magnetizeAfterLayout);
      }
    }], [{
      key: "_defaultParameters",
      value: function _defaultParameters() {
        return {
          padding: {
            x: 0,
            y: 0
          }
        };
      }
    }]);

    return AbstractLayout;
  }();
  /**
   * Defines the signature of the callback method that a layout will hit after it has run. The layout passes back the position of every element,
   * the bounds of the layout (min/max in each axis), and the size of every element.
   */

  /**
   * Base class for an object that a layout can use to find information about the size and position of rendered elements,
   * as well as to filter elements it should handle. This is subclassed in `CanvasLayoutAdapter` and `GroupLayoutAdapter`
   * currently.
   * @internal
   */
  var AbstractLayoutAdapter = function AbstractLayoutAdapter() {
    _classCallCheck$d(this, AbstractLayoutAdapter);
  };

  var layoutMap = {};
  var Layouts = {
    get: function get(name, params) {
      var c = layoutMap[name];

      if (!c) {
        throw {
          message: "jsPlumb: unknown layout type '" + name + "'"
        };
      } else {
        params.options = params.options || {}; // ensure options not null.

        return new c(params);
      }
    },
    register: function register(name, layout) {
      layoutMap[name] = layout;
    }
  };

  var EMPTY_MAP = new Map();
  var EmptyLayout = /*#__PURE__*/function (_AbstractLayout) {
    _inherits$8(EmptyLayout, _AbstractLayout);

    var _super = _createSuper$8(EmptyLayout);

    function EmptyLayout(options) {
      var _this;

      _classCallCheck$d(this, EmptyLayout);

      _this = _super.call(this, options);

      _defineProperty$c(_assertThisInitialized$8(_this), "type", EmptyLayout.type);

      _defineProperty$c(_assertThisInitialized$8(_this), "defaultMagnetized", void 0);

      return _this;
    }

    _createClass$d(EmptyLayout, [{
      key: "getDefaultParameters",
      value: function getDefaultParameters() {
        return {};
      }
    }, {
      key: "layout",
      value: function layout() {}
    }, {
      key: "refresh",
      value: function refresh() {
        this.layout();
      }
    }, {
      key: "relayout",
      value: function relayout() {
        this.layout();
      }
    }, {
      key: "getPositions",
      value: function getPositions() {
        return EMPTY_MAP;
      }
    }, {
      key: "getPosition",
      value: function getPosition(id) {
        return {
          x: 0,
          y: 0
        };
      }
    }, {
      key: "setPosition",
      value: function setPosition(id, x, y) {
        return _defineProperty$c({}, id, {
          original: {
            x: x,
            y: y
          },
          current: {
            x: x,
            y: y
          }
        });
      }
    }, {
      key: "getExtents",
      value: function getExtents() {
        return [0, 0, 0, 0];
      }
    }, {
      key: "getSize",
      value: function getSize(id) {
        return {
          w: 0,
          h: 0
        };
      }
    }, {
      key: "begin",
      value: function begin(toolkit, parameters) {}
    }, {
      key: "canMagnetize",
      value: function canMagnetize(id) {
        return false;
      }
    }, {
      key: "end",
      value: function end(toolkit, parameters, wasMagnetized) {}
    }, {
      key: "reset",
      value: function reset() {}
    }, {
      key: "step",
      value: function step(toolkit, parameters) {
        this.done = true;
      }
    }, {
      key: "getSizes",
      value: function getSizes() {
        return EMPTY_MAP;
      }
    }]);

    return EmptyLayout;
  }(AbstractLayout);

  _defineProperty$c(EmptyLayout, "type", "Empty");

  Layouts.register(EmptyLayout.type, EmptyLayout);

  var AbsoluteBackedLayout = /*#__PURE__*/function (_AbstractLayout) {
    _inherits$8(AbsoluteBackedLayout, _AbstractLayout);

    var _super = _createSuper$8(AbsoluteBackedLayout);

    function AbsoluteBackedLayout(params) {
      var _this;

      _classCallCheck$d(this, AbsoluteBackedLayout);

      _this = _super.call(this, params);

      _defineProperty$c(_assertThisInitialized$8(_this), "_suppliedLocationFunction", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "defaultMagnetized", false);

      _defineProperty$c(_assertThisInitialized$8(_this), "absoluteBacked", void 0);

      _this.absoluteBacked = params.options.absoluteBacked === true;
      _this._suppliedLocationFunction = params.options.locationFunction;
      return _this;
    }

    _createClass$d(AbsoluteBackedLayout, [{
      key: "_vertexAdded",
      value: function _vertexAdded(params, eventInfo) {
        return this._findLocation(params.vertex, params.parameters);
      }
    }, {
      key: "_defaultLocationFunction",
      value: function _defaultLocationFunction(n) {
        return {
          x: n.data.left,
          y: n.data.top
        };
      }
    }, {
      key: "_findLocation",
      value: function _findLocation(v, parameters) {
        var fn = parameters != null && parameters.locationFunction ? parameters.locationFunction : this._suppliedLocationFunction || this._defaultLocationFunction;
        return fn(v);
      }
    }, {
      key: "begin",
      value: function begin(toolkit, parameters) {
        var objects = this.adapter.getElements();
        var count = objects.length;

        for (var i = 0; i < count; i++) {
          var v = objects[i],
              id = v.getFullId(),
              p = this.getPosition(id); // if no position yet tracked, get it from the data.

          if (p == null) {
            p = this._findLocation(v, parameters);
          } // we position ALL Nodes here, including those inside Groups.


          this.setPosition(id, p.x, p.y, true);
        }
      }
    }, {
      key: "step",
      value: function step(toolkit, parameters) {
        this.done = true; // all the work was done in 'begin'
      }
    }, {
      key: "canMagnetize",
      value: function canMagnetize(id) {
        return true;
      }
    }, {
      key: "end",
      value: function end(toolkit, parameters, wasMagnetized) {}
    }, {
      key: "reset",
      value: function reset() {}
      /**
       * Gets the position for the given Node/Group as dictated by either the `left`/`top` properties, or some other nominated pair, in the Node/Group's data.
       * This position is what the Absolute layout uses itself, and this method exposes the absolute position for subclasses that wish to make use
       * of the absolute backing.
       * @param v Node/Group to get absolute position for.
       * @param parameters Constructor parameters. May contain a custom `locationFunction`.
       */

    }, {
      key: "getAbsolutePosition",
      value: function getAbsolutePosition(v, parameters) {
        return this._findLocation(v, parameters);
      }
    }]);

    return AbsoluteBackedLayout;
  }(AbstractLayout);
  /**
   * This layout uses `left` and `top` positions in your data model to position elements, unless you provide a `locationFunction` in its
   * options.
   */

  var AbsoluteLayout = /*#__PURE__*/function (_AbsoluteBackedLayout) {
    _inherits$8(AbsoluteLayout, _AbsoluteBackedLayout);

    var _super2 = _createSuper$8(AbsoluteLayout);

    function AbsoluteLayout(params) {
      var _this2;

      _classCallCheck$d(this, AbsoluteLayout);

      _this2 = _super2.call(this, params);

      _defineProperty$c(_assertThisInitialized$8(_this2), "type", AbsoluteLayout.type);

      return _this2;
    }

    _createClass$d(AbsoluteLayout, [{
      key: "getDefaultParameters",
      value: function getDefaultParameters() {
        return {};
      }
    }]);

    return AbsoluteLayout;
  }(AbsoluteBackedLayout);

  _defineProperty$c(AbsoluteLayout, "type", "Absolute");

  Layouts.register(AbsoluteLayout.type, AbsoluteLayout);

  /*
   * Constants
   *
   * Copyright 2022 jsPlumb
   * https://jsplumbtoolkit.com
   *
   * This software is not free.
   *
   * This file contains event and class constants.
   *
   */

  /**
   * @public
   */
  var EVENT_DATA_LOAD_START = "dataLoadStart";
  /**
   * @public
   */

  var EVENT_DATA_APPEND_START = "dataAppendStart";
  /**
   * @public
   */

  var EVENT_DATA_LOAD_END = "dataLoadEnd";
  /**
   * @public
   */

  var EVENT_DATA_APPEND_END = "dataAppendEnd";
  /**
   * @public
   */

  var EVENT_DATA_UPDATED = "dataUpdated";
  /**
   * @public
   */

  var EVENT_DESTROY = "destroy";
  /**
   * @public
   */

  var EVENT_GRAPH_CLEAR_START = "graphClearStart";
  /**
   * @public
   */

  var EVENT_GRAPH_CLEARED = "graphCleared";
  /**
   * @public
   */

  var EVENT_GRAPH_CHANGED = "graphChanged";
  /**
   * @public
   */

  var EVENT_GROUP_UPDATED = "group:updated";
  /**
   * @public
   */

  var EVENT_NODE_UPDATED = "node:updated";
  /**
   * @public
   */

  var EVENT_PORT_UPDATED = "port:updated";
  /**
   * @public
   */

  var EVENT_EDGE_UPDATED = "edge:updated";
  /**
   * @public
   */

  var EVENT_EDGE_ADDED = "edge:added";
  /**
   * @public
   */

  var EVENT_NODE_ADDED = "node:added";
  /**
   * @public
   */

  var EVENT_EDGE_REMOVED = "edge:removed";
  /**
   * @public
   */

  var EVENT_NODE_REMOVED = "node:removed";
  /**
   * @public
   */

  var EVENT_PORT_ADDED = "port:added";
  /**
   * @public
   */

  var EVENT_PORT_REMOVED = "port:removed";
  /**
   * @public
   */

  var EVENT_GROUP_MEMBER_ADDED = "group:member:added";
  /**
   * @public
   */

  var EVENT_GROUP_MEMBER_REMOVED = "group:member:removed";
  /**
   * @public
   */

  var EVENT_GROUP_REMOVED = "group:removed";
  /**
   * @public
   */

  var EVENT_GROUP_ADDED = "group:added";
  /**
   * @public
   */

  var EVENT_EDGE_TARGET_CHANGED = "edge:target";
  /**
   * @public
   */

  var EVENT_EDGE_SOURCE_CHANGED = "edge:source";
  /**
   * @public
   */

  var EVENT_SELECT = "select";
  /**
   * @public
   */

  var EVENT_DESELECT = "deselect";
  /**
   * @public
   */

  var EVENT_SELECTION_CLEARED = "selection:cleared";
  /**
   * @public
   */

  var EVENT_EDGE_PATH_RESTORED = "edge:pathRestored";
  /**
   * @public
   */

  var EVENT_EDGE_PATH_EDITED = "edge:pathEdited";
  /**
   * @public
   */

  var EVENT_EDGE_TYPE_CHANGED = "edge:typeChanged";
  /**
   * @public
   */

  var EVENT_NODE_TYPE_CHANGED = "node:typeChanged";
  /**
   * @public
   */

  var EVENT_PORT_TYPE_CHANGED = "port:typeChanged";
  /**
   * @public
   */

  var EVENT_GROUP_TYPE_CHANGED = "group:typeChanged";
  /**
   * @public
   */

  var EVENT_GROUP_MOVE = "group:move";
  /**
   * @public
   */

  var EVENT_GROUP_MOVE_END = "group:move:end";
  /**
   * @public
   */

  var EVENT_NODE_MOVE_START = "node:move:start";
  /**
   * @public
   */

  var EVENT_NODE_MOVE = "node:move";
  /**
   * @public
   */

  var EVENT_NODE_MOVE_END = "node:move:end";
  /**
   * @public
   */

  var EVENT_RENDERER_ADDED = "renderer:added";
  /**
   * @public
   */

  var EVENT_UNDOREDO_UPDATE = "undoredo:update";
  /**
   * @public
   */

  var Parameters = {
    portType: "portType",
    edgeType: "edgeType"
  };

  var prefixes = ["node", "port", "edge", "group"],
      suffixes = [":added", ":removed", ":updated", ":moved"],
      p2 = ["edge"],
      s2 = [":source", ":target"];

  var _bind = function _bind(binder, p, s, fn) {
    for (var i = 0; i < p.length; i++) {
      for (var j = 0; j < s.length; j++) {
        _bindOne(binder, p[i] + s[j], fn);
      }
    }
  };

  var _bindOne = function _bindOne(binder, event, fn) {
    binder.instance.bind(event, fn);
    binder.bindings.push([event, fn]);
  };

  var AutoSaver = /*#__PURE__*/function () {
    function AutoSaver(instance, options) {
      var _this = this;

      _classCallCheck$d(this, AutoSaver);

      this.instance = instance;

      _defineProperty$c(this, "bindings", []);

      _defineProperty$c(this, "timer", null);

      if (options.saveUrl == null) {
        if (options.autoSaveHandler == null) {
          throw new Error("JSPLUMB autosave: neither saveUrl nor autoSaveHandler was specified");
        }
      }

      function _afterBind(fn) {
        return function () {
          fn && fn.apply(fn, arguments);
          options.onAfterAutoSave && options.onAfterAutoSave();
        };
      }

      var _suspended = false;

      var _doSave = function _doSave() {
        if (!_suspended) {
          try {
            options.onBeforeAutoSave && options.onBeforeAutoSave();
          } catch (e) {}

          if (options.autoSaveHandler != null) {
            options.autoSaveHandler(instance);
          } else {
            instance.save({
              url: options.saveUrl,
              success: _afterBind(options.onAutoSaveSuccess),
              error: _afterBind(options.onAutoSaveError),
              headers: options.saveHeaders
            });
          }
        }
      };

      var _save = function _save() {
        if (options.autoSaveDebounceTimeout == null) {
          _doSave();
        } else {
          if (_this.timer == null) {
            _this.timer = setTimeout(_doSave, options.autoSaveDebounceTimeout);
          } else {
            clearTimeout(_this.timer);
            _this.timer = setTimeout(_doSave, options.autoSaveDebounceTimeout);
          }
        }
      };

      _bindOne(this, EVENT_DATA_LOAD_START, function () {
        _suspended = true;
      });

      _bindOne(this, EVENT_DATA_LOAD_END, function () {
        _suspended = false;
      });

      _bindOne(this, EVENT_GRAPH_CLEAR_START, function () {
        _suspended = true;
      });

      _bindOne(this, EVENT_GRAPH_CLEARED, function () {
        _suspended = false;
      });

      _bind(this, prefixes, suffixes, _save);

      _bind(this, p2, s2, _save);

      _bind(this, ["group:"], ["member:added", "member:removed"], _save);
    }

    _createClass$d(AutoSaver, [{
      key: "discard",
      value: function discard() {
        var _this2 = this;

        this.bindings.forEach(function (binding) {
          return _this2.instance.unbind(binding[0], binding[1]);
        });
        this.bindings.length = 0;
      }
    }]);

    return AutoSaver;
  }();
  var CatchAllEventHandler = function CatchAllEventHandler(instance) {
    _classCallCheck$d(this, CatchAllEventHandler);

    this.instance = instance;

    _defineProperty$c(this, "bindings", []);

    var _f = function _f() {
      instance.fire("dataUpdated");
    };

    _bind(this, prefixes, suffixes, _f);

    _bind(this, p2, s2, _f);

    _bind(this, ["group:"], ["member:added", "member:removed"], _f);
  };

  /**
   * Extension of dataset that offers operation to perform operations on the contents, and to filter the contents.
   * @public
   */

  /**
   * @internal
   * @param obj
   */
  function isFilterableDataset(obj) {
    return obj.eachNode != null && obj.eachEdge != null && obj.eachGroup != null && obj.filter != null;
  }
  /**
   * @internal
   */

  var AbstractFilterableDataset = /*#__PURE__*/function (_EventGenerator) {
    _inherits$8(AbstractFilterableDataset, _EventGenerator);

    var _super = _createSuper$8(AbstractFilterableDataset);

    function AbstractFilterableDataset(toolkit) {
      var _this;

      _classCallCheck$d(this, AbstractFilterableDataset);

      _this = _super.call(this);
      _this.toolkit = toolkit;
      return _this;
    }

    _createClass$d(AbstractFilterableDataset, [{
      key: "_createSelection",
      value: function _createSelection(onClear) {
        return new Selection(this.toolkit, {
          onClear: onClear || function () {}
        });
      }
    }, {
      key: "filter",
      value: function filter(spec, includePartials) {
        var fn = typeof spec === "function" ? spec : function (obj) {
          var d = obj.data,
              out = false;

          for (var _i in spec) {
            var match = spec[_i] === d[_i];
            if (!match && !includePartials) return false;
            out = out || match;
          }

          return out;
        },
            s = this._createSelection();

        this.eachNode(function (i, n) {
          if (fn(n)) s.append(n);
          var o = n.getPorts();

          for (var j = 0; j < o.length; j++) {
            if (fn(o[j])) s.append(o[j]);
          }
        });
        this.eachEdge(function (i, e) {
          if (fn(e)) s.append(e);
        });
        this.eachGroup(function (i, e) {
          if (fn(e)) s.append(e);
        });
        return s;
      }
    }]);

    return AbstractFilterableDataset;
  }(EventGenerator);

  /**
   * A selection is a group of vertices and edges, upon which you can perform bulk operations.
   */
  var Selection = /*#__PURE__*/function (_AbstractFilterableDa) {
    _inherits$8(Selection, _AbstractFilterableDa);

    var _super = _createSuper$8(Selection);

    function Selection(toolkit, params) {
      var _this;

      _classCallCheck$d(this, Selection);

      _this = _super.call(this, toolkit);
      _this.toolkit = toolkit;

      _defineProperty$c(_assertThisInitialized$8(_this), "maxNodes", Infinity);

      _defineProperty$c(_assertThisInitialized$8(_this), "maxEdges", Infinity);

      _defineProperty$c(_assertThisInitialized$8(_this), "maxGroups", Infinity);

      _defineProperty$c(_assertThisInitialized$8(_this), "_nodes", []);

      _defineProperty$c(_assertThisInitialized$8(_this), "_groups", []);

      _defineProperty$c(_assertThisInitialized$8(_this), "_edges", []);

      _defineProperty$c(_assertThisInitialized$8(_this), "capacityPolicy", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "generator", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "onReload", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "onBeforeReload", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "onClear", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "autoFill", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "dataSource", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "_objMap", {});

      _defineProperty$c(_assertThisInitialized$8(_this), "_loading", false);

      _defineProperty$c(_assertThisInitialized$8(_this), "edgeFactory", void 0);

      _this.edgeFactory = toolkit.edgeFactory;
      _this.generator = params.generator;
      _this.onReload = params.onReload;
      _this.onBeforeReload = params.onBeforeReload;
      _this.autoFill = params.autoFill === true;

      _this.onClear = params.onClear || function () {}; // select
      // getPath


      _this.toolkit.bind(EVENT_NODE_REMOVED, function (o) {
        _this._removeOne(o.node);
      });

      _this.toolkit.bind(EVENT_GROUP_REMOVED, function (o) {
        _this._removeOne(o.group);
      });

      _this.toolkit.bind(EVENT_PORT_REMOVED, function (o) {
        _this._removeOne(o.port);
      });

      _this.toolkit.bind(EVENT_EDGE_REMOVED, function (o) {
        _this._removeOne(o.edge);
      });

      _this.toolkit.bind(EVENT_EDGE_TARGET_CHANGED, function (o) {
        if (_this._objMap[o.edge.getFullId()]) {
          _this.fire(EVENT_EDGE_TARGET_CHANGED, o);
        }
      });

      _this.toolkit.bind(EVENT_EDGE_SOURCE_CHANGED, function (o) {
        if (_this._objMap[o.edge.getFullId()]) {
          _this.fire(EVENT_EDGE_SOURCE_CHANGED, o);
        }
      });

      _this.toolkit.bind(EVENT_NODE_ADDED, function (o) {
        if (_this.generator && _this.autoFill && !_this._loading) {
          _this.reload();
        }
      });

      _this.toolkit.bind(EVENT_GROUP_ADDED, function (o) {
        if (_this.generator && _this.autoFill && !_this._loading) {
          _this.reload();
        }
      });

      _this.toolkit.bind(EVENT_NODE_UPDATED, function (p) {
        if (_this._objMap[p.vertex.getFullId()]) {
          _this.fire(EVENT_NODE_UPDATED, p);
        }
      });

      _this.toolkit.bind(EVENT_GROUP_UPDATED, function (p) {
        if (_this._objMap[p.vertex.getFullId()]) {
          _this.fire(EVENT_GROUP_UPDATED, p);
        }
      });

      _this.toolkit.bind(EVENT_EDGE_UPDATED, function (p) {
        if (_this._objMap[p.edge.getFullId()]) {
          _this.fire(EVENT_EDGE_UPDATED, p);
        }
      });

      _this.toolkit.bind(EVENT_PORT_UPDATED, function (p) {
        if (p.port != null && _this._objMap[p.port.getFullId()]) {
          _this.fire(EVENT_PORT_UPDATED, p);
        }
      });

      _this.toolkit.bind(EVENT_GRAPH_CLEARED, function () {
        _this.clear();
      });

      _this.toolkit.bind(EVENT_DATA_LOAD_END, function () {
        _this.reload();
      });

      _this.setCapacityPolicy(Selection.DISCARD_EXISTING);

      if (params.lazy !== true) {
        _this.reload(); // initial load

      }

      return _this;
    }

    _createClass$d(Selection, [{
      key: "_getList",
      value: function _getList(obj) {
        return obj.objectType === Edge.objectType ? this._edges : obj.objectType === Node.objectType ? this._nodes : this._groups;
      }
    }, {
      key: "_pushToList",
      value: function _pushToList(obj) {
        var deselected = [];

        var list = this._getList(obj),
            _max = obj.objectType === Edge.objectType ? this.maxEdges : obj.objectType === Node.objectType ? this.maxNodes : this.maxGroups;

        if (list.length >= _max) {
          if (this.capacityPolicy === Selection.DISCARD_NEW) {
            return false;
          } else {
            deselected = list.splice(0, 1);

            this._fireListEvent(deselected[0], ":removed");

            delete this._objMap[deselected[0].getFullId()];
          }
        }

        list.push(obj);

        this._fireListEvent(obj, ":added");

        return deselected;
      }
    }, {
      key: "_fireListEvent",
      value: function _fireListEvent(obj, suffix) {
        var evt = obj.objectType.toLowerCase() + suffix,
            payloads = {
          "Group": function Group(obj) {
            return {
              data: obj.data,
              group: obj
            };
          },
          "Node": function Node(obj) {
            return {
              data: obj.data,
              node: obj
            };
          },
          "Port": function (_Port) {
            function Port(_x) {
              return _Port.apply(this, arguments);
            }

            Port.toString = function () {
              return _Port.toString();
            };

            return Port;
          }(function (obj) {
            return {
              data: obj.data,
              node: obj.getParent(),
              port: obj
            };
          }),
          "Edge": function Edge(obj) {
            return {
              data: obj.data,
              edge: obj
            };
          }
        };
        this.fire(evt, payloads[obj.objectType](obj));
      }
    }, {
      key: "_addOne",
      value: function _addOne(obj, evtPipe) {
        if (!this._objMap[obj.getFullId()]) {
          var result = this._pushToList(obj);

          if (result === false) {
            return [[], []];
          } else {
            this._objMap[obj.getFullId()] = obj;
            if (evtPipe) evtPipe(obj, true);
            return [[obj], result];
          }
        }

        return [[], []];
      }
    }, {
      key: "_removeOne",
      value: function _removeOne(obj, evtPipe, e) {
        var objId = obj.getFullId();
        var wasRemoved = removeWithFunction(this._getList(obj), function (n) {
          return n.getFullId() == objId;
        });

        if (wasRemoved) {
          this._fireListEvent(obj, ":removed");
        }

        delete this._objMap[obj.getFullId()];

        if (evtPipe) {
          evtPipe(obj, false);
        }

        return [[], []];
      }
    }, {
      key: "_toggle",
      value: function _toggle(obj, evtPipe) {
        if (this._objMap[obj.getFullId()]) return this._removeOne(obj, evtPipe);else return this._addOne(obj, evtPipe);
      }
    }, {
      key: "_makeSenseOf",
      value: function _makeSenseOf(o, fn, evtPipe) {
        var _this2 = this;

        var out = [],
            deselections = [],
            objects;
        if (o == null) return out;

        var _one = function _one(_o) {
          var __o;

          if (isString(_o)) {
            __o = _this2.toolkit.getNode(_o) || _this2.toolkit.getEdge(_o) || _this2.toolkit.getGroup(_o);

            if (__o != null) {
              objects = fn(__o, evtPipe);
              out.push.apply(out, objects[0]);
              deselections.push.apply(deselections, objects[1]);
            }
          } else if (_o.eachVertex && _o.eachEdge) {
            _o.eachVertex(function (i, e) {
              _one(e);
            });

            _o.eachEdge(function (i, e) {
              _one(e);
            }); // if (_o.eachGroup) {
            //     _o.eachGroup((i:number, e:Group) => {
            //         _one(e)
            //     })
            // }

          } else if (_o.each) {
            _o.each(function (i, e) {
              _one(e.vertex || e);
            });
          } else if (_o.length != null) {
            for (var i = 0; i < _o.length; i++) {
              _one(_o[i]);
            }
          } else {
            objects = fn(_o, evtPipe);
            out.push.apply(out, objects[0]);
            deselections.push.apply(deselections, objects[1]);
          }
        };

        _one(o);

        return [out, deselections];
      }
      /**
       * Removes the given object from the selection.
       * @param obj Object(s) to remove. May take many forms - a Group, Group Id, Node, Node Id, or Edge, or a list of these,
       * or a Path.
       */

    }, {
      key: "remove",
      value: function remove(obj, evtPipe) {
        return this._makeSenseOf(obj, this._removeOne.bind(this), evtPipe);
      }
      /**
       * Appends the given object to the selection.
       * @param obj Object(s) to add. May take many forms - a Group, Group Id, Node, Node Id, or Edge, or a list of these,
       * or a Path.
       */

    }, {
      key: "append",
      value: function append(obj, evtPipe) {
        return this._makeSenseOf(obj, this._addOne.bind(this), evtPipe);
      }
      /**
       * Toggles the given object's membership in the current selection. If `obj` is a Path, then the individual
       * members of the Path are toggled independently.
       * @param obj Object(s) to add. May take many forms - a Group, Group Id, Node, Node Id, or Edge, or a list of these,
       * or a Path.
       */

    }, {
      key: "toggle",
      value: function toggle(obj, evtPipe) {
        return this._makeSenseOf(obj, this._toggle.bind(this), evtPipe);
      }
      /**
       * Sets the maximum number of nodes the selection can hold. The action taken when appending a node that would
       * take the selection above its limit depends on the current `capacityPolicy`, which can be either
       * Selection.DISCARD_EXISTING (the default) or Selection.DISCARD_NEW.
       * @param _maxNodes
       */

    }, {
      key: "setMaxNodes",
      value: function setMaxNodes(_maxNodes) {
        this.maxNodes = _maxNodes;
      }
      /**
       * Sets the maximum number of groups the selection can hold. The action taken when appending a group that would
       * take the selection above its limit depends on the current `capacityPolicy`, which can be either
       * Selection.DISCARD_EXISTING (the default) or Selection.DISCARD_NEW.
       * @param _maxGroups
       */

    }, {
      key: "setMaxGroups",
      value: function setMaxGroups(_maxGroups) {
        this.maxGroups = _maxGroups;
      }
      /**
       * Sets the maximum number of edges the selection can hold. The action taken when appending an edge that would
       * take the selection above its limit depends on the current `capacityPolicy`, which can be either
       * Selection.DISCARD_EXISTING (the default) or Selection.DISCARD_NEW.
       * @param _maxEdges
       */

    }, {
      key: "setMaxEdges",
      value: function setMaxEdges(_maxEdges) {
        this.maxEdges = _maxEdges;
      }
      /**
       * Sets the action taken when appending an edge or node that would
       * take the selection above its limit for that given type.
       * @param policy One of `Selection.DISCARD_EXISTING` (which removes the 0th entry from the list
       * before insertion of the new value) or `Selection.DISCARD_NEW`.
       */

    }, {
      key: "setCapacityPolicy",
      value: function setCapacityPolicy(policy) {
        this.capacityPolicy = policy;
      }
    }, {
      key: "clear",
      value: function clear(doNotFireEvent) {
        this._nodes.length = 0;
        this._edges.length = 0;
        this._groups.length = 0;
        this._objMap = {};
        this.fire(EVENT_GRAPH_CLEAR_START, {});

        if (!doNotFireEvent) {
          this.onClear(this);
        }
      }
    }, {
      key: "_filterEdgeList",
      value: function _filterEdgeList(edges) {
        var _ = [];

        for (var i = 0; i < edges.length; i++) {
          if (this._objMap[edges[i].getId()] != null) _.push(edges[i]);
        }

        return _;
      }
      /**
       * Reloads the content of this Selection, if a `generator` was supplied to the constructor. Otherwise
       * does nothing. A data load start event is fired first, followed by a call to the generator to repopulate,
       * and then a data load end event is fired.  So calling this method on a Selection that you are rendering
       * to a Surface will cause the Surface to repaint itself.
       */

    }, {
      key: "reload",
      value: function reload() {
        if (this.generator != null) {
          this.onBeforeReload && this.onBeforeReload();
          this.clear();
          this._loading = true;
          this.fire(EVENT_DATA_LOAD_START, {});
          this.generator(this, this.toolkit);
          this.fire(EVENT_DATA_LOAD_END, {});
          this.onReload && this.onReload();
          this._loading = false;
        }
      }
      /**
       * Iterates the objects of the given type in the selection, calling the supplied callback
       * for each item. The callback's signature should be `function(index, item)`. If you don't supply
       * `type`, the default of "Node" will be used.
       * @param  fn Function to call with each item.
       * @param type Type of object to iterate. Defaults to Node.objectType.
       */

    }, {
      key: "each",
      value: function each(fn, type) {
        var list = type === Edge.objectType ? this._edges : type === Group.objectType ? this._groups : this._nodes;

        for (var i = 0; i < list.length; i++) {
          try {
            fn(i, list[i]);
          } catch (e) {//util.log("Selection iterator function failed", e)
          }
        }
      }
      /**
       * Iterates the Nodes in the selection, calling the supplied callback
       * for each item. The callback's signature should be `function(index, item)`.
       * @param fn Function to call with each item.
       */

    }, {
      key: "eachNode",
      value: function eachNode(fn) {
        this.each(fn, Node.objectType);
      }
      /**
       * Iterates the Groups in the selection, calling the supplied callback
       * for each item. The callback's signature should be `function(index, item)`.
       * @param fn Function to call with each item.
       */

    }, {
      key: "eachGroup",
      value: function eachGroup(fn) {
        this.each(fn, Group.objectType);
      }
      /**
       * Iterates the Nodes and the Groups in the selection, calling the supplied callback
       * for each item. The callback's signature should be `function(index, item)`.
       * @param fn Function to call with each item.
       */

    }, {
      key: "eachVertex",
      value: function eachVertex(fn) {
        this.each(fn, Node.objectType);
        this.each(fn, Group.objectType);
      }
      /**
       * Iterates the Edges in the selection, calling the supplied callback
       * for each item. The callback's signature should be `function(index, item)`.
       * @param fn Function to call with each item.
       */

    }, {
      key: "eachEdge",
      value: function eachEdge(fn) {
        this.each(fn, Edge.objectType);
      }
      /**
       * Get the current number of Nodes in the selection.
       */

    }, {
      key: "getNodeCount",
      value: function getNodeCount() {
        return this._nodes.length;
      }
      /**
       * Gets the node at the given index.
       * @param idx Index of the Node to retrieve. Will return null if index out of range.
       * @returns A Node, or null.
       */

    }, {
      key: "getNodeAt",
      value: function getNodeAt(idx) {
        return this._nodes[idx];
      }
      /**
       * Gets all the Nodes in the Selection.
       */

    }, {
      key: "getNodes",
      value: function getNodes() {
        return this._nodes;
      }
      /**
       * Gets the Node with the given ID, if it is in the current selection
       * @param id ID of the Node to retrieve
       */

    }, {
      key: "getNode",
      value: function getNode(id) {
        var match = findWithFunction(this._nodes, function (n) {
          return n.id === id;
        });
        return match === -1 ? null : this._nodes[match];
      }
      /**
       * Gets the Group at the given index.
       * @param idx Index of the Gorup to retrieve. Will return null if index out of range.
       * @returns A Group, or null.
       */

    }, {
      key: "getGroupAt",
      value: function getGroupAt(idx) {
        return this._groups[idx];
      }
      /**
       * Gets all the Groups in the Selection.
       */

    }, {
      key: "getGroups",
      value: function getGroups() {
        return this._groups;
      }
      /**
       * Gets the Group with the given ID, if it is in the selection.
       * @param id ID of the Group to retrieve
       */

    }, {
      key: "getGroup",
      value: function getGroup(id) {
        var match = findWithFunction(this._groups, function (n) {
          return n.id === id;
        });
        return match === -1 ? null : this._groups[match];
      }
      /**
       * Get the current number of Groups in the selection.
       */

    }, {
      key: "getGroupCount",
      value: function getGroupCount() {
        return this._groups.length;
      }
      /**
       * Gets all the nodes, edges and groups.
       */

    }, {
      key: "getAll",
      value: function getAll() {
        var o = [];
        Array.prototype.push.apply(o, this._nodes);
        Array.prototype.push.apply(o, this._edges);
        Array.prototype.push.apply(o, this._groups);
        return o;
      }
      /**
       * Gets all Edges for the given Node or Group.
       * @param node The Node to get Edges for.
       * @param filter Optional filter for edges.
       * @returns An array of Edges, which may be empty. Never null.
       */

    }, {
      key: "getAllEdgesFor",
      value: function getAllEdgesFor(node, filter) {
        // need to get all edges and then filter to see if they're in the current selection.
        return this._filterEdgeList(node.getAllEdges({
          filter: filter
        }));
      }
      /**
       * Gets all source Edges for the given Node or Group.
       * @param v The Node/Group to get source Edges for.
       * @returns An array of Edges, which may be empty. Never null.
       */

    }, {
      key: "getSourceEdgesFor",
      value: function getSourceEdgesFor(v) {
        // need to get all edges and then filter to see if they're in the current selection.
        return this._filterEdgeList(v.getSourceEdges());
      }
      /**
       * Get the current number of Edges in the selection.
       */

    }, {
      key: "getEdgeCount",
      value: function getEdgeCount() {
        return this._edges.length;
      }
      /**
       * Gets the Edge at the given index.
       * @param idx Index of the Edge to retrieve.
       * @returns Edge at the given index, null if nothing found at that index.
       */

    }, {
      key: "getEdgeAt",
      value: function getEdgeAt(idx) {
        return this._edges[idx];
      }
      /**
       * Gets all the edges in the selection
       * @returns All the edges in the selection, perhaps an empty list. Never null.
       */

    }, {
      key: "getEdges",
      value: function getEdges() {
        return this._edges;
      }
      /**
       * @internal
       */

    }, {
      key: "shouldFireEvent",
      value: function shouldFireEvent(event, value, originalEvent) {
        return true;
      } // ---------------- delegates. check each of these to see if they need to be declared in the DataSource interface ------

    }, {
      key: "getNodeType",
      value: function getNodeType(nodeData) {
        return this.toolkit.getNodeType(nodeData);
      }
    }, {
      key: "getModel",
      value: function getModel() {
        return this.toolkit.getModel();
      }
    }, {
      key: "getGraph",
      value: function getGraph() {
        return this.toolkit.getGraph();
      }
    }, {
      key: "setSuspendGraph",
      value: function setSuspendGraph(v) {
        this.toolkit.setSuspendGraph(v);
      }
    }, {
      key: "getNodeId",
      value: function getNodeId(node) {
        return this.toolkit.getNodeId(node);
      }
    }, {
      key: "getPortType",
      value: function getPortType(port) {
        return this.toolkit.getPortType(port);
      }
    }, {
      key: "addPort",
      value: function addPort(node, data, doNotFireEvent) {
        return this.toolkit.addPort(node, data, doNotFireEvent);
      }
    }, {
      key: "getPortId",
      value: function getPortId(port) {
        return this.toolkit.getPortId(port);
      }
    }, {
      key: "getEdge",
      value: function getEdge(edgeId) {
        return this.toolkit.getEdge(edgeId);
      }
    }, {
      key: "addEdge",
      value: function addEdge(params, source, doNotFireEvent) {
        return this.toolkit.addEdge(params, source, doNotFireEvent);
      }
    }, {
      key: "edgeMoved",
      value: function edgeMoved(edge, obj, index) {
        this.toolkit.edgeMoved(edge, obj, index);
      }
    }, {
      key: "removeEdge",
      value: function removeEdge(edge) {
        this.toolkit.removeEdge(edge);
      }
    }, {
      key: "setEdgeGeometry",
      value: function setEdgeGeometry(edge, geometry, renderer) {
        this.toolkit.setEdgeGeometry(edge, geometry, renderer);
      }
    }, {
      key: "getEdgeType",
      value: function getEdgeType(edgeData) {
        return this.toolkit.getEdgeType(edgeData);
      } // TODO this method has no business being in this class. Selection is not a full data source like the Toolkit is; it's almost
      // a read only dataset, in fact.

    }, {
      key: "addToGroup",
      value: function addToGroup(node, group, sourceGroup, position) {
        return this.toolkit.addToGroup(node, group, position);
      }
    }, {
      key: "removeFromGroup",
      value: function removeFromGroup(node, doNotFireEvent, targetGroup, source) {
        return this.toolkit.removeFromGroup(node, doNotFireEvent, targetGroup, source);
      }
      /**
       * Returns the vertex with the given id, if it is in the selection.
       * @param id
       */

    }, {
      key: "getVertex",
      value: function getVertex(id) {
        return this.getNode(id) || this.getGroup(id);
      }
      /**
       * Returns whether or not the vertex (node/group) with the given id is in the selection.
       * @param id
       */

    }, {
      key: "containsVertex",
      value: function containsVertex(id) {
        return this.getVertex(id) != null;
      }
    }, {
      key: "getObjectInfo",
      value: function getObjectInfo(obj) {
        return this.toolkit.getObjectInfo(obj);
      }
    }, {
      key: "beforeConnect",
      value: function beforeConnect(source, target, data) {
        return this.toolkit.beforeConnect(source, target, data);
      }
    }, {
      key: "beforeMoveConnection",
      value: function beforeMoveConnection(source, target, edge) {
        return this.toolkit.beforeMoveConnection(source, target, edge);
      }
    }, {
      key: "beforeStartConnect",
      value: function beforeStartConnect(source, type) {
        return this.toolkit.beforeStartConnect(source, type);
      }
    }, {
      key: "beforeDetach",
      value: function beforeDetach(source, target, edge, isDiscard) {
        return this.toolkit.beforeDetach(source, target, edge, isDiscard);
      }
    }, {
      key: "beforeStartDetach",
      value: function beforeStartDetach(source, edge) {
        return this.toolkit.beforeStartDetach(source, edge);
      }
    }, {
      key: "debugEnabled",
      get: function get() {
        return this.toolkit.debugEnabled;
      }
    }, {
      key: "batch",
      value: function batch(fn) {
        this.toolkit.batch(fn);
      }
    }]);

    return Selection;
  }(AbstractFilterableDataset);

  _defineProperty$c(Selection, "DISCARD_EXISTING", "discardExisting");

  _defineProperty$c(Selection, "DISCARD_NEW", "discardNew");

  var _parsers, _JSON_DATATYPE;

  /*
   * jsPlumbToolkitIO
   *
   * Copyright 2021 jsPlumb
   * https://jsplumbtoolkit.com
   *
   * Licensed under the GPL2 license.  This software is not free.
   *
   * This file contains IO support - loading/saving of the internal JSON format used by the Toolkit (and also support for custom formats)
   *
   */

  /*
   This uses the toolkit's internal JSON format.
   */
  var JSONGraphParser = function JSONGraphParser(data, toolkit, parameters) {
    var nodes = data.nodes || [],
        edges = data.edges || [],
        ports = data.ports || [],
        groups = data.groups || []; //
    // a map of groups that are waiting to be added because they declared a `group` member and that group had not been loaded
    // when the child group was loaded. This map is keyed by the ID of the parent group, and the entry is a list of group data

    var nestedGroupMap = new Map();
    var alreadyAddedGroups = [];

    var _processDependentGroups = function _processDependentGroups(id) {
      // now add any groups that were dependent on it
      var dependentGroups = nestedGroupMap.get(id);

      if (dependentGroups != null) {
        forEach(dependentGroups, function (gd) {
          alreadyAddedGroups.push(toolkit.addGroup(gd).id);
        });
      }

      nestedGroupMap["delete"](id);
      forEach(dependentGroups, function (gd) {
        _processDependentGroups(gd.id);
      });
    };

    for (var l = 0; l < groups.length; l++) {
      var _data = groups[l];

      if (_data.group != null && alreadyAddedGroups.indexOf(_data.group) === -1) {
        // the `group` this is a member of has not yet been resolved.
        var childList = getsert(nestedGroupMap, _data.group, function () {
          return [];
        });
        childList.push(_data);
      } else {
        // add the group
        var addedGroup = toolkit.addGroup(_data); // record the fact that it's been added

        alreadyAddedGroups.push(addedGroup.id); // process nested groups

        _processDependentGroups(addedGroup.id);
      }
    } // finally, look through the map of nested groups and try to add anything that remains. if we come across a group that has not been added
    // then the parser throws an error


    nestedGroupMap.forEach(function (childData, parentId) {
      if (alreadyAddedGroups.indexOf(parentId) === -1) {
        throw new Error("Parent group [" + parentId + "] not found");
      } else {
        forEach(childData, function (cd) {
          return alreadyAddedGroups.push(toolkit.addGroup(cd).id);
        });
      }
    });

    for (var i = 0; i < nodes.length; i++) {
      toolkit.addNode(nodes[i]);
    }

    for (var k = 0; k < ports.length; k++) {
      // the original code; it is unclear if anybody was using this, since it doesnt conflict with the current
      // way we have left it for now
      if (ports[k].nodeId) {
        var n = toolkit.getNode(ports[k].nodeId);
        if (n == null) throw new Error("Unknown node [" + ports[k].nodeId + "]");
        n.addPort(ports[k]);
      } else if (ports[k].id) {
        // a new implementation, which can ingest what the exporter puts out.
        var vertex = toolkit.getGraph().getVertexByPortId(ports[k].id);

        if (vertex) {
          var p = extend(ports[k], {});
          p.id = toolkit.getGraph().splitPortId(ports[k].id)[1];
          vertex.addPort(p);
        }
      } else {
        console.log("could not add port with definition " + ports[k] + "; no nodeId or id found");
      }
    }

    for (var j = 0; j < edges.length; j++) {
      var edgePayload = {
        source: edges[j].source,
        target: edges[j].target,
        cost: edges[j].cost || 1,
        directed: edges[j].directed,
        data: edges[j].data
      };

      if (edges[j].geometry) {
        edgePayload.geometry = edges[j].geometry;
      }

      toolkit.addEdge(edgePayload);
    }
  };

  var JSONGraphExporter = function JSONGraphExporter(toolkit, parameters) {
    return toolkit.getGraph().serialize();
  }; // parser for the "hierarchical json" format


  var hierarchicalJsonParser = function hierarchicalJsonParser(data, toolkit, parameters) {
    var _one = function _one(d) {
      var n = toolkit.addNode(d);

      if (d.children) {
        for (var i = 0; i < d.children.length; i++) {
          var c = toolkit.addNode(d.children[i]);
          toolkit.addEdge({
            source: n,
            target: c
          });

          _one(d.children[i]);
        }
      }
    };

    _one(data);
  };

  var JSON_DATATYPE = "json";
  var HIERARCHICAL_JSON_DATATYPE = "hierarchical-json";

  var exporters = _defineProperty$c({}, JSON_DATATYPE, JSONGraphExporter);

  var parsers = (_parsers = {}, _defineProperty$c(_parsers, JSON_DATATYPE, JSONGraphParser), _defineProperty$c(_parsers, HIERARCHICAL_JSON_DATATYPE, hierarchicalJsonParser), _parsers);
  /**
   * list of managed operations.
   * @internal
   */

  var ManagedOperations;
  /**
   * @internal
   */

  (function (ManagedOperations) {
    ManagedOperations["removeGroup"] = "removeGroup";
    ManagedOperations["removeNode"] = "removeNode";
    ManagedOperations["removePort"] = "removePort";
    ManagedOperations["removeEdge"] = "removeEdge";
    ManagedOperations["addNode"] = "addNode";
    ManagedOperations["addGroup"] = "addGroup";
    ManagedOperations["addEdge"] = "addEdge";
    ManagedOperations["addPort"] = "addPort";
  })(ManagedOperations || (ManagedOperations = {}));

  var managers = _defineProperty$c({}, JSON_DATATYPE, (_JSON_DATATYPE = {}, _defineProperty$c(_JSON_DATATYPE, ManagedOperations.removeNode, function (dataset, node, idFunction) {
    var id = idFunction(node.data);
    removeWithFunction(dataset.nodes, function (n) {
      return n.id === id;
    });
  }), _defineProperty$c(_JSON_DATATYPE, ManagedOperations.removeGroup, function (dataset, group, idFunction) {
    var id = idFunction(group.data);
    removeWithFunction(dataset.groups, function (g) {
      return g.id === id;
    });
  }), _defineProperty$c(_JSON_DATATYPE, ManagedOperations.removeEdge, function (dataset, edge, idFunction) {
    var id = idFunction(edge.data);
    removeWithFunction(dataset.edges, function (e) {
      return e.data && e.data.id === id;
    });
  }), _defineProperty$c(_JSON_DATATYPE, ManagedOperations.addNode, function (dataset, node, idFunction) {
    dataset.nodes = dataset.nodes || [];
    dataset.nodes.push(node.data);
  }), _defineProperty$c(_JSON_DATATYPE, ManagedOperations.addGroup, function (dataset, group, idFunction) {
    dataset.groups = dataset.groups || [];
    dataset.groups.push(group.data);
  }), _defineProperty$c(_JSON_DATATYPE, ManagedOperations.addEdge, function (dataset, edge, idFunction) {
    var j = {
      source: edge.source.getFullId(),
      target: edge.target.getFullId(),
      data: edge.data || {}
    };
    dataset.edges = dataset.edges || [];
    dataset.edges.push(j);
  }), _defineProperty$c(_JSON_DATATYPE, ManagedOperations.addPort, function (dataset, params, idFunction) {
    dataset.ports = dataset.ports || [];
    var d = extend({}, params.port.data || {});
    d.id = params.port.getFullId();
    dataset.ports.push(d);
  }), _defineProperty$c(_JSON_DATATYPE, ManagedOperations.removePort, function (dataset, params, idFunction) {
    var id = params.port.getFullId();
    removeWithFunction(dataset.ports, function (p) {
      return p.id === id;
    });
  }), _JSON_DATATYPE));

  function parse(type, source, toolkit, parameters) {
    var parser = parsers[type];
    if (parser == null) throw new Error("jsPlumb Toolkit - parse - [" + type + "] is an unsupported type");else return parser(source, toolkit, parameters);
  }
  /**
   * Internal method that handles data export, by looking for an exporter registered for the given `type`.
   * @param type Format to export the data in
   * @param toolkit Toolkit to export data from
   * @param parameters Optional parameters for the exporter.
   */

  function exportData(type, toolkit, parameters) {
    var exporter = exporters[type];
    if (exporter === null) throw new Error("jsPlumb Toolkit - exportData - [" + type + "]  is an unsupported type");else return exporter(toolkit, parameters);
  }
  /**
   * @internal
   * @param operation
   * @param dataset
   * @param dataType
   * @param obj
   * @param idFunction
   * @param toolkit
   */

  function manage(operation, dataset, dataType, obj, idFunction, toolkit) {
    if (managers[dataType] && managers[dataType][operation]) {
      managers[dataType][operation](dataset, obj, idFunction);
    }
  }

  var EdgeAction = /*#__PURE__*/function () {
    function EdgeAction(obj, toolkit, manager) {
      _classCallCheck$d(this, EdgeAction);

      this.obj = obj;
      this.toolkit = toolkit;
      this.manager = manager;

      _defineProperty$c(this, "source", void 0);

      _defineProperty$c(this, "target", void 0);

      _defineProperty$c(this, "edgeId", void 0);

      _defineProperty$c(this, "sourcePort", void 0);

      _defineProperty$c(this, "targetPort", void 0);

      _defineProperty$c(this, "geometry", void 0);

      this.source = obj.source.getFullId();
      this.target = obj.target.getFullId();

      if (isPort(obj.source)) {
        this.sourcePort = obj.source.id;
        this.source = obj.source.getParent().getFullId();
      }

      if (isPort(obj.target)) {
        this.targetPort = obj.target.id;
        this.target = obj.target.getParent().getFullId();
      }

      this.edgeId = obj.getId();
      this.geometry = obj.geometry;
    }

    _createClass$d(EdgeAction, [{
      key: "generateSourceId",
      value: function generateSourceId() {
        return this.sourcePort == null ? this.source : this.source + this.toolkit.getGraph().getPortSeparator() + this.sourcePort;
      }
    }, {
      key: "generateTargetId",
      value: function generateTargetId() {
        return this.targetPort == null ? this.target : this.target + this.toolkit.getGraph().getPortSeparator() + this.targetPort;
      }
    }, {
      key: "_add",
      value: function _add() {
        // at this point, any EdgeActions in the stack whose edgeId is our previous edgeId need to be updated with this
        // new object...unfortunately. this object will itself be called back in the `edgeChange` method below to do an update.
        var connectOptions = {
          source: this.generateSourceId(),
          target: this.generateTargetId(),
          data: this.obj.data,
          geometry: this.geometry
        };
        var newEdge = this.toolkit.connect(connectOptions);
        this.manager.edgeChange(this.edgeId, newEdge);
      }
    }, {
      key: "_remove",
      value: function _remove() {
        this.toolkit.removeEdge(this.obj);
      }
    }, {
      key: "edgeChange",
      value: function edgeChange(newEdge) {
        this.obj = newEdge;
        this.edgeId = this.obj.getId();
      }
    }]);

    return EdgeAction;
  }();
  var EdgeAddAction = /*#__PURE__*/function (_EdgeAction) {
    _inherits$8(EdgeAddAction, _EdgeAction);

    var _super = _createSuper$8(EdgeAddAction);

    function EdgeAddAction() {
      _classCallCheck$d(this, EdgeAddAction);

      return _super.apply(this, arguments);
    }

    _createClass$d(EdgeAddAction, [{
      key: "undo",
      value: function undo() {
        this._remove();
      }
    }, {
      key: "redo",
      value: function redo() {
        this._add();
      }
    }, {
      key: "hasDeltas",
      value: function hasDeltas() {
        return this.obj != null;
      }
    }]);

    return EdgeAddAction;
  }(EdgeAction);
  var EdgeRemoveAction = /*#__PURE__*/function (_EdgeAction2) {
    _inherits$8(EdgeRemoveAction, _EdgeAction2);

    var _super2 = _createSuper$8(EdgeRemoveAction);

    function EdgeRemoveAction() {
      _classCallCheck$d(this, EdgeRemoveAction);

      return _super2.apply(this, arguments);
    }

    _createClass$d(EdgeRemoveAction, [{
      key: "undo",
      value: function undo() {
        this._add();
      }
    }, {
      key: "redo",
      value: function redo() {
        this._remove();
      }
    }, {
      key: "hasDeltas",
      value: function hasDeltas() {
        return this.obj != null;
      }
    }]);

    return EdgeRemoveAction;
  }(EdgeAction);

  var CompoundAction = /*#__PURE__*/function () {
    function CompoundAction(actions) {
      _classCallCheck$d(this, CompoundAction);

      this.actions = actions;

      if (this.actions == null) {
        this.actions = [];
      }
    }

    _createClass$d(CompoundAction, [{
      key: "addAction",
      value: function addAction(action) {
        this.actions.push(action);
      }
    }, {
      key: "undo",
      value: function undo() {
        this.actions.slice().reverse().forEach(function (action) {
          return action.undo();
        });
      }
    }, {
      key: "redo",
      value: function redo() {
        this.actions.forEach(function (action) {
          return action.redo();
        });
      }
    }, {
      key: "edgeChange",
      value: function edgeChange(previousId, newEdge) {
        this.actions.forEach(function (entry) {
          if (entry instanceof EdgeAction && entry.edgeId === previousId) {
            entry.edgeChange(newEdge);
          }
        });
      }
    }, {
      key: "hasDeltas",
      value: function hasDeltas() {
        for (var i = 0; i < this.actions.length; i++) {
          if (this.actions[i].hasDeltas()) {
            return true;
          }
        }

        return false;
      }
    }]);

    return CompoundAction;
  }();

  var MoveAction = /*#__PURE__*/function () {
    function MoveAction(obj, originalPosition, pos, renderer) {
      _classCallCheck$d(this, MoveAction);

      this.obj = obj;
      this.originalPosition = originalPosition;
      this.pos = pos;
      this.renderer = renderer;
    }

    _createClass$d(MoveAction, [{
      key: "redo",
      value: function redo() {
        this.renderer.setPosition(this.obj, this.pos.x, this.pos.y);
      }
    }, {
      key: "undo",
      value: function undo() {
        this.renderer.setPosition(this.obj, this.originalPosition.x, this.originalPosition.y);
      }
    }, {
      key: "hasDeltas",
      value: function hasDeltas() {
        return this.pos.x !== this.originalPosition.x && this.pos.y !== this.originalPosition.y;
      }
    }]);

    return MoveAction;
  }();

  var NodeGroupAction = /*#__PURE__*/function () {
    function NodeGroupAction(obj, toolkit) {
      _classCallCheck$d(this, NodeGroupAction);

      this.obj = obj;
      this.toolkit = toolkit;
    }

    _createClass$d(NodeGroupAction, [{
      key: "_add",
      value: function _add() {
        if (this.obj.objectType === Node.objectType) {
          this.obj = this.toolkit.addNode(this.obj.data);
        } else if (this.obj.objectType === Group.objectType) {
          this.obj = this.toolkit.addGroup(this.obj.data);
        }
      }
    }, {
      key: "_remove",
      value: function _remove() {
        this.toolkit.remove(this.obj);
      }
    }, {
      key: "getTerminusId",
      value: function getTerminusId() {
        return this.obj.getFullId();
      }
    }, {
      key: "hasDeltas",
      value: function hasDeltas() {
        return this.obj != null;
      }
    }]);

    return NodeGroupAction;
  }();
  var TerminusAddAction = /*#__PURE__*/function (_NodeGroupAction) {
    _inherits$8(TerminusAddAction, _NodeGroupAction);

    var _super = _createSuper$8(TerminusAddAction);

    function TerminusAddAction() {
      _classCallCheck$d(this, TerminusAddAction);

      return _super.apply(this, arguments);
    }

    _createClass$d(TerminusAddAction, [{
      key: "undo",
      value: function undo() {
        this._remove();
      }
    }, {
      key: "redo",
      value: function redo() {
        this._add();
      }
    }]);

    return TerminusAddAction;
  }(NodeGroupAction);
  var TerminusRemoveAction = /*#__PURE__*/function (_NodeGroupAction2) {
    _inherits$8(TerminusRemoveAction, _NodeGroupAction2);

    var _super2 = _createSuper$8(TerminusRemoveAction);

    function TerminusRemoveAction() {
      _classCallCheck$d(this, TerminusRemoveAction);

      return _super2.apply(this, arguments);
    }

    _createClass$d(TerminusRemoveAction, [{
      key: "undo",
      value: function undo() {
        this._add();
      }
    }, {
      key: "redo",
      value: function redo() {
        this._remove();
      }
    }, {
      key: "isConnectedTo",
      value: function isConnectedTo(edgeRemoveAction) {
        var tId = this.getTerminusId();
        return edgeRemoveAction.source === tId || edgeRemoveAction.target === tId;
      }
    }]);

    return TerminusRemoveAction;
  }(NodeGroupAction);
  var GroupRemoveAction = /*#__PURE__*/function (_TerminusRemoveAction) {
    _inherits$8(GroupRemoveAction, _TerminusRemoveAction);

    var _super3 = _createSuper$8(GroupRemoveAction);

    function GroupRemoveAction(params, t) {
      var _this;

      _classCallCheck$d(this, GroupRemoveAction);

      _this = _super3.call(this, params.group, t);
      _this.params = params;

      _defineProperty$c(_assertThisInitialized$8(_this), "childrenRemoved", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "orphanedChildren", void 0);

      _this.childrenRemoved = params.removeChildren;
      _this.orphanedChildren = params.children.map(function (c) {
        return c.data;
      });
      return _this;
    }

    _createClass$d(GroupRemoveAction, [{
      key: "_add",
      value: function _add() {
        var _this2 = this;

        _get$2(_getPrototypeOf$8(GroupRemoveAction.prototype), "_add", this).call(this);

        if (!this.childrenRemoved) {
          this.orphanedChildren.forEach(function (c) {
            return _this2.toolkit.addToGroup(c, _this2.obj);
          });
        }
      }
    }]);

    return GroupRemoveAction;
  }(TerminusRemoveAction);

  var UpdateAction = /*#__PURE__*/function () {
    function UpdateAction(obj, originalData, toolkit) {
      _classCallCheck$d(this, UpdateAction);

      this.obj = obj;
      this.toolkit = toolkit;

      _defineProperty$c(this, "newData", void 0);

      _defineProperty$c(this, "originalData", void 0);

      this.newData = extend({}, obj.data);
      this.originalData = extend({}, originalData);
    }

    _createClass$d(UpdateAction, [{
      key: "_getMethod",
      value: function _getMethod() {
        return "update" + this.obj.objectType;
      }
    }, {
      key: "undo",
      value: function undo() {
        this.toolkit[this._getMethod()](this.obj, this.originalData);
      }
    }, {
      key: "redo",
      value: function redo() {
        this.toolkit[this._getMethod()](this.obj, this.newData);
      }
    }, {
      key: "hasDeltas",
      value: function hasDeltas() {
        return !objectsEqual(this.newData, this.originalData);
      }
    }]);

    return UpdateAction;
  }();

  var PortAction = /*#__PURE__*/function () {
    function PortAction(obj, parent, toolkit) {
      _classCallCheck$d(this, PortAction);

      this.obj = obj;
      this.parent = parent;
      this.toolkit = toolkit;
    }

    _createClass$d(PortAction, [{
      key: "_add",
      value: function _add() {
        this.toolkit.addPort(this.parent, this.obj.data);
      }
    }, {
      key: "_remove",
      value: function _remove() {
        this.toolkit.removePort(this.parent, this.obj.id);
      }
    }, {
      key: "getTerminusId",
      value: function getTerminusId() {
        return this.obj.getFullId();
      }
    }]);

    return PortAction;
  }();
  var PortAddAction = /*#__PURE__*/function (_PortAction) {
    _inherits$8(PortAddAction, _PortAction);

    var _super = _createSuper$8(PortAddAction);

    function PortAddAction() {
      _classCallCheck$d(this, PortAddAction);

      return _super.apply(this, arguments);
    }

    _createClass$d(PortAddAction, [{
      key: "undo",
      value: function undo() {
        this._remove();
      }
    }, {
      key: "redo",
      value: function redo() {
        this._add();
      }
    }, {
      key: "hasDeltas",
      value: function hasDeltas() {
        return this.obj != null;
      }
    }]);

    return PortAddAction;
  }(PortAction);
  var PortRemoveAction = /*#__PURE__*/function (_PortAction2) {
    _inherits$8(PortRemoveAction, _PortAction2);

    var _super2 = _createSuper$8(PortRemoveAction);

    function PortRemoveAction() {
      _classCallCheck$d(this, PortRemoveAction);

      return _super2.apply(this, arguments);
    }

    _createClass$d(PortRemoveAction, [{
      key: "undo",
      value: function undo() {
        this._add();
      }
    }, {
      key: "redo",
      value: function redo() {
        this._remove();
      }
    }, {
      key: "isConnectedTo",
      value: function isConnectedTo(edgeRemoveAction) {
        var tId = this.getTerminusId();
        return edgeRemoveAction.generateSourceId() === tId || edgeRemoveAction.generateTargetId() === tId;
      }
    }, {
      key: "hasDeltas",
      value: function hasDeltas() {
        return this.obj != null;
      }
    }]);

    return PortRemoveAction;
  }(PortAction);

  var GroupAction = /*#__PURE__*/function () {
    function GroupAction(node, group, toolkit) {
      _classCallCheck$d(this, GroupAction);

      this.node = node;
      this.group = group;
      this.toolkit = toolkit;
    }

    _createClass$d(GroupAction, [{
      key: "hasDeltas",
      value: function hasDeltas() {
        return this.node != null;
      }
    }]);

    return GroupAction;
  }();

  var AddGroupMemberAction = /*#__PURE__*/function (_GroupAction) {
    _inherits$8(AddGroupMemberAction, _GroupAction);

    var _super = _createSuper$8(AddGroupMemberAction);

    function AddGroupMemberAction() {
      _classCallCheck$d(this, AddGroupMemberAction);

      return _super.apply(this, arguments);
    }

    _createClass$d(AddGroupMemberAction, [{
      key: "redo",
      value: function redo() {
        this.toolkit.addToGroup(this.node, this.group);
      }
    }, {
      key: "undo",
      value: function undo() {
        this.toolkit.removeFromGroup(this.node);
      }
    }]);

    return AddGroupMemberAction;
  }(GroupAction);
  var RemoveGroupMemberAction = /*#__PURE__*/function (_GroupAction2) {
    _inherits$8(RemoveGroupMemberAction, _GroupAction2);

    var _super2 = _createSuper$8(RemoveGroupMemberAction);

    function RemoveGroupMemberAction() {
      _classCallCheck$d(this, RemoveGroupMemberAction);

      return _super2.apply(this, arguments);
    }

    _createClass$d(RemoveGroupMemberAction, [{
      key: "redo",
      value: function redo() {
        this.toolkit.removeFromGroup(this.node);
      }
    }, {
      key: "undo",
      value: function undo() {
        this.toolkit.addToGroup(this.node, this.group);
      }
    }]);

    return RemoveGroupMemberAction;
  }(GroupAction);
  var GroupCollapseAction = /*#__PURE__*/function () {
    function GroupCollapseAction(group, renderer) {
      _classCallCheck$d(this, GroupCollapseAction);

      this.group = group;
      this.renderer = renderer;
    }

    _createClass$d(GroupCollapseAction, [{
      key: "redo",
      value: function redo() {
        this.renderer.collapseGroup(this.group);
      }
    }, {
      key: "undo",
      value: function undo() {
        this.renderer.expandGroup(this.group);
      }
    }, {
      key: "hasDeltas",
      value: function hasDeltas() {
        return this.group != null;
      }
    }]);

    return GroupCollapseAction;
  }();
  var GroupExpandAction = /*#__PURE__*/function () {
    function GroupExpandAction(group, renderer) {
      _classCallCheck$d(this, GroupExpandAction);

      this.group = group;
      this.renderer = renderer;
    }

    _createClass$d(GroupExpandAction, [{
      key: "redo",
      value: function redo() {
        this.renderer.expandGroup(this.group);
      }
    }, {
      key: "undo",
      value: function undo() {
        this.renderer.collapseGroup(this.group);
      }
    }, {
      key: "hasDeltas",
      value: function hasDeltas() {
        return this.group != null;
      }
    }]);

    return GroupExpandAction;
  }();

  var ToolkitRendererVertexRemovedAction = /*#__PURE__*/function () {
    function ToolkitRendererVertexRemovedAction(renderer, vertex, pos) {
      _classCallCheck$d(this, ToolkitRendererVertexRemovedAction);

      this.renderer = renderer;
      this.vertex = vertex;
      this.pos = pos;
    } // this action has no redo: redoing this action means that the associated vertex was once again removed from
    // the dataset


    _createClass$d(ToolkitRendererVertexRemovedAction, [{
      key: "redo",
      value: function redo() {} // undoing this action means putting the vertex back to where it was prior to it being removed.

    }, {
      key: "undo",
      value: function undo() {
        this.renderer.setPosition(this.vertex, this.pos.x, this.pos.y);
      }
    }, {
      key: "hasDeltas",
      value: function hasDeltas() {
        return this.vertex != null;
      }
    }]);

    return ToolkitRendererVertexRemovedAction;
  }();

  var EdgePathCommand = /*#__PURE__*/function () {
    function EdgePathCommand(toolkit, edge, originalGeometry, geometry, renderer) {
      _classCallCheck$d(this, EdgePathCommand);

      this.toolkit = toolkit;
      this.edge = edge;
      this.originalGeometry = originalGeometry;
      this.geometry = geometry;
      this.renderer = renderer;
    }

    _createClass$d(EdgePathCommand, [{
      key: "_apply",
      value: function _apply(g) {
        this.toolkit.fire(EVENT_EDGE_PATH_RESTORED, {
          edge: this.edge,
          geometry: g,
          renderer: this.renderer
        });
      }
    }, {
      key: "undo",
      value: function undo() {
        this._apply(this.originalGeometry);
      }
    }, {
      key: "redo",
      value: function redo() {
        this._apply(this.geometry);
      }
    }, {
      key: "hasDeltas",
      value: function hasDeltas() {
        return !objectsEqual(this.originalGeometry, this.geometry);
      }
    }]);

    return EdgePathCommand;
  }();

  var MAXIMUM_SIZE = 50;
  var CANNOT_START_WHILE_ACTIVE_MSG = "Cannot start a new transaction while one is active. Either commit/rollback the current transaction before creating a new one, or pass a cleanup flag in to this method";
  var CANNOT_ROLLBACK_FROM_HERE_MSG = "Cannot rollback transaction from here; it has been appended to. Close all transaction appenders before attempting to rollback the transaction.";

  /**
   * Manager for undo/redo operations on a JsPlumbToolkit instance. An instance of JsPlumbToolkit creates one of these automatically so
   * there is no need for library users to instantiate one.
   */
  var UndoRedoManager = /*#__PURE__*/function () {
    function UndoRedoManager(params) {
      _classCallCheck$d(this, UndoRedoManager);

      _defineProperty$c(this, "toolkit", void 0);

      _defineProperty$c(this, "maximumSize", void 0);

      _defineProperty$c(this, "suspend", void 0);

      _defineProperty$c(this, "onChange", void 0);

      _defineProperty$c(this, "undoStack", void 0);

      _defineProperty$c(this, "redoStack", void 0);

      _defineProperty$c(this, "currentTransaction", void 0);

      _defineProperty$c(this, "appendStack", 0);

      this.toolkit = params.toolkit;
      this.suspend = false;
      this.undoStack = [];
      this.redoStack = [];
      this.maximumSize = params.maximumSize || MAXIMUM_SIZE;
      this.onChange = params.onChange;

      this._bindListeners();
    }
    /**
     * Bind listeners to the events in the Toolkit we are interested in.
     * @internal
     */


    _createClass$d(UndoRedoManager, [{
      key: "_bindListeners",
      value: function _bindListeners() {
        var _this = this;

        this.toolkit.bind(EVENT_DATA_LOAD_START, function () {
          _this.clear();

          _this.suspend = true;
        });
        this.toolkit.bind(EVENT_DATA_LOAD_END, function () {
          _this.suspend = false;
        });
        this.toolkit.bind(EVENT_GRAPH_CLEARED, function () {
          _this.clear();
        });
        this.toolkit.bind(EVENT_NODE_ADDED, function (p) {
          _this.command(new TerminusAddAction(p.node, _this.toolkit));
        });
        this.toolkit.bind(EVENT_NODE_REMOVED, function (p) {
          _this.command(new TerminusRemoveAction(p.node, _this.toolkit));
        });
        this.toolkit.bind(EVENT_NODE_UPDATED, function (p) {
          if (!isEmpty(p.updates)) {
            _this.command(new UpdateAction(p.vertex, p.originalData, _this.toolkit));
          }
        });
        this.toolkit.bind(EVENT_GROUP_ADDED$1, function (p) {
          _this.command(new TerminusAddAction(p.group, _this.toolkit));
        });
        this.toolkit.bind(EVENT_GROUP_REMOVED$1, function (p) {
          _this.command(new GroupRemoveAction(p, _this.toolkit));
        });
        this.toolkit.bind(EVENT_GROUP_UPDATED, function (p) {
          if (!isEmpty(p.updates)) {
            _this.command(new UpdateAction(p.vertex, p.originalData, _this.toolkit));
          }
        });
        this.toolkit.bind(EVENT_EDGE_ADDED, function (p) {
          _this.command(new EdgeAddAction(p.edge, _this.toolkit, _this));
        });
        this.toolkit.bind(EVENT_EDGE_REMOVED, function (p) {
          _this.command(new EdgeRemoveAction(p.edge, _this.toolkit, _this));
        });
        this.toolkit.bind(EVENT_EDGE_UPDATED, function (p) {
          if (!isEmpty(p.updates)) {
            _this.command(new UpdateAction(p.edge, p.originalData, _this.toolkit));
          }
        });
        this.toolkit.bind(EVENT_EDGE_PATH_EDITED, function (p) {
          _this.command(new EdgePathCommand(_this.toolkit, p.edge, p.originalGeometry, p.geometry, p.renderer));
        });
        this.toolkit.bind(EVENT_PORT_ADDED, function (p) {
          _this.command(new PortAddAction(p.port, p.vertex, _this.toolkit));
        });
        this.toolkit.bind(EVENT_PORT_REMOVED, function (p) {
          _this.command(new PortRemoveAction(p.port, p.vertex, _this.toolkit));
        });
        this.toolkit.bind(EVENT_PORT_UPDATED, function (p) {
          if (!isEmpty(p.updates)) {
            _this.command(new UpdateAction(p.port, p.originalData, _this.toolkit));
          }
        });
        this.toolkit.bind(EVENT_GROUP_MEMBER_ADDED$1, function (p) {
          if (p.vertexIsNew !== true) {
            _this.command(new AddGroupMemberAction(p.vertex, p.group, _this.toolkit));
          }
        });
        this.toolkit.bind(EVENT_GROUP_MEMBER_REMOVED$1, function (p) {
          _this.command(new RemoveGroupMemberAction(p.vertex, p.group, _this.toolkit));
        });
        this.toolkit.bind("renderer:added", function (p) {
          p.renderer.bind(EVENT_NODE_MOVE_END, function (vmp) {
            if (vmp.originalPosition != null) {
              _this.command(new MoveAction(vmp.vertex, vmp.originalPosition, vmp.pos, vmp.renderer));
            }
          });
          p.renderer.bind(EVENT_GROUP_MOVE_END, function (vmp) {
            if (vmp.originalPosition != null) {
              _this.command(new MoveAction(vmp.vertex, vmp.originalPosition, vmp.pos, vmp.renderer));
            }
          });
          p.renderer.bind(EVENT_GROUP_COLLAPSE, function (p) {
            _this.command(new GroupCollapseAction(p.group, p.renderer));
          });
          p.renderer.bind(EVENT_GROUP_EXPAND, function (p) {
            _this.command(new GroupExpandAction(p.group, p.renderer));
          });
          p.renderer.bind(EVENT_NODE_REMOVED, function (params) {
            _this.command(new ToolkitRendererVertexRemovedAction(p.renderer, params.vertex, params.pos));
          });
          p.renderer.bind(EVENT_GROUP_REMOVED$1, function (params) {
            _this.command(new ToolkitRendererVertexRemovedAction(p.renderer, params.vertex, params.pos));
          });
        });
      }
      /**
       * Fire the on change event, if there's a listener registered.
       * @internal
       */

    }, {
      key: "_fireUpdate",
      value: function _fireUpdate() {
        this.onChange && this.onChange(this, this.undoStack.length, this.redoStack.length);
      }
      /**
       * add a command to the undo stack, clearing the redo stack.
       * @param action
       * @internal
       */

    }, {
      key: "command",
      value: function command(action) {
        if (!this.suspend) {
          // dont insert actions that do not have any deltas.
          if (!action.hasDeltas()) {
            return;
          }

          if (this.currentTransaction != null) {
            this.currentTransaction.addAction(action);
          } else {
            this.undoStack.push(action);

            if (this.undoStack.length > this.maximumSize) {
              this.undoStack.splice(this.undoStack.length - this.maximumSize - 1, this.undoStack.length - this.maximumSize);
            }

            this.redoStack.length = 0;

            this._fireUpdate();
          }
        }
      }
      /**
       * Notification that some edge has been replaced with a copy. This occurs when an edge removed is undone or an edge add is
       * redone. we need to update all references to the previous edge with this new one, as the toolkit no longer knows about
       * the old edge. This is not a method that should be called from outside of the undo manager.
       * @param previousId
       * @param newEdge
       * @internal
       */

    }, {
      key: "edgeChange",
      value: function edgeChange(previousId, newEdge) {
        var _one = function _one(list) {
          list.forEach(function (entry) {
            if (entry instanceof EdgeAction && entry.edgeId === previousId) {
              entry.edgeChange(newEdge);
            } else if (entry instanceof CompoundAction) {
              entry.edgeChange(previousId, newEdge);
            }
          });
        };

        _one(this.undoStack);

        _one(this.redoStack);
      }
      /**
       * Execute undo on the last command in the undo stack, if it isn't empty.
       */

    }, {
      key: "undo",
      value: function undo() {
        var cmd = this.undoStack.pop();

        if (cmd) {
          this.suspend = true;
          this.redoStack.push(cmd);
          cmd.undo();
          this.suspend = false;

          this._fireUpdate();
        }
      }
      /**
       * Re-execute the last command in the redo stack, if it isn't empty.
       */

    }, {
      key: "redo",
      value: function redo() {
        var cmd = this.redoStack.pop();

        if (cmd) {
          this.suspend = true;
          this.undoStack.push(cmd);
          cmd.redo();
          this.suspend = false;

          this._fireUpdate();
        }
      }
      /**
       * Clears both stacks and fires an update event.
       */

    }, {
      key: "clear",
      value: function clear() {
        this.undoStack.length = 0;
        this.redoStack.length = 0;
        this.currentTransaction = null;
        this.appendStack = 0;

        this._fireUpdate();
      }
      /**
       * Run a series of operations as a single transaction in the undo stack, meaning that they will all be undone/redone
       * at once.
       * @param fn - Series of operations to run as a transaction.
       * @param cleanupAction - Optional directive specifying what to do if there is a current transaction when this method is called.
       * @public
       */

    }, {
      key: "transaction",
      value: function transaction(fn, cleanupAction) {
        var hasCurrent = this.currentTransaction != null;

        if (hasCurrent && cleanupAction == null) {
          log(CANNOT_START_WHILE_ACTIVE_MSG);
          return;
        }

        this.openTransaction(cleanupAction);

        try {
          var result = fn();

          if (result !== false) {
            var ct = this.currentTransaction;
            this.currentTransaction = null;
            this.command(ct);
            return result;
          } else {
            this.rollbackTransaction();
          }
        } catch (e) {
          log("Exception thrown in transaction " + e.message + "; rolling transaction back");
          this.rollbackTransaction();
        }
      }
    }, {
      key: "_createNewTransaction",
      value: function _createNewTransaction() {
        this.currentTransaction = new CompoundAction();
        this.appendStack = 0;
      }
      /**
       * Open a new transaction. If a transaction is currently open this method will check the value of the
       * `cleanupAction` parameter. If it is null, an error will be thrown. Otherwise the appropriate action
       * will be taken (see @TransactionCleanupAction).
       * @param cleanupAction
       */

    }, {
      key: "openTransaction",
      value: function openTransaction(cleanupAction) {
        var createNew = true;

        if (this.currentTransaction != null) {
          if (cleanupAction != null) {
            if (cleanupAction === COMMIT_CURRENT) {
              this.commitTransaction();
            } else if (cleanupAction === ROLLBACK_CURRENT) {
              this.rollbackTransaction();
            } else if (cleanupAction === APPEND_TO_CURRENT) {
              createNew = false;
              this.appendStack++;
            } // subsequent operations will be appended to the current transaction
            else {
              throw new Error(CANNOT_START_WHILE_ACTIVE_MSG);
            }
          } else {
            throw new Error(CANNOT_START_WHILE_ACTIVE_MSG);
          }
        }

        if (createNew) {
          this._createNewTransaction();
        }

        return createNew;
      }
      /**
       * Rollback the current transaction, if there is one.
       * @public
       */

    }, {
      key: "rollbackTransaction",
      value: function rollbackTransaction() {
        if (this.currentTransaction != null) {
          if (this.appendStack > 0) {
            this.appendStack--;
            log(CANNOT_ROLLBACK_FROM_HERE_MSG);
          } else {
            this.currentTransaction.undo();
            this.currentTransaction = null;

            this._fireUpdate();
          }
        }
      }
      /**
       * Commit the current transaction.
       * @public
       */

    }, {
      key: "commitTransaction",
      value: function commitTransaction() {
        if (this.currentTransaction != null) {
          if (this.appendStack > 0) {
            this.appendStack--;
          } else {
            var ct = this.currentTransaction;
            this.currentTransaction = null;
            this.command(ct);
          }
        }
      }
      /**
       * Checks the last action in the stack to see if it was a compound action, and if so, pushes this
       * action onto it. If it wasn't a compound action, a new compound action is created with the original stack head as its
       * first action, and then this action is pushed into it. That new compound action then replaces the head of the stack.
       * @param action
       * @internal
       */

    }, {
      key: "_attach",
      value: function _attach(action) {
        if (this.undoStack.length === 0) {
          var compound = new CompoundAction();
          compound.addAction(action);
          this.command(compound);
        } else {
          var head = this.undoStack[this.undoStack.length - 1];

          if (head instanceof CompoundAction) {
            head.addAction(action);
          } else {
            this.undoStack.pop();

            var _compound = new CompoundAction();

            _compound.addAction(head);

            _compound.addAction(action);

            this.undoStack.push(_compound);
          }
        }
      }
    }]);

    return UndoRedoManager;
  }();
  /**
   * Directive to commit the current transaction if a new one has been opened before the current one has been closed.
   * @public
   */

  var COMMIT_CURRENT = "commitCurrent";
  /**
   * Directive to rollback the current transaction if a new one has been opened before the current one has been closed.
   * @public
   */

  var ROLLBACK_CURRENT = "rollbackCurrent";
  /**
   * Directive to append the operations in the new transaction to the current transaction, if a new one has been opened before the current one has been closed.
   * @public
   */

  var APPEND_TO_CURRENT = "appendToCurrent";
  /**
   * Defines the available actions in response to a new transaction being opened when one is currently open.
   * @public
   */

  /**
   * Constructor options for a Toolkit instance.
   * @public
   */

  var DEFAULT_TYPE_PROPERTY = "type";
  var DEFAULT_TYPE = "default";

  var DEV_NULL = function DEV_NULL() {};
  /**
   * Definition of a function that can act as a factory for model objects.
   * @public
   */


  var UPDATE_NODE_REASON_ADD_PORT = "addport";
  var UPDATE_NODE_REASON_ADD_NEW_PORT = "addnewport";
  var UPDATE_NODE_REASON_REMOVE_PORT = "removeport";
  var UPDATE_NODE_REASON_UPDATE_PORT = "updateport";
  var UPDATE_NODE_REASON_MOVED = "moved";

  /**
   * Core Toolkit functionality. This class is extended by renderer specific subclasses.
   * @public
   */
  var JsPlumbToolkit = /*#__PURE__*/function (_OptimisticEventGener) {
    _inherits$8(JsPlumbToolkit, _OptimisticEventGener);

    var _super = _createSuper$8(JsPlumbToolkit);

    function JsPlumbToolkit(params) {
      var _this;

      _classCallCheck$d(this, JsPlumbToolkit);

      _this = _super.call(this);

      _defineProperty$c(_assertThisInitialized$8(_this), "graph", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "autoSaver", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "idFunction", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "typeProperty", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "edgeTypeProperty", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "portTypeProperty", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "typeFunction", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "edgeIdFunction", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "edgeTypeFunction", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "portIdFunction", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "portTypeFunction", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "portExtractor", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "portUpdater", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "portDataProperty", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "portOrderProperty", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "modelTopAttribute", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "modelLeftAttribute", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "model", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "suspendGraph", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "dataLoading", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "_originalData", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "_originalDataType", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "debugEnabled", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "defaultObjectFactory", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "nodeFactory", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "edgeFactory", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "portFactory", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "groupFactory", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "autoSave", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "saveUrl", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "autoSaveDebounceTimeout", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "autoSaveHandler", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "saveHeaders", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "onAutoSaveSuccess", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "onAutoSaveError", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "doNotUpdateOriginalData", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "onBeforeAutoSave", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "onAfterAutoSave", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "portSeparator", ".");

      _defineProperty$c(_assertThisInitialized$8(_this), "defaultCost", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "defaultDirected", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "enableSubgraphs", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "undoRedo", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "graphParams", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "beforeConnect", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "beforeMoveConnection", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "beforeStartConnect", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "beforeDetach", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "beforeStartDetach", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "_currentSelection", void 0);

      _defineProperty$c(_assertThisInitialized$8(_this), "_renderersById", new Map());

      params = params || {};
      var undoRedoParams = params.undoRedo || {};

      if (undoRedoParams.enabled !== false) {
        _this.undoRedo = new UndoRedoManager({
          toolkit: _assertThisInitialized$8(_this),
          maximumSize: undoRedoParams.maximumSize,
          onChange: function onChange(instance, undoCount, redoCount) {
            _this.fire(EVENT_UNDOREDO_UPDATE, {
              undoCount: undoCount,
              redoCount: redoCount
            });
          }
        });
      }

      _this.idFunction = params.idFunction || defaultIdFunction;
      _this.typeProperty = params.typeProperty || DEFAULT_TYPE_PROPERTY;
      _this.edgeTypeProperty = params.edgeTypeProperty || DEFAULT_TYPE_PROPERTY;
      _this.portTypeProperty = params.portTypeProperty || DEFAULT_TYPE_PROPERTY;

      _this.typeFunction = params.typeFunction || function (d) {
        return d[_this.typeProperty] || DEFAULT_TYPE;
      };

      _this.edgeIdFunction = params.edgeIdFunction || _this.idFunction;

      _this.edgeTypeFunction = params.edgeTypeFunction || function (d) {
        return d[_this.edgeTypeProperty] || DEFAULT_TYPE;
      };

      _this.portIdFunction = params.portIdFunction || _this.idFunction;

      _this.portTypeFunction = params.portTypeFunction || function (d) {
        return d[_this.portTypeProperty] || DEFAULT_TYPE;
      };

      _this.portExtractor = params.portExtractor;
      _this.portUpdater = params.portUpdater;
      _this.portDataProperty = params.portDataProperty;
      _this.portOrderProperty = params.portOrderProperty;
      _this.suspendGraph = false;
      _this.debugEnabled = false;
      _this.model = new DataModel(_assertThisInitialized$8(_this), params.model);

      _this.defaultObjectFactory = function (type, data, callback) {
        data = data == null || !isObject(data) ? {} : data;
        data = clone(data);
        data.id = data.id || uuid();
        data.type = data.type || (type == null ? null : type.type || type);
        callback(data);
        return true;
      };

      _this.modelLeftAttribute = params.modelLeftAttribute || "left";
      _this.modelTopAttribute = params.modelTopAttribute || "top";
      _this.nodeFactory = params.nodeFactory || _this.defaultObjectFactory;
      _this.edgeFactory = params.edgeFactory || _this.defaultObjectFactory;
      _this.portFactory = params.portFactory || _this.defaultObjectFactory;
      _this.groupFactory = params.groupFactory || _this.defaultObjectFactory;
      _this.autoSave = params.autoSave === true && (params.saveUrl != null || params.autoSaveHandler != null);
      _this.autoSaveDebounceTimeout = params.autoSaveDebounceTimeout;
      _this.autoSaveHandler = params.autoSaveHandler;
      _this.saveUrl = params.saveUrl;
      _this.saveHeaders = params.saveHeaders;
      _this.onAutoSaveSuccess = params.onAutoSaveSuccess || DEV_NULL;
      _this.onAutoSaveError = params.onAutoSaveError || DEV_NULL;
      _this.doNotUpdateOriginalData = params.doNotUpdateOriginalData === true;
      _this.onBeforeAutoSave = params.onBeforeAutoSave || DEV_NULL;
      _this.onAfterAutoSave = params.onAfterAutoSave || DEV_NULL;
      _this.graphParams = {
        portSeparator: params.portSeparator,
        defaultCost: params.defaultCost,
        defaultDirected: params.defaultDirected,
        enableSubgraphs: params.enableSubgraphs
      };

      if (_this.portDataProperty != null && _this.portExtractor == null) {
        _this.portExtractor = function (data) {
          var portData = data[_this.portDataProperty] || [];

          if (_this.portOrderProperty != null) {
            portData.sort(function (a, b) {
              var _a = a[_this.portOrderProperty],
                  _b = b[_this.portOrderProperty],
                  __a = _a == null ? Infinity : _a,
                  __b = _b == null ? Infinity : _b;

              return __a - __b;
            });
          }

          return portData;
        };
      }

      if (_this.portDataProperty != null && _this.portUpdater == null) {
        _this.portUpdater = function (data, node, ports) {
          var d = {};

          if (_this.portOrderProperty != null) {
            ports.sort(function (a, b) {
              var _a = a.data[_this.portOrderProperty],
                  _b = b.data[_this.portOrderProperty],
                  __a = _a == null ? Infinity : _a,
                  __b = _b == null ? Infinity : _b;

              return __a - __b;
            });
          }

          d[_this.portDataProperty] = ports.map(function (p) {
            return p.data;
          });
          return extend(data, d);
        };
      }

      _this.graph = new Graph(_this.graphParams);

      if (_this.autoSave) {
        _this.autoSaver = new AutoSaver(_assertThisInitialized$8(_this), {
          saveUrl: _this.saveUrl,
          saveHeaders: _this.saveHeaders,
          onAutoSaveSuccess: _this.onAutoSaveSuccess,
          onAutoSaveError: _this.onAutoSaveError,
          onBeforeAutoSave: _this.onBeforeAutoSave,
          onAfterAutoSave: _this.onAfterAutoSave,
          autoSaveDebounceTimeout: _this.autoSaveDebounceTimeout,
          autoSaveHandler: _this.autoSaveHandler
        });
      } // catch all event handler fires 'dataUpdated' for lots of events.


      new CatchAllEventHandler(_assertThisInitialized$8(_this));

      var _defaultConnectHandler = function _defaultConnectHandler(source, target) {
        if (_this.model == null) return true; // shortcut for setups where there is no model on the toolkit.

        var st = _this.getType(source),
            tt = _this.getType(target),
            sourceVertex = isPort(source) ? source.getParent() : source,
            targetVertex = isPort(target) ? target.getParent() : target,
            sourceDefinition = isPort(source) ? _this.model.getPortDefinition(st) : isNode(source) ? _this.model.getNodeDefinition(st) : _this.model.getGroupDefinition(st),
            targetDefinition = isPort(target) ? _this.model.getPortDefinition(tt) : isNode(target) ? _this.model.getNodeDefinition(tt) : _this.model.getGroupDefinition(tt),
            sourceVertexDefinition = isNode(sourceVertex) ? _this.model.getNodeDefinition(st) : _this.model.getGroupDefinition(st),
            targetVertexDefinition = isNode(targetVertex) ? _this.model.getNodeDefinition(tt) : _this.model.getGroupDefinition(tt);

        if (sourceDefinition.maxConnections != null && source.getEdges().length >= sourceDefinition.maxConnections) {
          return false;
        }

        if (targetDefinition.maxConnections != null && target.getEdges().length >= targetDefinition.maxConnections) {
          return false;
        } // its loopback if the source is the same as the target (whether they be nodes/groups or ports).


        if (source === target) {
          return !(sourceVertexDefinition.allowLoopback === false || sourceDefinition.allowLoopback === false || targetDefinition.allowLoopback === false || targetVertexDefinition.allowLoopback === false);
        } // its nodeLoopback if the source node is the same as the target node.


        if (sourceVertex === targetVertex) {
          return !(sourceVertexDefinition.allowVertexLoopback === false || sourceDefinition.allowVertexLoopback === false || targetDefinition.allowVertexLoopback === false || targetVertexDefinition.allowVertexLoopback === false);
        }

        return true;
      };

      _this.beforeConnect = params.beforeConnect || _defaultConnectHandler;
      _this.beforeMoveConnection = params.beforeMoveConnection || _defaultConnectHandler;

      _this.beforeStartConnect = params.beforeStartConnect || function (obj, edgeType) {
        return {};
      };

      _this.beforeDetach = params.beforeDetach || function (source, target, edge) {
        return true;
      };

      _this.beforeStartDetach = params.beforeStartDetach || function (nodeOrPort, edge) {
        return true;
      };

      _this._currentSelection = _this._createSelection(function (sel) {
        _this.fire(EVENT_SELECTION_CLEARED, {
          selection: sel
        });
      });

      if (params.maxSelectedNodes) {
        _this._currentSelection.setMaxNodes(params.maxSelectedNodes);
      }

      if (params.maxSelectedGroups) {
        _this._currentSelection.setMaxGroups(params.maxSelectedGroups);
      }

      if (params.maxSelectedEdges) {
        _this._currentSelection.setMaxEdges(params.maxSelectedEdges);
      }

      if (params.selectionCapacityPolicy) {
        _this._currentSelection.setCapacityPolicy(params.selectionCapacityPolicy);
      }

      if (params.data != null) {
        _this.load({
          data: params.data
        });
      }

      return _this;
    }

    _createClass$d(JsPlumbToolkit, [{
      key: "_createSelection",
      value: function _createSelection(onClear) {
        return new Selection(this, {
          onClear: onClear || function () {}
        });
      }
      /**
       * Filter the dataset and return a Selection containing matches. You can optionally provide a type parameter to indicate the type of objects you expect
       * back in the Selection.
       * @param spec Either a function which is passed every object in the dataset and expected to return `true` to indicate inclusion, or an object containg key:value pairs to match in the backing data of each object in the dataset
       * @param includePartials If true, objects whose data matches one or more, but not all, of the pairs in `spec` will be included in the result. By default objects have to match all the pairs in `spec` to be included in the result.
       */

    }, {
      key: "filter",
      value: function filter(spec, includePartials) {
        var fn = typeof spec === "function" ? spec : function (obj) {
          var d = obj.data,
              out = false,
              _spec = spec;

          for (var i in _spec) {
            var match = _spec[i] === d[i];

            if (!match && !includePartials) {
              return false;
            }

            out = out || match;
          }

          return out;
        },
            s = this._createSelection();

        this.eachNode(function (i, n) {
          if (fn(n)) {
            s.append(n);
          }

          var o = n.getPorts();

          for (var j = 0; j < o.length; j++) {
            if (fn(o[j])) {
              s.append(o[j]);
            }
          }
        });
        this.eachEdge(function (i, e) {
          if (fn(e)) {
            s.append(e);
          }
        });
        this.eachGroup(function (i, e) {
          if (fn(e)) {
            s.append(e);
          }
        });
        return s;
      }
      /**
       * Gets the model registered with this Toolkit instance, if any. Use the Toolkit's model to map data model event
       * handlers and other data model considerations such as the maximum number of connections a Port allows
       * @returns Current model. May be null.
       */

    }, {
      key: "getModel",
      value: function getModel() {
        return this.model;
      }
      /**
       * Sets whether operations on the underlying graph are
       * @param v
       * @public
       */

    }, {
      key: "setSuspendGraph",
      value: function setSuspendGraph(v) {
        this.suspendGraph = v;
      }
      /**
       * Sets options for the auto save mechanism.
       * @param autoSaveOptions
       * @public
       */

    }, {
      key: "setAutoSave",
      value: function setAutoSave(autoSaveOptions) {
        if (this.autoSaver != null) {
          this.autoSaver.discard();
        }

        this.autoSaver = new AutoSaver(this, autoSaveOptions);
      }
      /**
       * Sets whether or not the original dataset will be updated whenever a node/edge is removed or added. This functionality is suspended
       * when a `load` operation is taking place. Note that for this functionality to work there must be a `manager` registered for the given
       * data type in jsPlumbToolkitIO. The Toolkit ships with a manager for the default `json` datatype, but if you have your own custom
       * datatype you will need to provide one of these to support this functionality. See the documentation on data loading for a full
       * discussion.
       * @param update True if you want the backing data to be updated, false otherwise.
       * @public
       */

    }, {
      key: "setDoNotUpdateOriginalData",
      value: function setDoNotUpdateOriginalData(update) {
        this.doNotUpdateOriginalData = update;
      }
      /**
       * Returns the type function that is currently in use.
       * @returns Function currently being used to determine types of nodes from their data. The default is to look for a `type` member in the data.
       * @public
       */

    }, {
      key: "getTypeFunction",
      value: function getTypeFunction() {
        return this.typeFunction;
      }
      /**
       * Connects two nodes/ports (or a combination of the two), by ID.  This function does not know about the DOM: you cannot pass it DOM elements
       * or selectors. By default, this method will create nodes that are missing. Port ids are specified with a dotted syntax, eg `foo.bar` refers
       * to the port "bar" on the node "foo".
       * @param params Connect parameters.
       * @returns The new Edge.
       * @public
       */

    }, {
      key: "connect",
      value: function connect(params) {
        var edge;

        if (!this.suspendGraph) {
          var sv = this.graph.getVertex(params.source),
              tv = this.graph.getVertex(params.target),
              cost = params.cost,
              directed = params.directed;

          if (!sv) {
            if (!params.doNotCreateMissingNodes) {
              sv = this.graph.addNode(params.source);
              this.fire(EVENT_NODE_ADDED, {
                data: {},
                node: sv
              });
            } else return; // probaby better to throw here? but maybe not.

          }

          if (!tv) {
            if (!params.doNotCreateMissingNodes) {
              tv = this.graph.addNode(params.target);
              this.fire(EVENT_NODE_ADDED, {
                data: {},
                node: tv
              });
            } else return;
          }

          var currentData = params.data || {};

          var _continue = this.beforeStartConnect(sv, this.edgeTypeFunction(currentData));

          if (_continue) {
            if (_typeof(_continue) === "object") {
              currentData = extend(_continue, currentData);
            }

            var _reallyContinue = this.beforeConnect(sv, tv, currentData);

            if (_reallyContinue !== false) {
              edge = this.graph.addEdge({
                source: sv,
                target: tv,
                cost: cost,
                directed: directed,
                data: currentData,
                geometry: params.geometry
              });
              this.fire(EVENT_EDGE_ADDED, {
                edge: edge,
                geometry: params.geometry,
                addedByMouse: false
              });
            }
          }
        }

        return edge;
      }
      /**
       * Fires a 'graphClearStart' event, clears the graph, then fires a `graphClearEnd` event.
       * @returns The current Toolkit instance.
       * @public
       */

    }, {
      key: "clear",
      value: function clear() {
        this.fire(EVENT_GRAPH_CLEAR_START);
        this.graph.clear();
        this.fire(EVENT_GRAPH_CLEARED);
        return this;
      }
      /**
       * Returns the current Graph.
       * @returns The underlying Graph.
       * @public
       */

    }, {
      key: "getGraph",
      value: function getGraph() {
        return this.graph;
      }
      /**
       * Returns the count of nodes in the Graph.
       * @returns The count of Nodes in the Graph.
       * @public
       */

    }, {
      key: "getNodeCount",
      value: function getNodeCount() {
        return this.graph.getVertexCount();
      }
      /**
       * Returns the Node at the given index.
       * @returns The Node at the given index, null if not found.
       * @public
       */

    }, {
      key: "getNodeAt",
      value: function getNodeAt(idx) {
        return this.graph.getVertexAt(idx);
      }
      /**
       * Returns all the nodes in the Graph.
       * @returns All the Nodes in the graph.
       * @public
       */

    }, {
      key: "getNodes",
      value: function getNodes() {
        return this.graph.getVertices();
      }
      /**
       * Iterates through all Nodes in the Toolkit one at a time. You should not perform destructive editing of
       * the dataset inside one of these loops.
       * @param fn A function that takes (index, node) as arguments and is applied for every Node in the Toolkit instance.
       * @public
       */

    }, {
      key: "eachNode",
      value: function eachNode(fn) {
        var v;

        for (var i = 0, j = this.graph.getVertexCount(); i < j; i++) {
          v = this.graph.getVertexAt(i);
          fn(i, v);
        }
      }
      /**
       * Iterates through all Groups in the Toolkit one at a time. You should not perform destructive editing of
       * the dataset inside one of these loops.
       * @param fn A function that takes (index, node) as arguments and is applied for every Node in the Toolkit instance.
       * @public
       */

    }, {
      key: "eachGroup",
      value: function eachGroup(fn) {
        var v;

        for (var i = 0, j = this.graph.getGroupCount(); i < j; i++) {
          v = this.graph.getGroupAt(i);
          fn(i, v);
        }
      }
      /**
       * Combines eachNode and eachGroup into one method.
       * @param fn
       * @public
       */

    }, {
      key: "eachVertex",
      value: function eachVertex(fn) {
        this.eachNode(fn);
        this.eachGroup(fn);
      }
      /**
       * Iterates through all Edges in the Toolkit one at a time. You should not perform destructive editing of
       * the dataset inside one of these loops.
       * @param fn A function that takes (index, edge) as arguments and is applied for every Node in the Toolkit instance.
       * @public
       */

    }, {
      key: "eachEdge",
      value: function eachEdge(fn) {
        var e = this.graph.getEdges();

        for (var i = 0, j = e.length; i < j; i++) {
          fn(i, e[i]);
        }
      }
      /**
       * Returns the total number of edges in the graph.
       * @public
       */

    }, {
      key: "getEdgeCount",
      value: function getEdgeCount() {
        return this.graph.getEdgeCount();
      }
      /**
       * Returns the total number of group in the Graph.
       * @public
       */

    }, {
      key: "getGroupCount",
      value: function getGroupCount() {
        return this.graph.getGroupCount();
      }
      /**
       * Returns the Group at the given index, null if not found.
       * @param idx Index into group list
       * @public
       */

    }, {
      key: "getGroupAt",
      value: function getGroupAt(idx) {
        return this.graph.getGroupAt(idx);
      }
      /**
       * Returns all the Groups in the Graph.
       * @public
       */

    }, {
      key: "getGroups",
      value: function getGroups() {
        return this.graph.getGroups();
      }
      /**
       * Calculates "clusters" of nodes (and groups), where a 'cluster' is a set of Nodes/Groups that
       * are connected. Direction of connections is not taken into account. Nodes that are children of Groups are
       * included in all cluster calculations, which might cause some weird situations, but this functionality
       * is mostly intended just for Nodes anyway.
       * @returns An array of arrays, each entry being a list of nodes in the cluster.
       * @public
       */

    }, {
      key: "getClusters",
      value: function getClusters() {
        return this.graph.getClusters();
      }
      /**
       * Gets the id of the Node represented by the given arguments. If this is a JS object, we extract the id using the
       * current idFunction. Otherwise we just pass it back as-is.
       * @param node Object from which to retrieve id.
       * @public
       */

    }, {
      key: "getNodeId",
      value: function getNodeId(node) {
        return typeof node === "string" ? node : this.idFunction(node);
      }
      /**
       * Gets the type of the Node represented by the given JS object. We first try for a return value from the current typeFunction,
       * but if that returns nothing we just return 'default'.
       * @param nodeData  Node's data. Note: this is NOT a Node object, it is the backing data. You can use
       * `getType` to get the type for some Toolkit object.
       * @returns Either the object's type, or `default`.
       * @public
       */

    }, {
      key: "getNodeType",
      value: function getNodeType(nodeData) {
        return this.typeFunction(nodeData) || "default";
      }
      /**
       * Gets the id of the Edge represented by the given arguments. If this is a JS object, we extract the id using the
       * current edgeIdFunction. Otherwise we just pass it back as-is.
       * @param edge Edge from which to retrieve id.
       * @returns Edge's id, if we could resolve it, otherwise the object we were given.
       * @public
       */

    }, {
      key: "getEdgeId",
      value: function getEdgeId(edge) {
        return this.edgeIdFunction(edge);
      }
      /**
       * Gets the type of the Edge represented by the given JS object.
       * @param edgeData Edge's data. Note: this is NOT an Edge object, it is the backing data. You can use
       * `getType` to get the type for some Toolkit object.
       * @returns Either the Edge's type, if set, or "default".
       * @public
       */

    }, {
      key: "getEdgeType",
      value: function getEdgeType(edgeData) {
        return this.edgeTypeFunction(edgeData) || "default";
      }
      /**
       * Gets the id of the Port represented by the given arguments. If this is a JS object, we extract the id using the
       * current portIdFunction. Otherwise we just pass it back as-is.
       * @returns Port's id, if we could resolve it, otherwise the object we were given.
       * @public
       */

    }, {
      key: "getPortId",
      value: function getPortId(port) {
        return this.portIdFunction(port);
      }
      /**
       * Gets the type of the Port represented by the given JS object
       * @returns Either the port's type, if set, or "default".
       * @public
       */

    }, {
      key: "getPortType",
      value: function getPortType(port) {
        return this.portTypeFunction(port) || "default";
      }
      /**
       * Gets the type of the given Object. This is not a type such as `Node`, `Port` or `Edge` - this is the type of the
       * object as defined by your system to identify types; these are the types used to lookup objects in the view.
       * @param obj Object to retrieve type for
       * @returns The object's type.
       * @public
       */

    }, {
      key: "getType",
      value: function getType(obj) {
        var m = isNode(obj) ? this.typeFunction : isPort(obj) ? this.portTypeFunction : this.edgeTypeFunction;
        return m(obj.data) || "default";
      }
      /**
       * Sets the type of the given object. This will do two things:
       * 1. update the appropriate property in the object's data to this new value. You can set what properties define
       * types, but by default each of Node, Edge and Port use `type` as the property that indicates their type.
       * 2. attempt to apply a type definition for the new type, if one is found. NB this only applies to Edge objects,
       * as at version 1.1.0. Support for Nodes (including switching node templates) is a possible future enhancement.
       * @param obj Object to set the type for.
       * @param type Type to set on the object.
       * @public
       */

    }, {
      key: "setType",
      value: function setType(obj, type) {
        var currentType = this.getType(obj);
        if (currentType === type) return;
        var m = obj.objectType === Node.objectType ? this.typeProperty : obj.objectType === Port.objectType ? this.portTypeProperty : this.edgeTypeProperty;
        var evt;

        if (isNode(obj)) {
          evt = EVENT_NODE_TYPE_CHANGED;
        } else if (isPort(obj)) {
          evt = EVENT_PORT_TYPE_CHANGED;
        } else if (isEdge(obj)) {
          evt = EVENT_EDGE_TYPE_CHANGED;
        } else if (isGroup(obj)) {
          evt = EVENT_GROUP_TYPE_CHANGED;
        }

        obj.data[m] = type;

        if (evt != null) {
          this.fire(evt, {
            obj: obj,
            previousType: currentType,
            newType: type
          });
        }
      }
      /**
       * Adds a Node with the given data. If the data is null, the Toolkit creates an empty object and assigns
       * a uuid as the Node's id.  If no id can be derived for the given data, the Toolkit creates a uuid and
       * sets it as the data object's 'id' member. This method also calls the current `portExtractor` function, if
       * one was supplied. Its purpose is to extract any Ports from the data for some given Node.
       * @param data The Node's backing data - from your data model.
       * @param eventInfo Optional data member that the Toolkit will pass into any registered event listeners. This can be used
       * by the UI layer, for instance, to track the position on screen of any newly added elements.
       * @returns A Node object.  Your original data is available via the `data` member. The Node's id is available via the `id` member.
       * @public
       */

    }, {
      key: "addNode",
      value: function addNode(data, eventInfo, doNotFireEvent) {
        var id = this.idFunction(data);
        var group = null; // assign an id if one was not supplied.

        if (id == null && typeof data !== "string") {
          data.id = uuid();
        }

        var v = this.graph.addNode(data, this.idFunction);

        if (v != null) {
          // optionally extract port information
          if (this.portExtractor != null) {
            var ports = this.portExtractor(v.data, v);

            if (ports != null) {
              for (var i = 0; i < ports.length; i++) {
                v.addPort(ports[i], this.portIdFunction);
              }
            }
          } // is the node a member of a group?


          if (typeof data !== "string" && data.group != null) {
            group = this.getGroup(data.group);

            if (group != null) {
              group.addMember(v);
            } else {
              throw new Error("parent group [" + data.group + "] not found");
            }
          }

          if (!this.dataLoading && !this.doNotUpdateOriginalData) {
            manage(ManagedOperations.addNode, this._originalData, this._originalDataType, v, this.idFunction || this.graph.getIdFunction());
          } // if not null, it didnt exist. fire event and return. Pass in the optional eventInfo params here to the listener.


          if (!doNotFireEvent) {
            this.fire(EVENT_NODE_ADDED, {
              data: data,
              node: v,
              eventInfo: eventInfo,
              parentGroup: group
            });
          }

          if (group != null) {
            this.fire(EVENT_GROUP_MEMBER_ADDED, {
              group: group,
              vertex: v,
              vertexIsNew: true
            });
          }

          return v;
        } else // otherwise get the existing node.
          return this.graph.getVertex(id);
      }
      /**
       * Adds a Node by type, running the data generation for the node through the current NodeFactory.  This is
       * different from `addNode` in that with `addNode` you are supplying the final data and your NodeFactory is
       * not called. This method can be called with one, two or three arguments. A single argument is considered to be
       * the new Node's `type`, and a backing data object will be created with this set, and no callback will occur.
       * If you provide two arguments the second argument may be either the new Node's backing data OR a callback to
       * hit with the newly created Node. With three arguments the second argument is the Node's backing data and the
       * third is a callback to hit with the newly created Node.
       * @param type Required. Type of the object to create. `type` will be passed as the first argument to your node factory.
       * @param data Optional backing data for the Node.
       * @param continueCallback Optional function to call with the newly created Node.
       * @param abortCallback Optional function to call if the factory aborted the node add.
       * @public
       */

    }, {
      key: "addFactoryNode",
      value: function addFactoryNode(type, data, continueCallback, abortCallback) {
        var _this2 = this;

        if (continueCallback == null) {
          if (data != null) {
            data = _typeof(data) === "object" ? data : {};
            continueCallback = typeof data === "function" ? data : null;
          } else {
            data = {};
          }
        }

        data.type = data.type || type;
        this.openTransaction();
        this.nodeFactory(type, data, function (n) {
          var node = _this2.addNode(n);

          if (continueCallback) {
            continueCallback(node);
          }

          _this2.commitTransaction();
        }, function () {
          if (abortCallback) {
            abortCallback();
          }

          _this2.rollbackTransaction();
        });
      }
      /**
       * Adds a list of Nodes.
       * @param nodeList An array of objects, one for each Node to be added.
       * @returns The current Toolkit instance.
       * @public
       */

    }, {
      key: "addNodes",
      value: function addNodes(nodeList) {
        for (var i = 0; i < nodeList.length; i++) {
          this.addNode(nodeList[i]);
        }

        return this;
      }
      /**
       * Adds a Group by type, running the data generation for the node through the current GroupFactory.  This is
       * different from `addGroup` in that with `addGroup` you are supplying the final data and your GroupFactory is
       * not called. This method can be called with one, two or three arguments. A single argument is considered to be
       * the new Group's `type`, and a backing data object will be created with this set, and no callback will occur.
       * If you provide two arguments the second argument may be either the new Group's backing data OR a callback to
       * hit with the newly created Group. With three arguments the second argument is the Group's backing data and the
       * third is a callback to hit with the newly created Group.
       * @param type Required. Type of the object to create. `type` will be passed as the first argument to your group factory.
       * @param data Optional backing data for the Group.
       * @param continueCallback Optional function to call with the newly created Group.
       * @param abortCallback Optional function to call if the group factory aborted
       * @public
       */

    }, {
      key: "addFactoryGroup",
      value: function addFactoryGroup(type, data, continueCallback, abortCallback) {
        var _this3 = this;

        if (continueCallback == null) {
          if (data != null) {
            data = _typeof(data) === "object" ? data : {};
            continueCallback = typeof data === "function" ? data : null;
          } else if (data == null && continueCallback == null) {
            data = {};
          }
        }

        data.type = data.type || type;
        this.openTransaction();
        this.groupFactory(type, data, function (g) {
          var group = _this3.addGroup(g);

          if (continueCallback) {
            continueCallback(group);
          }

          _this3.commitTransaction();
        }, function () {
          if (abortCallback) {
            abortCallback();
          }

          _this3.rollbackTransaction();
        });
      }
      /**
       * Adds a new Group.
       * @param data Backing data for the Group.
       * @param eventInfo Used internally, sometimes, by the Toolkit.
       * @param doNotFireEvent Internal usage.
       * @returns The Group that was added.
       * @public
       */

    }, {
      key: "addGroup",
      value: function addGroup(data, eventInfo, doNotFireEvent) {
        var parentGroup, g;
        var id = this.idFunction(data); // assign an id if one was not supplied.

        if (id == null && typeof data !== "string") {
          data.id = uuid();
        }

        g = this.graph.addGroup(data, this.idFunction);

        if (g != null) {
          // is the node a member of a group?
          if (typeof data !== "string" && data.group != null) {
            parentGroup = this.getGroup(data.group);

            if (parentGroup == null) {
              throw new Error("Cannot find parent group [" + data.group + "]");
            } else {
              parentGroup.addMember(g);
            }
          }

          if (!this.dataLoading && !this.doNotUpdateOriginalData) {
            manage(ManagedOperations.addGroup, this._originalData, this._originalDataType, g, this.idFunction || this.graph.getIdFunction());
          } // if not null, it didnt exist. fire event and return. Pass in the optional eventInfo params here to the listener.


          if (!doNotFireEvent) {
            this.fire(EVENT_GROUP_ADDED, {
              data: data,
              group: g,
              eventInfo: eventInfo,
              parentGroup: parentGroup
            });

            if (parentGroup != null) {
              this.fire(EVENT_GROUP_MEMBER_ADDED, {
                group: parentGroup,
                vertex: g,
                vertexIsNew: true
              });
            }
          }
        }

        return g;
      }
      /**
       * Adds a Node/Group to a Group.
       * @param node Node to add
       * @param group Group to add the Node/Group to
       * @param sourceGroup Optional Group the Node previously belonged to.
       * @param position Optional previous position of the Node in `sourceGroup`.
       * @param source For internal use. Identifies the renderer that instigated this model change. This renderer will not subsequently respond to the model change, since it already knows about it and its UI has been changed accordingly already.
       * @returns True if added, false otherwise.
       * @public
       */

    }, {
      key: "addToGroup",
      value: function addToGroup(node, group, sourceGroup, position, source) {
        var added = false;
        var groupInfo = this.getObjectInfo(group);
        var nodeInfo = this.getObjectInfo(node);

        if (nodeInfo.obj && groupInfo.obj) {
          added = groupInfo.obj.addMember(nodeInfo.obj);

          if (added) {
            nodeInfo.obj.data.group = groupInfo.obj.id;
            var p = {
              vertex: nodeInfo.obj,
              group: groupInfo.obj,
              pos: position,
              source: source
            };

            if (sourceGroup) {
              p.sourceGroup = sourceGroup;
            }

            this.fire(EVENT_GROUP_MEMBER_ADDED, p);
            this.fire(EVENT_DATA_UPDATED);
          }
        }

        return added;
      }
      /**
       * Removes a Node/Group from a Group.
       * @param node Node/Group to remove, or its id, or the data representing it.
       * @param doNotFireEvent For internal use. If true, a `group:removeMember` event will not be fired as a result of
       * this operation. Otherwise it will.
       * @param targetGroup For internal use. Group to which the Node is being moved, if that applies.
       * @param source For internal use. The renderer in which user activity caused this method to be called. We echo that out in the
       * event parameters, allowing renderers to not respond to events they raised.
       * @returns The Group from which the Node was removed.
       * @public
       */

    }, {
      key: "removeFromGroup",
      value: function removeFromGroup(node, doNotFireEvent, targetGroup, source) {
        var info = this.getObjectInfo(node);
        var group;

        if (info.obj && info.obj.group) {
          group = info.obj.group;

          if (group.removeMember(info.obj)) {
            delete info.obj.data.group;

            if (!doNotFireEvent) {
              var p = {
                group: group,
                source: source,
                vertex: info.obj
              };

              if (targetGroup) {
                p.targetGroup = targetGroup;
              }

              this.fire(EVENT_GROUP_MEMBER_REMOVED, p);
            }

            this.fire(EVENT_DATA_UPDATED);
          }
        }

        return group;
      }
    }, {
      key: "_notifyGroupRemoved",
      value: function _notifyGroupRemoved(group, childrenWereRemoved, doNotFireEvent) {
        var _this4 = this;

        group.nestedGroups.forEach(function (nestedGroup) {
          return _this4._notifyGroupRemoved(nestedGroup, childrenWereRemoved, doNotFireEvent);
        });
        group.nodes.forEach(function (node) {
          return _this4._notifyNodeRemoved(node, doNotFireEvent);
        });

        for (var i = 0; i < group.edges.length; i++) {
          this._notifyEdgeRemoved(group.edges[i]);
        }

        if (!childrenWereRemoved) {
          group.children.forEach(function (v) {//
          });
        }

        if (!this.dataLoading && !this.doNotUpdateOriginalData) {
          manage(ManagedOperations.removeGroup, this._originalData, this._originalDataType, group.group, this.idFunction || this.graph.getIdFunction());
        }

        if (!doNotFireEvent) {
          this.fire(EVENT_GROUP_REMOVED, {
            group: group.group,
            groupId: group.group.id,
            removeChildren: childrenWereRemoved,
            children: group.children,
            parentGroup: group.parentGroup
          });
        }
      }
    }, {
      key: "_notifyNodeRemoved",
      value: function _notifyNodeRemoved(node, doNotFireEvent) {
        for (var i = 0; i < node.edges.length; i++) {
          this._notifyEdgeRemoved(node.edges[i]);
        } // optionally, clean up the original backing data. requires that a DataManager for the current _originalDataType be registered
        // on jsPlumbToolkitIO


        if (!this.dataLoading && !this.doNotUpdateOriginalData) {
          manage(ManagedOperations.removeNode, this._originalData, this._originalDataType, node.node, this.idFunction || this.graph.getIdFunction());
        }

        if (!doNotFireEvent) {
          this.fire(EVENT_NODE_REMOVED, {
            node: node.node,
            nodeId: node.node.id,
            edges: node.edges,
            parentGroup: node.parentGroup
          });
        }
      }
      /**
       * Removes the given Group from the dataset.
       * @param group Group or ID of Group to remove.
       * @param removeChildren If true, Nodes/Groups that are members of the Group will also be
       * removed. Defaults to false.
       * @param doNotFireEvent  If true, a `group:removed` will not be fired as a result of this
       * operation. Otherwise it will.
       * @public
       */

    }, {
      key: "removeGroup",
      value: function removeGroup(group, removeChildren, doNotFireEvent) {
        var info = this.getObjectInfo(group);

        if (info && info.obj) {
          var vgroup = info.obj;
          this.openTransaction(APPEND_TO_CURRENT);
          var g = this.graph.deleteGroup(vgroup, removeChildren);

          if (g.group) {
            this._notifyGroupRemoved(g, removeChildren, doNotFireEvent);
          }

          this.commitTransaction();
        }
      }
      /**
       * Gets the Node with the given id.
       * @param nodeId
       * @public
       */

    }, {
      key: "getNode",
      value: function getNode(nodeId) {
        return this.graph.getVertex(nodeId);
      }
      /**
       * Gets an Edge by id, or if the given object is already an Edge, hands that back.
       * @param edgeId ID of the Edge to retrieve.
       * @returns The requested Edge, if found, otherwise null.
       * @public
       */

    }, {
      key: "getEdge",
      value: function getEdge(edgeId) {
        return this.graph.getEdge(edgeId);
      }
      /**
       * Gets a Group by its ID, or if the object is already a Group, hands that back.
       * @param groupId
       * @returns The requested Group, if found, otherwise null.
       * @public
       */

    }, {
      key: "getGroup",
      value: function getGroup(groupId) {
        return this.graph.getGroup(groupId);
      }
      /**
       * gets the Vertex with the given id.
       * @param id
       * @public
       */

    }, {
      key: "getVertex",
      value: function getVertex(id) {
        return this.getNode(id) || this.getGroup(id);
      }
      /**
       * Gets a port by its full id
       * @param portId ID of the Port to retrieve, in nodeId.portId syntax.
       * @returns The requested port, if found, otherwise null.
       * @public
       */

    }, {
      key: "getPort",
      value: function getPort(portId) {
        var vertex = this.graph.getVertexByPortId(portId);

        if (vertex) {
          return vertex.getPort(this.graph.splitPortId(portId)[1]);
        }
      }
      /**
       * Returns whether or not object(s) exist for the given id(s).
       * @param objects List of ids to check existence for.  This method takes an arbitrary number of arguments.
       * @returns True if objects exist for all given ids, false otherwise.
       * @public
       */

    }, {
      key: "exists",
      value: function exists() {
        for (var i = 0; i < arguments.length; i++) {
          if (this.graph.getVertex(i < 0 || arguments.length <= i ? undefined : arguments[i]) == null) return false;
        }

        return true;
      }
      /**
       * Removes the given Node, which may be passed in as the actual Node object, or its id.
       * @param node Either a Node, or its ID.
       * @returns The current Toolkit instance.
       * @public
       */

    }, {
      key: "removeNode",
      value: function removeNode(node, doNotFireEvent) {
        this.openTransaction(APPEND_TO_CURRENT);
        var vnode = this.graph.getVertex(node);
        var edges = vnode.getAllEdges() || [];

        for (var i = 0; i < edges.length; i++) {
          this.removeEdge(edges[i]);
        }

        vnode.group; // delete the vertex from the graph.

        var nodeDeletion = this.graph.deleteNode(vnode);

        this._notifyNodeRemoved(nodeDeletion, doNotFireEvent);

        this.commitTransaction();
        return this;
      }
      /**
       * Adds an Edge to the Graph.
       * @param params Options for the new edge
       * @param source The renderer that was the source of the action. Optional, used internally.
       * @param doNotFireEvent Optional. Won't fire an event if this is true. For internal use only.
       * @returns The Edge that was added.
       * @public
       */

    }, {
      key: "addEdge",
      value: function addEdge(params, source, doNotFireEvent) {
        var edge = this.graph.addEdge(params, this.edgeIdFunction, this.beforeConnect);

        if (edge != null) {
          if (!this.dataLoading && !this.doNotUpdateOriginalData) {
            manage(ManagedOperations.addEdge, this._originalData, this._originalDataType, edge, this.idFunction || this.graph.getIdFunction());
          }

          if (!doNotFireEvent) {
            this.fire(EVENT_EDGE_ADDED, {
              edge: edge,
              source: source,
              geometry: params.geometry,
              addedByMouse: params.addedByMouse
            }, null);
          }
        } else {
          if (this.debugEnabled) {
            log("Could not add edge");
          }
        }

        return edge;
      }
      /**
       * Notify registered managers of edge removal, and fire event. used by a couple of call sites.
       * @param edge
       * @param source
       * @internal
       */

    }, {
      key: "_notifyEdgeRemoved",
      value: function _notifyEdgeRemoved(edge, source) {
        // optionally, clean up the original backing data. requires that a DataManager for the current _originalDataType be registered
        // on jsPlumbToolkitIO
        if (!this.dataLoading && !this.doNotUpdateOriginalData) {
          manage(ManagedOperations.removeEdge, this._originalData, this._originalDataType, edge, this.idFunction || this.graph.getIdFunction());
        }

        this.fire(EVENT_EDGE_REMOVED, {
          edge: edge,
          source: source
        }, null);
      }
      /**
       * Removes an Edge from the Graph.
       * @param edge The Edge to remove, as either an Edge object or its id.
       * @param source The source for the removeEdge operation. For internal use.
       * @returns The current Toolkit instance.
       * @public
       */

    }, {
      key: "removeEdge",
      value: function removeEdge(edge, source) {
        var vedge = this.graph.getEdge(edge);

        if (vedge != null) {
          // delete the vertex from the graph.
          this.graph.deleteEdge(vedge);

          this._notifyEdgeRemoved(vedge, source);
        }

        return this;
      }
      /**
       * @internal
       * @param edge
       * @param obj
       * @param index
       */

    }, {
      key: "edgeMoved",
      value: function edgeMoved(edge, obj, index) {
        if (index === 0) {
          this.setSource(edge, obj);
        } else if (index === 1) {
          this.setTarget(edge, obj);
        }
      }
      /**
       * Sets the target for the given edge to be the given vertex.
       * @param edge Edge to set target for.
       * @param o ID of vertex, or vertex.
       * @public
       */

    }, {
      key: "setTarget",
      value: function setTarget(edge, o, doNotFireEvent) {
        var info = this.graph.setTarget(edge, o);

        if (info.success !== false && !doNotFireEvent) {
          this.fire(EVENT_EDGE_TARGET_CHANGED, info);
        }

        return info;
      }
      /**
       * Sets the source for the given edge to be the given vertex.
       * @param edge Edge to set source for.
       * @param o ID of vertex, or vertex.
       * @public
       */

    }, {
      key: "setSource",
      value: function setSource(edge, o, doNotFireEvent) {
        var info = this.graph.setSource(edge, o);

        if (info.success !== false && !doNotFireEvent) {
          this.fire(EVENT_EDGE_SOURCE_CHANGED, info);
        }

        return info;
      }
      /**
       * Adds a new Port to some Node. This will call the current `portFactory` to get the data for a new Port.
       * @param obj node/group or id of the node/group to add a new Port to.
       * @param type Type of Port to add.
       * @param portData Data to pass to the PortFactory.
       * @public
       */

    }, {
      key: "addNewPort",
      value: function addNewPort(obj, type, portData, doNotFireEvent) {
        var _this5 = this;

        var vobj = this.graph.getVertex(obj);
        this.portFactory({
          node: vobj,
          type: type
        }, portData, function (p) {
          var portId = _this5.portIdFunction(p),
              port = vobj.addPort(portId);

          port.data = p;

          _this5._updateVertexAfterPortChange(vobj, UPDATE_NODE_REASON_ADD_NEW_PORT);

          if (!_this5.dataLoading && !_this5.doNotUpdateOriginalData) {
            manage(ManagedOperations.addPort, _this5._originalData, _this5._originalDataType, {
              node: vobj,
              port: port
            }, _this5.idFunction || _this5.graph.getIdFunction());
          }

          if (!doNotFireEvent) {
            _this5.fire(EVENT_PORT_ADDED, {
              vertex: vobj,
              data: p,
              port: port
            }, null);
          }
        }, function () {// noop
        });
      }
      /**
       * Adds a Port from existing data to some Node/Group. This is distinct from `addNewPort`, because in this
       * case the data for the Port already exists.
       * @param vertex Node/Group or id of the Node/Group to add the Port to.
       * @param data Data for the Port.
       * @returns The port that was added.
       * @public
       */

    }, {
      key: "addPort",
      value: function addPort(vertex, data, doNotFireEvent) {
        var vnode = this.graph.getVertex(vertex);
        var p = vnode.addPort(data, this.portIdFunction);

        this._updateVertexAfterPortChange(vnode, UPDATE_NODE_REASON_ADD_PORT);

        if (!this.dataLoading && !this.doNotUpdateOriginalData) {
          manage(ManagedOperations.addPort, this._originalData, this._originalDataType, {
            node: vnode,
            port: p
          }, this.idFunction || this.graph.getIdFunction());
        }

        if (!doNotFireEvent) {
          this.fire(EVENT_PORT_ADDED, {
            vertex: vnode,
            data: data,
            port: p
          }, null);
        }

        return p;
      }
      /**
       * Removes a Port from the dataset.
       * @param vertexOrId If a string is passed in here, it may represent the full ID of some port, ie in "vertex.port" notation,
       * or it may be the ID of the vertex on which the port to be removed resides. If you do not pass a string to this argument you can pass a Port instead, or you can
       * pass the Node/Group on which the port resides (in which case you'll also need to provide a value for `portId`)
       * @param portId Id of the port to remove from the given node. Only required if you did not provide a full port ID, or the Port itself, to `vertexOrId`.
       * @returns True if the port existed and was removed, false otherwise.
       * @public
       */

    }, {
      key: "removePort",
      value: function removePort(vertexOrId, portId) {
        var vertex;

        if (typeof vertexOrId === "string") {
          var idComponents = this.graph.splitPortId(vertexOrId);

          if (idComponents.length === 2) {
            vertex = this.graph.getVertex(idComponents[0]);
            portId = idComponents[1];
          } else {
            vertex = this.graph.getVertex(vertexOrId);
          }
        } else {
          if (isPort(vertexOrId)) {
            portId = vertexOrId.id;
            vertex = vertexOrId.getParent();
          } else {
            vertex = this.graph.getVertex(vertexOrId);
          }
        }

        if (vertex != null && portId != null) {
          var port = vertex.getPort(portId);

          if (port) {
            var edges = port.getAllEdges();

            for (var j = edges.length, i = 0; i < j; i++) {
              this.removeEdge(edges[0]);
            }

            vertex.removePort(port);

            this._updateVertexAfterPortChange(vertex, UPDATE_NODE_REASON_REMOVE_PORT);

            this.fire(EVENT_PORT_REMOVED, {
              vertex: vertex,
              port: port,
              edges: edges
            }, null);
            return true;
          }
        }

        return false;
      }
      /**
       * Attempts to identify the given argument as a model object, and, if successful, removes it.
       * @param obj A string representing the ID of some model object, or a model object of some type.
       * @public
       */

    }, {
      key: "remove",
      value: function remove(obj) {
        if (obj == null) return;
        var o = this.getObjectInfo(obj);
        this.setSuspendRendering(true);

        try {
          if (o.obj && (o.type === Node.objectType || o.type === Edge.objectType || o.type === Group.objectType)) {
            this["remove" + o.type](o.obj);
          } else {
            while (obj.getNodeCount() > 0) {
              this.removeNode(obj.getNodeAt(0));
            }

            while (obj.getEdgeCount() > 0) {
              this.removeEdge(obj.getEdgeAt(0));
            }

            while (obj.getGroupCount() > 0) {
              this.removeGroup(obj.getGroupAt(0));
            }
          }
        } finally {
          this.setSuspendRendering(false, true);
        }
      }
      /**
       * Suspends or re-enables rendering. This method simply round-robins all the registered renderers
       * and calls `setSuspendRendering` on each of them.
       * @param v True to suspend rendering, false to enable it.
       * @param thenRefresh Defaults to false. If true, a refresh will be called on all renderers after rendering is unsuspended.
       * @public
       */

    }, {
      key: "setSuspendRendering",
      value: function setSuspendRendering(v, thenRefresh) {
        for (var _r in this._renderersById) {
          this._renderersById[_r].setSuspendRendering(v, thenRefresh);
        }
      }
      /**
       * Suspends rendering and then runs the given function, unsuspending rendering afterwards and doing
       * a refresh. This method is just a convenience method that handles suspending
       * and subsequent enabling of rendering. You might use this if you're adding a whole load of Nodes or
       * Edges, or maybe you want to add a Node and one or more Edges before
       * the layout recomputes.
       * @param fn
       * @public
       */

    }, {
      key: "batch",
      value: function batch(fn) {
        this.setSuspendRendering(true);

        try {
          fn();
        } catch (e) {
          console.log("Error in transaction " + e);
        } finally {
          this.setSuspendRendering(false, true);
        }
      }
      /**
       * Updates the given Group, notifying any Renderers to do a redraw. If autoSave is set, this method
       * will cause the dataset to be saved.
       * @param group Either a Group, a Group id, or the backing data for a Group.
       * @param updates An object with path->value pairs. Path can be in dotted notation.
       * You do not actually have to supply this, although in most cases you will want to. But there are edge
       * cases in which you might simply wish to kick off a repaint.
       * @public
       */

    }, {
      key: "updateGroup",
      value: function updateGroup(group, updates) {
        this.updateVertex(group, updates);
      }
      /**
       * Updates the given Node, notifying any Renderers to do a redraw. If autoSave is set, this method
       * will cause the dataset to be saved.
       * @param node Either a Node, a Node id, or the backing data for a Node.
       * @param updates An object with path->value pairs. Path can be in dotted notation. You do not actually have to supply this, although in most cases you will want to. But there are edge cases in which you might simply wish to kick off a repaint.
       * @public
       */

    }, {
      key: "updateNode",
      value: function updateNode(node, updates) {
        this.updateVertex(node, updates);
      }
      /**
       * Updates the given Node/Group, notifying any Renderers to do a redraw. If autoSave is set, this method
       * will cause the dataset to be saved.
       * @param vertex Either a Node/Group, a Node/Group id, or the backing data for a Node/Group.
       * @param updates An object with path->value pairs. Path can be in dotted notation. You do not actually have to supply this, although in most cases you will want to. But there are edge cases in which you might simply wish to kick off a repaint.
       * @public
       */

    }, {
      key: "updateVertex",
      value: function updateVertex(vertex, updates) {
        var info = this.getObjectInfo(vertex);

        if (info.obj) {
          var _vertex = isPort(info.obj) ? info.obj.getParent() : info.obj;

          var eventName = _vertex.objectType === Node.objectType ? EVENT_NODE_UPDATED : EVENT_GROUP_UPDATED;

          this._updateVertex(info.obj, updates, eventName, function (o, originalData) {
            return {
              vertex: o,
              updates: updates || {},
              originalData: originalData
            };
          });
        }
      }
      /**
       * Updates the given Port, notifying any Renderers to do a redraw. If autoSave is set, this method
       * will cause the dataset to be saved.
       * @param port Either a Port, a Port id, or the backing data for a Port.
       * @param updates An object with path->value pairs. Path can be in dotted notation. You do not actually have to supply this, although in most cases you will want to. But there are edge cases in which you might simply wish to kick off a repaint.
       * @public
       */

    }, {
      key: "updatePort",
      value: function updatePort(port, updates) {
        var info = this.getObjectInfo(port);

        if (info.obj) {
          this._updateVertex(info.obj, updates, EVENT_PORT_UPDATED, function (o, originalData) {
            return {
              port: o,
              vertex: o.getParent(),
              updates: updates || {},
              originalData: originalData
            };
          });
        }
      }
      /**
       * Updates the given Edge, notifying any Renderers to do a redraw. If autoSave is set, this method
       * will cause the dataset to be saved.
       * @param obj Either an Edge, an Edge id, or the backing data for an Edge.
       * @param updates An object with path->value pairs. Path can be in dotted notation. You do not actually have to supply this, although in most cases you will want to. But there are edge cases in which you might simply wish to kick off a repaint.
       * @public
       */

    }, {
      key: "updateEdge",
      value: function updateEdge(obj, updates) {
        var edge = typeof obj === "string" ? this.graph.getEdge(obj) : obj;

        if (edge != null) {
          var originalData = extend({}, edge.data);

          if (updates) {
            for (var u in updates) {
              if (edge.data[u] == null) edge.data[u] = updates[u];else replace(edge.data, u, updates[u]);
            }
          }

          this.fire(EVENT_EDGE_UPDATED, {
            edge: edge,
            updates: updates || {},
            originalData: originalData
          }, null);
        }
      }
      /**
       * Updates the given object, notifying any renderers to do a repaint.
       * @param object Either a Node, Group, Port or Edge, or, as a string, the id of some Node, Group, Port or Edge.
       * @param updates An object with path->value pairs. Path can be in dotted notation. You do not actually have to supply this, although in most cases you will want to. But there are edge cases in which you might simply wish to kick off a repaint.
       * @public
       */

    }, {
      key: "update",
      value: function update(object, updates) {
        if (isNode(object) || isGroup(object)) {
          this.updateVertex(object, updates);
        } else if (isEdge(object)) {
          this.updateEdge(object, updates);
        } else if (isPort(object)) {
          this.updatePort(object, updates);
        }
      }
      /**
       * Sets the geometry for the given edge. The type of `geometry` depends on the connector being used to represent the edge in the UI.
       * @param edge The edge to update.
       * @param geometry New geometry for the given edge.
       * @param renderer The renderer that instigated this change.
       * @internal
       */

    }, {
      key: "setEdgeGeometry",
      value: function setEdgeGeometry(edge, geometry, renderer) {
        var originalGeometry = clone(edge.geometry);
        edge.geometry = geometry;
        this.fire(EVENT_EDGE_PATH_EDITED, {
          edge: edge,
          geometry: geometry,
          originalGeometry: originalGeometry,
          renderer: renderer
        });
        this.fire(EVENT_DATA_UPDATED);
      }
      /**
       * Gets a Path from some source vertex to some target vertex.
       * @param params Path spec params
       * @public
       */

    }, {
      key: "getPath",
      value: function getPath(params) {
        return new Path(this, params);
      }
      /**
       * Finds the object that matches the given spec.
       * @param spec If a string, a Node/Port matching that id is retrieved. Otherwise if `spec` is already a Graph object (Node or Port), it is
       * returned.
       * @public
       */

    }, {
      key: "findGraphObject",
      value: function findGraphObject(spec) {
        if (spec == null) {
          return null;
        }

        if (spec === "*") {
          return this.graph;
        } else if (spec.constructor === Node || spec.constructor === Port || spec.constructor === Group) {
          return spec;
        } else if (spec.constructor === Edge) {
          return spec;
        } else if (isString(spec) || isObject(spec)) {
          return this.graph.getVertex(spec);
        }

        return null;
      }
      /**
       *
       * @param obj
       * @param append
       * @param _selection
       * @param fireSelectEvent
       * @internal
       */

    }, {
      key: "_select",
      value: function _select(obj, append, _selection, fireSelectEvent) {
        var _this6 = this;

        if (!append) {
          _selection.clear();
        }

        return _selection.append(obj, function (o) {
          if (fireSelectEvent) {
            _this6.fire(EVENT_SELECT, {
              append: append,
              obj: o,
              selection: _selection
            });
          }
        });
      }
      /**
       *
       * @param params Options for the edge selection.
       * @param edgeSelector
       * @param checkForPorts
       * @internal
       */

    }, {
      key: "_selectEdges",
      value: function _selectEdges(params, edgeSelector, checkForPorts) {
        var _this7 = this;

        params = params || {};

        var edges = [],
            edgeMap = {},
            _add = function _add(edge) {
          if (!edgeMap[edge.getId()]) {
            edges.push(edge);
            edgeMap[edge.getId()] = true;
          }
        },
            _addEdges = function _addEdges(obj, matchSource, matchTarget, matchElement) {
          if (obj != null) {
            var _e = obj[edgeSelector]({
              filter: params.filter
            });

            for (var i = 0; i < _e.length; i++) {
              var isSource = matchSource && obj === _this7.graph || _e[i].source === obj || checkForPorts && isPort(_e[i].source) && _e[i].source.getParent() === obj,
                  isTarget = matchTarget && obj === _this7.graph || _e[i].target === obj || checkForPorts && isPort(_e[i].target) && _e[i].target.getParent() === obj;

              if (matchSource && isSource || matchTarget && isTarget || matchElement && (isSource || isTarget)) {
                _add(_e[i]);
              }
            }
          }
        };

        _addEdges(this.findGraphObject(params.source), true, false, false);

        _addEdges(this.findGraphObject(params.target), false, true, false);

        _addEdges(this.findGraphObject(params.element), false, false, true);

        return edges;
      }
      /**
       * Updates the given vertex with the given data. For internal use.
       * @param obj
       * @param updates
       * @param evtId
       * @param generator
       * @internal
       */

    }, {
      key: "_updateVertex",
      value: function _updateVertex(obj, updates, evtId, generator) {
        if (obj && obj.objectType) {
          var originalData = extend({}, obj.data),
              originalId = obj.objectType === Port.objectType ? obj.getFullId() : obj.id,
              originalPortId = obj.objectType === Port.objectType ? this.portIdFunction(originalData) : null,
              newPortId;

          if (updates) {
            for (var u in updates) {
              replace(obj.data, u, updates[u]);
            }

            if (obj.objectType === Port.objectType) {
              // if the id of the port has changed, we need to rename it in the model,
              // and fire an event.
              newPortId = this.portIdFunction(obj.data);

              if (newPortId !== obj.id) {
                this.graph.renamePort(obj, newPortId);
              }

              this._updateVertexAfterPortChange(obj.getParent(), UPDATE_NODE_REASON_UPDATE_PORT);
            }
          }

          var payload = generator(obj, originalData);
          payload.originalId = originalId;

          if (originalPortId != null) {
            payload.originalPortId = originalPortId;
          }

          this.fire(evtId, payload, null);
        }
      }
      /**
       * After a change to a port, perhaps set the backing data for the associated node per the client app's portUpdater function. For internal use.
       * @param nodeOrGroup
       * @param reason
       * @internal
       */

    }, {
      key: "_updateVertexAfterPortChange",
      value: function _updateVertexAfterPortChange(nodeOrGroup, reason) {
        if (this.portUpdater != null) {
          var newData = this.portUpdater(nodeOrGroup.data, nodeOrGroup, nodeOrGroup.getPorts());

          if (newData != null) {
            nodeOrGroup.data = newData;

            if (!this.dataLoading) {
              var eventName = isGroup(nodeOrGroup) ? EVENT_GROUP_UPDATED : EVENT_NODE_UPDATED;
              this.fire(eventName, {
                vertex: nodeOrGroup,
                updates: {},
                originalData: nodeOrGroup.data,
                reason: reason
              });
            }
          }
        }
      }
      /**
       * Gets a set of edges.
       * @param params Options for the edge selection
       * @public
       */

    }, {
      key: "getEdges",
      value: function getEdges(params) {
        return this._selectEdges(params, "getEdges", false);
      }
      /**
       * Get all Edges in the Toolkit instance.
       * @public
       */

    }, {
      key: "getAllEdges",
      value: function getAllEdges() {
        return this.graph.getAllEdges();
      }
      /**
       * Gets all edges for the given Node, Port or Group.
       * @param obj Object to retrieve edges for.
       * @param filter Optional filter function for edge selection.
       * @public
       */

    }, {
      key: "getAllEdgesFor",
      value: function getAllEdgesFor(obj, filter) {
        return obj.getAllEdges({
          filter: filter
        });
      }
      /**
       * Gets all edges in the Toolkit instance as a Selection object.
       * @public
       */

    }, {
      key: "selectAllEdges",
      value: function selectAllEdges() {
        return this.filter(isEdge);
      }
      /**
       * Adds all the Edges in the Toolkit instance to the Toolkit's current selection.
       * @public
       */

    }, {
      key: "addAllEdgesToSelection",
      value: function addAllEdgesToSelection() {
        this.addToSelection(this.getAllEdges());
      }
      /**
       * Sets obj as the current selection for this instance of the jsPlumb Toolkit.
       * @param obj Object to select. May be a Node/Edge/Group or an array of any
       * of these, or a Node/Group id, or a Path.
       * @public
       */

    }, {
      key: "setSelection",
      value: function setSelection(obj) {
        var o = this._resolveObjectForSelection(obj);

        this._select(o, false, this._currentSelection, true);
      }
      /**
       * Gets an ad-hoc selection
       * @param obj Object to select. May be a Node/Group/Port/Edge or an array of any one
       * of these, or a Vertex id, a Selection, or a Path.
       * @param includeEdges If true, include edges between vertices
       * @public
       */

    }, {
      key: "select",
      value: function select(obj, includeEdges) {
        var s = this._createSelection();

        var o = this._resolveObjectForSelection(obj);

        var objects = this._select(o, true, s);

        if (includeEdges) {
          for (var i = 0; i < objects[0].length; i++) {
            var so = objects[0][i];

            if (isNode(so || isGroup(so) || isPort(so))) {
              var ae = so.getAllEdges();

              for (var j = 0; j < ae.length; j++) {
                s.append(ae[j]);
              }
            }
          }
        }

        return s;
      }
      /**
       *
       * @param focus
       * @param selection
       * @param includeEdges
       * @param touched
       * @internal
       */

    }, {
      key: "_descendants",
      value: function _descendants(focus, selection, includeEdges, touched) {
        var edges = focus.getAllEdges();

        for (var i = 0, j = edges.length; i < j; i++) {
          if (edges[i].source === focus) {
            var t = edges[i].target,
                tid = t.getFullId();

            if (!touched[tid]) {
              selection.append(t);

              if (includeEdges) {
                selection.append(edges[i]);
              }

              touched[tid] = true;

              this._descendants(t, selection, includeEdges, touched);
            }
          }
        }
      }
      /**
       * Selects all descendants of some Node or Group, and, optionally, the Node/Group itself.
       * @param obj Node/Group, or ID of Node/Group, to select
       * @param includeFocus Whether or not to include the focus node/group in the returned dataset. Defaults to false.
       * @param includeEdges Whether or not to include edges in the returned dataset. Defaults to false.
       * @public
       */

    }, {
      key: "selectDescendants",
      value: function selectDescendants(obj, includeFocus, includeEdges) {
        var info = this.getObjectInfo(obj);

        var s = this._createSelection();

        if (info.obj && info.obj.objectType === Node.objectType) {
          if (includeFocus) {
            this._select(info.obj, true, s);
          }

          var touched = {};
          touched[info.obj.getFullId()] = true;

          this._descendants(info.obj, s, includeEdges, touched);
        }

        return s;
      }
      /**
       * @param obj
       * @internal
       */

    }, {
      key: "_resolveObjectForSelection",
      value: function _resolveObjectForSelection(obj) {
        var _this8 = this;

        if (obj instanceof Path) {
          return obj;
        } else if (obj instanceof Selection) {
          return obj;
        } else if (isString(obj)) {
          return this.getVertex(obj) || this.getEdge(obj);
        } else if (Array.isArray(obj)) {
          return map(obj, function (o) {
            return isString(o) ? _this8.getVertex(obj) || _this8.getEdge(obj) : o;
          });
        } else {
          return obj;
        }
      }
      /**
       * Appends `obj` to the current selection. If there is no current selection, `obj` becomes it.
       * @param obj Object to select. May be a Node/Group/Port/Edge or an array of any
       * of these, or a Vertex id, or a Path.
       * @public
       */

    }, {
      key: "addToSelection",
      value: function addToSelection(obj) {
        var objToAppend = this._resolveObjectForSelection(obj);

        if (objToAppend) {
          var objects = this._select(objToAppend, true, this._currentSelection, true);

          if (objects[1] != null) {
            this._adhocSel(EVENT_DESELECT, objects[1]);
          }

          if (objects[0] != null) {
            this._adhocSel(EVENT_SELECT, objects[0]);
          }
        }
      }
      /**
       * @internal
       * @param evt
       * @param objects
       */

    }, {
      key: "_adhocSel",
      value: function _adhocSel(evt, objects) {
        for (var i = 0; i < objects.length; i++) {
          this.fire(evt, {
            obj: objects[i],
            selection: this._currentSelection
          });
        }
      }
      /**
       * Toggles whether or not the given `obj` forms part of the current selection.
       * @param obj Object to select. May be a Node/Group/Port/Edge or an array of any
       * of these, or a Vertex id, or a Path.
       * @public
       */

    }, {
      key: "toggleSelection",
      value: function toggleSelection(obj) {
        var objToToggle = this._resolveObjectForSelection(obj);

        if (objToToggle) {
          var desel = [];

          var objects = this._currentSelection.toggle(objToToggle, function (o, wasAdded) {
            // seems we dont need to add to 'sel'
            if (!wasAdded) {
              desel.push(o);
            }
          });

          this._adhocSel(EVENT_DESELECT, objects[1]);

          this._adhocSel(EVENT_DESELECT, desel);

          this._adhocSel(EVENT_SELECT, objects[0]);
        }
      }
      /**
       * Removes obj from the current selection
       * @param obj Object to deselect. May be a Node/Edge/Group/Port or an array of any
       * of these, or a Vertex id, or a Path.
       * @public
       */

    }, {
      key: "removeFromSelection",
      value: function removeFromSelection(obj) {
        var _this9 = this;

        var objToRemove = this._resolveObjectForSelection(obj);

        if (objToRemove) {
          this._currentSelection.remove(objToRemove, function (o) {
            _this9.fire(EVENT_DESELECT, {
              obj: o,
              selection: _this9._currentSelection
            });
          });
        }
      }
      /**
       * Appends the Path from `source` to `target` to the current selection. If there is no current selection, `obj` becomes it.
       * If the Path does not exist, there is no selection.
       * @param params Path params
       * @param params.source ID of source, or source Node/Port
       * @param params.target ID of target, or target Node/Port
       * @public
       */

    }, {
      key: "addPathToSelection",
      value: function addPathToSelection(params) {
        this.addToSelection(this.getPath(params));
      }
      /**
       * Clears the current selection and fires a `selectionCleared` event.
       * @public
       */

    }, {
      key: "clearSelection",
      value: function clearSelection() {
        this._currentSelection.clear();
      }
      /**
       * Gets the current Selection for this Toolkit instance.
       * @returns Current Selection.
       * @public
       */

    }, {
      key: "getSelection",
      value: function getSelection() {
        return this._currentSelection;
      }
      /**
       * Sets the maximum number of nodes that may be selected at any one time. Default is Infinity.
       * @param maxNodes Max number of nodes allowed to be selected at once.
       * @public
       */

    }, {
      key: "setMaxSelectedNodes",
      value: function setMaxSelectedNodes(maxNodes) {
        this._currentSelection.setMaxNodes(maxNodes);
      }
      /**
       * Sets the maximum number of edges that may be selected at any one time. Default is Infinity.
       * @param maxEdges Max number of edges allowed to be selected at once.
       * @public
       */

    }, {
      key: "setMaxSelectedEdges",
      value: function setMaxSelectedEdges(maxEdges) {
        this._currentSelection.setMaxEdges(maxEdges);
      }
      /**
       * Sets The action taken when appending an edge or node that would
       * take the selection above its limit for that given type. Depends on the current `capacityPolicy`, which can be either
       * Selection.DISCARD_EXISTING (the default) or Selection.DISCARD_NEW.
       * @param policy One of `Selection.DISCARD_EXISTING` (which removes the 0th entry from the list before insertion of the new value) or `Selection.DISCARD_NEW`.
       * @public
       */

    }, {
      key: "setSelectionCapacityPolicy",
      value: function setSelectionCapacityPolicy(policy) {
        this._currentSelection.setCapacityPolicy(policy);
      } // ---------------------- import /export -------------------------------

      /**
       * @param endEvent
       * @internal
       */

    }, {
      key: "_notifyDataLoaded",
      value: function _notifyDataLoaded(endEvent) {
        this.setSuspendGraph(true);
        this.fire(endEvent);
        this.setSuspendGraph(false);
        this.dataLoading = false;
      }
      /**
       *
       * @param params
       * @param startEvent
       * @param endEvent
       * @internal
       */

    }, {
      key: "_doLoad",
      value: function _doLoad(params, startEvent, endEvent) {
        var _this10 = this;

        params = params || {};

        var type = params.type || "json",
            data = params.data,
            url = params.url,
            jsonp = params.jsonp,
            onload = params.onload,
            parameters = params.parameters || {},
            error = params.error || function (e) {};

        if (data == null && url == null) {
          throw new TypeError("You must supply either data or url to load.");
        }

        var _parse = function _parse(d) {
          _this10._originalData = d;
          _this10._originalDataType = type;
          _this10.dataLoading = true;

          _this10.fire(startEvent);

          parse(type, d, _this10, parameters);

          _this10._notifyDataLoaded(endEvent);

          if (onload) {
            onload(_this10, d);
          }

          _this10.fire(EVENT_GRAPH_CHANGED);
        }; // then, import the data.


        if (data) {
          _parse(data);
        } else if (url) {
          if (jsonp) {
            var sep = url.indexOf("?") === -1 ? "?" : "&";
            url = url + sep + "callback=?";
          }

          var dataType = type === "json" ? type : params.dataType;
          var headers = params.headers || {
            Accept: "application/json"
          };
          this.loadData({
            url: url,
            success: _parse,
            dataType: dataType,
            error: error,
            headers: headers
          });
        }

        return this;
      }
      /**
       * Loads some data, either via ajax, or directly from a JS object.
       * @param params Load options.
       * @returns The current instance of the Toolkit. If you provide data directly to this method you can then chain a load call with a subsequent `render`.
       * @public
       */

    }, {
      key: "load",
      value: function load(params) {
        return this._doLoad(params, EVENT_DATA_LOAD_START, EVENT_DATA_LOAD_END);
      }
      /**
       * Appends some data to the dataset, either via ajax, or directly from a JS object. The only difference
       * between this and `load` is the events that are fired during the loading process.
       * @param params Append parameters.
       * @returns The current instance of the Toolkit. If you provide data directly to this method you can then chain a load call with a subsequent `render`.
       * @public
       */

    }, {
      key: "append",
      value: function append(params) {
        return this._doLoad(params, EVENT_DATA_APPEND_START, EVENT_DATA_APPEND_END);
      }
      /**
       * Saves the current data via ajax POST to a given URL.
       * @param params Save parameters
       * @returns The current instance of the Toolkit. If you provide data directly to this method you can then chain a load call with a subsequent `render`.
       * @public
       */

    }, {
      key: "save",
      value: function save(params) {
        if (params == null) {
          throw new Error("JSPLUMB: save method requires at least URL parameter - no params given.");
        }

        if (params.url == null) {
          throw new Error("JSPLUMB: save method requires at least URL parameter");
        }

        var data = this.exportData(params);
        var headers = {
          "Content-Type": "application/json"
        };
        extend(headers, params.headers || {});
        this.loadData({
          url: params.url,
          type: "POST",
          data: data,
          success: params.success || function (r) {},
          error: params.error || function (e) {},
          headers: headers
        });
        return this;
      }
      /**
       * Method stub for subclasses to implement for loading data.
       */

    }, {
      key: "exportData",
      value:
      /**
       * Exports the current data to JSON.
       * @param params Export parameters
       * @returns JSON payload.
       * @public
       */
      function exportData$1(params) {
        params = params || {};
        return exportData(params.type || "json", this, params.parameters);
      }
      /**
       * Helper method to allow `JSON.stringify` to be called with an instance of the Toolkit as argument (JSON.stringify looks
       * for a `toJSON()` method on each object it is attempting to serialise). This method generates the same output as
       * calling `exportData()`.
       */

    }, {
      key: "toJSON",
      value: function toJSON() {
        return exportData("json", this, {});
      }
      /**
       * Gets a renderer by the `id` parameter supplied to the `render` call (which is by default null, and only renderers for which an `id` was supplied are retrievable via this method)
       * @param id ID of the renderer to retrieve.
       * @returns Either a Renderer that was registered against the given id, or null if none found.
       * @public
       */

    }, {
      key: "getRenderer",
      value: function getRenderer(id) {
        return this._renderersById.get(id);
      }
      /**
       * Gets all renderers registered on this instance of the jsPlumb Toolkit.
       * @returns A map of `id-> ToolkitRenderer` pairs.
       * @public
       */

    }, {
      key: "getRenderers",
      value: function getRenderers() {
        return this._renderersById;
      }
      /**
       * registers a renderer on the Toolkit instance. For internal use.
       * @param renderer
       * @param id
       * @internal
       */

    }, {
      key: "addRenderer",
      value: function addRenderer(renderer, id) {
        var _this11 = this;

        id = id || uuid();

        this._renderersById.set(id, renderer);

        renderer.id = id; // if rendering a selection, augment the renderer with the selection's reload method.
        // if (params.selection != null) {
        //     //(renderer as any).reload = params.selection.reload.bind(this);
        // }

        renderer.bind(EVENT_DESTROY, function (r) {
          _this11._renderersById["delete"](r.id);
        });
        this.fire(EVENT_RENDERER_ADDED, {
          renderer: renderer,
          id: id
        });
      }
      /**
       * Finds information related to the given object, which may be an existing Toolkit object, a Node/Group/Edge id, or the backing data for some object.
       * @param obj A Node/Group/Edge id, or Node, Port, Group or Edge
       * @returns A JS object containing `obj` (the Toolkit object), `id` (the Node/Port/Group/Edge ID), `type` ("Port", "Node", "Group", "Edge")
       * @public
       */

    }, {
      key: "getObjectInfo",
      value: function getObjectInfo(obj) {
        var out = {
          obj: null,
          type: null,
          id: null
        };

        if (obj != null) {
          if (typeof obj === "string") {
            obj = this.getNode(obj) || this.getGroup(obj) || this.getPort(obj) || this.getEdge(obj);
          } else if (_typeof(obj) === "object" && typeof obj.objectType === "undefined") {
            var id = this.idFunction(obj),
                edgeId = this.edgeIdFunction(obj);
            obj = this.getNode(id) || this.getGroup(id) || this.getEdge(edgeId);
          }

          if (obj != null) {
            // it's a toolkit object (in theory.)
            out.obj = obj;
          } else {
            return out;
          }

          if (out.obj != null) {
            out.id = out.obj.id;
            out.type = out.obj.objectType;
          }
        }

        return out;
      } // ------------- undo/redo -------------------

      /**
       * Undo the latest operation, if there is one. Otherwise does nothing.
       * @public
       */

    }, {
      key: "undo",
      value: function undo() {
        this.undoRedo && this.undoRedo.undo();
      }
      /**
       * Redo the latest operation that was undone, if there is one. Otherwise does nothing.
       * @public
       */

    }, {
      key: "redo",
      value: function redo() {
        this.undoRedo && this.undoRedo.redo();
      }
      /**
       * Opens a transaction and runs the given function within it, then commits the transaction. If your function returns
       * false (boolean false, not false-y), the transaction is rolled back instead of committed.
       * @param fn Function to run.
       * @param cleanupAction What to do if a transaction already exists.
       * @public
       */

    }, {
      key: "transaction",
      value: function transaction(fn, cleanupAction) {
        this.undoRedo && this.undoRedo.transaction(fn, cleanupAction);
      }
      /**
       * Opens a transaction.
       * @param cleanupAction What to do if a transaction already exists. If you supply nothing, or an inappropriate value, here and there is a current transaction, then
       * an Error is thrown.
       * @param cleanupAction action to perform if a transaction already exists
       * @public
       */

    }, {
      key: "openTransaction",
      value: function openTransaction(cleanupAction) {
        this.undoRedo && this.undoRedo.openTransaction(cleanupAction);
      }
      /**
       * Rolls back the current transaction, undoing any changes to the data model made in the transaction. If there is no current transaction this method does nothing.
       * @public
       */

    }, {
      key: "rollbackTransaction",
      value: function rollbackTransaction() {
        this.undoRedo && this.undoRedo.rollbackTransaction();
      }
      /**
       * Commits any changes made in the current transaction to the undo stack. If there is no current transaction this method does nothing.
       * @public
       */

    }, {
      key: "commitTransaction",
      value: function commitTransaction() {
        this.undoRedo && this.undoRedo.commitTransaction();
      }
      /**
       * Clears out the undo/redo stacks and discards (neither commits nor rolls back) any existing transaction.
       * @public
       */

    }, {
      key: "flushUndoRedo",
      value: function flushUndoRedo() {
        this.undoRedo && this.undoRedo.clear();
      }
    }]);

    return JsPlumbToolkit;
  }(OptimisticEventGenerator);

  function _classCallCheck$c(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$c(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$c(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$c(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$c(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty$b(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _inherits$7(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf$7(subClass, superClass);
  }

  function _getPrototypeOf$7(o) {
    _getPrototypeOf$7 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$7(o);
  }

  function _setPrototypeOf$7(o, p) {
    _setPrototypeOf$7 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$7(o, p);
  }

  function _isNativeReflectConstruct$7() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _assertThisInitialized$7(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn$7(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }

    return _assertThisInitialized$7(self);
  }

  function _createSuper$7(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$7();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf$7(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$7(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn$7(this, result);
    };
  }

  function _superPropBase$1(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf$7(object);
      if (object === null) break;
    }

    return object;
  }

  function _get$1(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get$1 = Reflect.get;
    } else {
      _get$1 = function _get(target, property, receiver) {
        var base = _superPropBase$1(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };
    }

    return _get$1(target, property, receiver || target);
  }

  function _slicedToArray$2(arr, i) {
    return _arrayWithHoles$2(arr) || _iterableToArrayLimit$2(arr, i) || _unsupportedIterableToArray$2(arr, i) || _nonIterableRest$2();
  }

  function _toConsumableArray$1(arr) {
    return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _unsupportedIterableToArray$2(arr) || _nonIterableSpread$1();
  }

  function _arrayWithoutHoles$1(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray$2(arr);
  }

  function _arrayWithHoles$2(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray$1(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }

  function _iterableToArrayLimit$2(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;

    var _s, _e;

    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray$2(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray$2(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen);
  }

  function _arrayLikeToArray$2(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread$1() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _nonIterableRest$2() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var decoratorMap = {};
  var Decorators = {
    get: function get(name, params, adapter, container) {
      //
      var c = decoratorMap[name];

      if (!c) {
        throw {
          message: "jsPlumb: unknown decorator type '" + name + "'"
        };
      } else {
        return new c(params, adapter, container);
      }
    },
    register: function register(name, dec) {
      decoratorMap[name] = dec;
    }
  };

  function deltaCurry(prop, amount, negate) {
    return function (e) {
      return e[prop] / amount * (negate ? -1 : 1);
    };
  }

  var deltaY = "deltaY",
      deltaX = "deltaX",
      wheelDeltaY = "wheelDeltaY",
      wheelDeltaX = "wheelDeltaX";

  function defaultFirefoxYProfile(e) {
    return -1 * (e.deltaY * (e.deltaMode === 1 ? 25 : 1)) / 120;
  }

  function defaultFirefoxXProfile(e) {
    return -1 * (e.deltaX * (e.deltaMode === 1 ? 25 : 1)) / 120;
  }

  var yProfiles = {
    "webkit": {
      "mac": deltaCurry(deltaY, 120),
      "win": deltaCurry(deltaY, 100)
    },
    "safari": deltaCurry(wheelDeltaY, 120, true),
    "firefox": {
      "mac": defaultFirefoxYProfile,
      "win": defaultFirefoxYProfile
    },
    "ie": function ie(e) {
      return e.wheelDelta / 120;
    },
    "default": function _default(e) {
      return e.deltaY || e.wheelDelta;
    }
  },
      xProfiles = {
    "webkit": {
      "mac": deltaCurry(deltaX, 120),
      "win": deltaCurry(deltaX, 100)
    },
    "safari": deltaCurry(wheelDeltaX, 120, true),
    "firefox": {
      "mac": defaultFirefoxXProfile,
      "win": defaultFirefoxXProfile
    },
    "ie": function ie(e) {
      return e.wheelDelta / 120;
    },
    "default": function _default(e) {
      return e.deltaX || e.wheelDelta;
    }
  },
      _navigator = typeof navigator !== "undefined",
      _os = _navigator ? /Mac/.test(navigator.userAgent) ? "mac" : "win" : "mac",
      // linux?
  _browser = _navigator ? navigator.userAgent.indexOf("Firefox") !== -1 ? "firefox" : /Chrome/.test(navigator.userAgent) ? "webkit" : /Safari/.test(navigator.userAgent) ? "safari" : /WebKit/.test(navigator.userAgent) ? "webkit" : /Trident/.test(navigator.userAgent) ? "ie" : "default" : "default",
      _yProfile = typeof yProfiles[_browser] === "function" ? yProfiles[_browser] : yProfiles[_browser][_os],
      _xProfile = typeof xProfiles[_browser] === "function" ? xProfiles[_browser] : xProfiles[_browser][_os],
      _distanceY = function _distanceY(evt) {
    return _yProfile(evt || event);
  },
      _distanceX = function _distanceX(evt) {
    return _xProfile(evt || event);
  },
      _wrap = function _wrap(callback, ignoreTouchWheelEvents, requireMetaKey) {
    var wl = function wl(e) {
      // Firefox posts wheel events for a single touch moving on an element. we may not want that;
      // so if the user set the flag, here we test for the existence of the mozInputSource member, and
      // if it is not 1 (mouse device) then we return.
      if (ignoreTouchWheelEvents && e.mozInputSource != null && e.mozInputSource !== 1) return;

      var dy = _distanceY(e),
          dx = _distanceX(e);

      e.normalizedWheelDelta = dy;

      if (!requireMetaKey || e.metaKey || e.ctrlKey) {
        callback(e, dx, dy, e.metaKey || e.ctrlKey);
      }
    };

    callback._jtkwl = wl;
    return wl;
  },
      supportedEvent = "onwheel" in document.createElement("div") ? "wheel" : // Modern browsers support "wheel"
  document.onmousewheel !== undefined ? "mousewheel" : // Webkit and IE support at least "mousewheel"
  "DOMMouseScroll";

  function addWheelListener(el, callback, ignoreTouchWheelEvents, requireMetaKey) {
    var _cb = _wrap(callback, ignoreTouchWheelEvents, requireMetaKey);

    if (el.addEventListener) {
      el.addEventListener(supportedEvent, _cb, false); // Chrome/Safari/Opera
    } else if (el.attachEvent) {
      el.attachEvent('onmousewheel', _cb); // IE
    }

    return _cb;
  }
  function removeWheelListener(el, callback) {
    var wl = callback._jtkwl;

    if (wl != null) {
      if (el.removeEventListener) {
        el.removeEventListener(supportedEvent, wl, false); // Chrome/Safari/Opera
      } else if (el.detachEvent) {
        el.detachEvent('onmousewheel', wl); // IE
      }
    }
  }

  var EVENT_AFTER_LAYOUT_REFRESH = "afterLayoutRefresh";
  var EVENT_CANVAS_CLICK = "canvasClick";
  var EVENT_CANVAS_DBL_CLICK = "canvasDblClick";
  var EVENT_GROUP_RESIZE = "group:resize";
  var EVENT_GROUP_RELAYOUT = "group:relayout";
  var EVENT_LASSO_END = "lasso:end";
  var EVENT_NODE_VISIBILITY = "node:visibility";
  var EVENT_NODE_RENDERED = "node:render";
  var EVENT_OBJECT_REPAINTED = "objectRepainted";
  var EVENT_PAN = "pan";
  var EVENT_RELAYOUT = "relayout";
  var EVENT_RESIZE = "resize";
  var EVENT_ROTATE = "rotate";
  var EVENT_SURFACE_MODE_CHANGED = "modeChanged";
  var EVENT_STATE_RESTORED = "state:restore"; // ---------------------- ATTRIBUTES ---------------------------------------------------------

  var ATTRIBUTE_OFFSET_X = "data-jtk-offset-x";
  var ATTRIBUTE_OFFSET_Y = "data-jtk-offset-y";
  var ATTRIBUTE_ANCHOR_X = "data-jtk-anchor-x";
  var ATTRIBUTE_ANCHOR_Y = "data-jtk-anchor-y";
  var ATTRIBUTE_ORIENTATION_X = "data-jtk-orientation-x";
  var ATTRIBUTE_ORIENTATION_Y = "data-jtk-orientation-y";
  var ATTRIBUTE_JTK_NODE_ID = "jtk-node-id";
  var ATTRIBUTE_MINIVIEW_TYPE = "jtk-miniview-type";
  /**
   * Used to indicate that the given element is the place to which connections for the given port should be attached in the UI.
   * Don't confuse this with ATTRIBUTE_JTK_PORT_ID.
   */

  var ATTRIBUTE_JTK_PORT = "data-jtk-port";
  /**
   * Used to indicate what the port id should be for connections from/to this element. It does not necessarily mean that the
   * connection will be attached to an element that has this attribute - it is possible to have 'logical' ports on some vertex,
   * whose edges appear in the UI attached to the vertex, rather than some element inside the vertex. If you want to specify
   * that some element is the place to which connections for a given port should be attached, use ATTRIBUTE_JTK_PORT (`data-jtk-port`)
   */

  var ATTRIBUTE_JTK_PORT_ID = "data-jtk-port-id";
  var ATTRIBUTE_JTK_PORT_TYPE = "data-jtk-port-type";
  var ATTRIBUTE_JTK_EDGE_TYPE = "data-jtk-edge-type";
  var ATTRIBUTE_JTK_SOURCE = "data-jtk-source";
  var ATTRIBUTE_JTK_TARGET = "data-jtk-target";
  var ATTRIBUTE_JTK_SOURCE_PORT_ID = "data-jtk-source-port-id";
  var ATTRIBUTE_JTK_TARGET_PORT_ID = "data-jtk-target-port-id";
  var ATTRIBUTE_JTK_SOURCE_PORT = "data-jtk-source-port";
  var ATTRIBUTE_JTK_TARGET_PORT = "data-jtk-target-port";
  var ATTRIBUTE_JTK_SOURCE_PORT_TYPE = "data-jtk-source-port-type";
  var ATTRIBUTE_JTK_TARGET_PORT_TYPE = "data-jtk-target-port-type";
  var ATTRIBUTE_JTK_ENDPOINT = "data-jtk-endpoint";
  var ELEMENT_JTK_ENDPOINT = "jtk-endpoint"; // ------------------------------ CSS CLASSES -------------------------------------------

  var CLASS_SURFACE = "jtk-surface";
  var CLASS_SURFACE_DIRECT = "jtk-surface-direct-render";
  var CLASS_SURFACE_NO_PAN = "jtk-surface-nopan";
  var CLASS_SURFACE_CANVAS = "jtk-surface-canvas";
  var CLASS_SURFACE_SELECTED_ELEMENT = "jtk-surface-selected-element";
  var CLASS_SURFACE_SELECTED_CONNECTION = "jtk-surface-selected-connection";
  var CLASS_SURFACE_PANNING = "jtk-surface-panning";
  var CLASS_SURFACE_ELEMENT_DRAGGING = "jtk-surface-element-dragging"; //export const CLASS_SURFACE_DROPPABLE_NODE = "jtk-surface-droppable-node"

  var CLASS_LASSO = "jtk-lasso";
  var CLASS_LASSO_MASK = "jtk-lasso-mask";
  var CLASS_LASSO_MASK_LEFT = "jtk-lasso-mask-left";
  var CLASS_LASSO_MASK_TOP = "jtk-lasso-mask-top";
  var CLASS_LASSO_MASK_RIGHT = "jtk-lasso-mask-right";
  var CLASS_LASSO_MASK_BOTTOM = "jtk-lasso-mask-bottom";
  var CLASS_MINIVIEW = "jtk-miniview";
  var CLASS_MINIVIEW_CANVAS = "jtk-miniview-canvas";
  var CLASS_MINIVIEW_PANNER = "jtk-miniview-panner";
  var CLASS_MINIVIEW_ELEMENT = "jtk-miniview-element";
  var CLASS_MINIVIEW_GROUP_ELEMENT = "jtk-miniview-group-element";
  var CLASS_MINIVIEW_PANNING = "jtk-miniview-panning";
  var CLASS_MINIVIEW_COLLAPSE = "jtk-miniview-collapse";
  var CLASS_MINIVIEW_COLLAPSED = "jtk-miniview-collapsed";
  var CLASS_MOST_RECENTLY_DRAGGED = "jtk-most-recently-dragged";
  var CLASS_DRAG_SELECT_DEFEAT = "jtk-drag-select-defeat";
  var CLASS_NODE = "jtk-node";
  var CLASS_PORT = "jtk-port";
  var CLASS_GROUP = "jtk-group";
  var CLASS_SELECT_DEFEAT = "jtk-drag-select-defeat";
  var Constants = {
    click: "click",
    start: "start",
    stop: "stop",
    "default": "default",
    drop: "drop",
    disabled: "disabled",
    pan: "pan",
    select: "select",
    drag: "drag",
    left: "left",
    right: "right",
    top: "top",
    bottom: "bottom",
    width: "width",
    height: "height",
    leftmin: "leftmin",
    leftmax: "leftmax",
    topmin: "topmin",
    topmax: "topmax",
    min: "min",
    max: "max",
    nominalSize: "50px",
    px: "px",
    onepx: "1px",
    nopx: "0px",
    em: "em",
    absolute: "absolute",
    relative: "relative",
    none: "none",
    block: "block",
    hidden: "hidden",
    div: "div",
    id: "id",
    plusEquals: "+=",
    minusEquals: "-=",
    dot: ".",
    transform: "transform",
    transformOrigin: "transform-origin",
    surfaceNodeDragScope: "surfaceNodeDrag",
    mistletoeLayoutType: "Mistletoe",
    surfaceType: "Surface",
    jtkStatePrefix: "jtk-state-",
    msgCannotSaveState: "Cannot save state",
    msgCannotRestoreState: "Cannot restore state"
  };

  var DATA_PREFIX = "data-";
  /**
   * Definition of some object that can extract values from something. For internal use.
   * @internal
   */

  /**
   * Support class for extracting attribute values from an element. For internal use.
   * @internal
   */
  var AttributeExtractor = /*#__PURE__*/function () {
    function AttributeExtractor(el) {
      _classCallCheck$c(this, AttributeExtractor);

      this.el = el;
    }

    _createClass$c(AttributeExtractor, [{
      key: "value",
      value: function value(name, _default) {
        var v = this.el.getAttribute(name);
        return v == null ? _default : v;
      }
    }, {
      key: "findDataValues",
      value: function findDataValues(portValues) {
        for (var n = 0; n < this.el.attributes.length; n++) {
          var att = this.el.attributes[n];

          if (att.name.indexOf(DATA_PREFIX) === 0) {
            portValues[att.value] = att.name.split("-")[1];
          }
        }
      }
    }]);

    return AttributeExtractor;
  }();
  /**
   * Support class for extracting values from an object. For internal use.
   * @internal
   */

  var ObjectValueExtractor = /*#__PURE__*/function () {
    function ObjectValueExtractor(obj, stripPrefix) {
      _classCallCheck$c(this, ObjectValueExtractor);

      this.obj = obj;

      _defineProperty$b(this, "stripPrefix", void 0);

      this.stripPrefix = stripPrefix || "";
    }

    _createClass$c(ObjectValueExtractor, [{
      key: "value",
      value: function value(name, _default) {
        var v = this.obj[name.replace(this.stripPrefix, "").replace(/(\-\w)/g, function (m) {
          return m[1].toUpperCase();
        })];
        return v == null ? _default : v;
      }
    }, {
      key: "findDataValues",
      value: function findDataValues(portValues) {
        for (var key in this.obj) {
          if (key.indexOf(DATA_PREFIX) === 0) {
            portValues[this.obj[key]] = key.split("-")[1];
          }
        }
      }
    }]);

    return ObjectValueExtractor;
  }();

  var Layer = /*#__PURE__*/function () {
    function Layer(background, params, zoom) {
      _classCallCheck$c(this, Layer);

      _defineProperty$b(this, "scaledImageSize", void 0);

      _defineProperty$b(this, "scaledImageSizeH", void 0);

      _defineProperty$b(this, "container", void 0);

      _defineProperty$b(this, "zoom", void 0);

      _defineProperty$b(this, "specs", void 0);

      _defineProperty$b(this, "url", void 0);

      _defineProperty$b(this, "urlGenerator", void 0);

      _defineProperty$b(this, "apparentZoom", void 0);

      _defineProperty$b(this, "xTiles", void 0);

      _defineProperty$b(this, "yTiles", void 0);

      _defineProperty$b(this, "_images", []);

      var iwh = Math.pow(2, params.options.maxZoom - zoom) * params.options.tileSize.w;
      var iwhh = Math.pow(2, params.options.maxZoom - zoom) * params.options.tileSize.h;
      this.scaledImageSize = iwh;
      this.scaledImageSizeH = iwhh;
      this.container = document.createElement("div");
      this.container.style.position = "relative";
      this.container.style.height = "100%";
      this.container.style.width = "100%";
      this.container.style.display = "none";
      params.canvas.appendChild(this.container);
      this.zoom = zoom;
      this.specs = background.getTileSpecs(zoom);
      this.url = params.url;
      this.urlGenerator = background.urlGenerator;
      this.apparentZoom = Math.min(this.specs[2], this.specs[3]);
      this.xTiles = this.specs[0];
      this.yTiles = this.specs[1];

      for (var i = 0; i < this.xTiles; i++) {
        this._images[i] = this._images[i] || [];

        for (var j = 0; j < this.yTiles; j++) {
          var img = document.createElement("img");
          img._tiledBg = true;
          img.className = "jtk-surface-tile";

          img.ondragstart = function () {
            return false;
          };

          this.container.appendChild(img);
          img.style.position = "absolute";
          img.style.opacity = 0;
          this._images[i][j] = [img, new Image(), false];
        }
      }
    }

    _createClass$c(Layer, [{
      key: "_url",
      value: function _url(z, x, y) {
        return this.url.replace("{z}", z + "").replace("{x}", x + "").replace("{y}", y + "");
      }
    }, {
      key: "_resolver",
      value: function _resolver(z, x, y) {
        if (this.urlGenerator == null) {
          return this._url(z, x, y);
        } else {
          return this.urlGenerator(z, x, y);
        }
      }
    }, {
      key: "setActive",
      value: function setActive(a) {
        this.container.style.display = a ? "block" : "none";
      } // initialize backing image store.

    }, {
      key: "_load",
      value: function _load(imgEl, img, x, y) {
        imgEl.style.left = x * this.scaledImageSize + "px";
        imgEl.style.top = y * this.scaledImageSizeH + "px";
        imgEl.style.width = this.scaledImageSize + "px";
        imgEl.style.height = this.scaledImageSizeH + "px";

        img.onload = function () {
          imgEl.setAttribute("src", img.src);
          imgEl.style.opacity = 1;
        };

        img.src = this._resolver(this.zoom, x, y);
      }
    }, {
      key: "ensureLoaded",
      value: function ensureLoaded(xo, yo, xf, yf) {
        for (var i = xo; i <= xf; i++) {
          for (var j = yo; j <= yf; j++) {
            if (this._images[i] != null && this._images[i][j] != null) {
              if (!this._images[i][j][2]) {
                this._load(this._images[i][j][0], this._images[i][j][1], i, j);

                this._images[i][j][2] = true;
              }
            }
          }
        }
      }
    }]);

    return Layer;
  }();

  var TiledBackground = /*#__PURE__*/function () {
    function TiledBackground(params) {
      _classCallCheck$c(this, TiledBackground);

      _defineProperty$b(this, "canvas", void 0);

      _defineProperty$b(this, "viewport", void 0);

      _defineProperty$b(this, "layers", []);

      _defineProperty$b(this, "currentLayer", void 0);

      _defineProperty$b(this, "widgetZoom", void 0);

      _defineProperty$b(this, "zoomWidget", void 0);

      _defineProperty$b(this, "getWidthOf", void 0);

      _defineProperty$b(this, "getHeightOf", void 0);

      _defineProperty$b(this, "width", void 0);

      _defineProperty$b(this, "height", void 0);

      _defineProperty$b(this, "tileSize", void 0);

      _defineProperty$b(this, "panDebounceTimeout", void 0);

      _defineProperty$b(this, "zoomDebounceTimeout", void 0);

      _defineProperty$b(this, "maxZoom", void 0);

      _defineProperty$b(this, "urlGenerator", void 0);

      _defineProperty$b(this, "_debounceUpdateZoom", void 0);

      _defineProperty$b(this, "_doEnsureVisibleTiles", void 0);

      if (params.options.maxZoom == null) throw new Error("Parameter `maxZoom` not set; cannot initialize TiledBackground");
      if (!params.options.tileSize) throw new Error("Parameter `tileSize not set; cannot initialize TiledBackground. It should be in the form {w:width, h:height}.");
      if (!params.options.width || !params.options.height) throw new Error("Parameters `width` and `height` must be set");
      this.canvas = params.canvas;
      this.viewport = params.viewport;
      this.urlGenerator = params.options.urlGenerator;

      for (var i = 0; i <= params.options.maxZoom; i++) {
        this.layers.push(new Layer(this, params, i));
      }

      this.width = params.options.width;
      this.height = params.options.height;
      this.maxZoom = params.options.maxZoom;
      this.panDebounceTimeout = params.options.panDebounceTimeout || 50;
      this.zoomDebounceTimeout = params.options.zoomDebounceTimeout || 120;
      this.canvas.style.width = this.width + "px";
      this.canvas.style.height = this.height + "px";
      this.zoomWidget = params.zoomWidget;
      this.getWidthOf = params.getWidth;
      this.getHeightOf = params.getHeight;
      this._debounceUpdateZoom = this.debounce(this._doUpdateZoom, this.zoomDebounceTimeout);
      this._doEnsureVisibleTiles = this.debounce(this._ensureVisibleTiles, this.panDebounceTimeout);
      this.setZoom(params.zoomWidget.getZoom(), true); // finally, execute the onBackgroundReady callback immediately, if it was provided, since there is
      // no specific time at which you can say the tiled layer is completely done.

      if (params.onBackgroundReady != null) {
        setTimeout(params.onBackgroundReady, 0);
      }
    } // maps the current widget zoom to a zoom layer from our set. Returns the layer index.


    _createClass$c(TiledBackground, [{
      key: "_mapZoomToLayer",
      value: function _mapZoomToLayer() {
        if (this.widgetZoom <= this.layers[0].apparentZoom) return 0;else if (this.widgetZoom >= this.layers[this.layers.length - 1].apparentZoom) return this.layers.length - 1;else {
          for (var i = this.layers.length - 1; i > 0; i--) {
            if (this.layers[i].apparentZoom >= this.widgetZoom && this.widgetZoom >= this.layers[i - 1].apparentZoom) {
              return i;
            }
          }
        }
      } //
      // calculates the current scale for the given layer, relative to the widget's zoom.
      // then performs a relayout of the images, resizing and repositioning as necessary
      //

    }, {
      key: "_calculateScale",
      value: function _calculateScale(layerIndex) {
        var l = this.layers[layerIndex];

        if (this.currentLayer != null && this.currentLayer !== l) {
          this.currentLayer.setActive(false);
        }

        l.setActive(true);
        this.currentLayer = l;
      } //
      // for currentLayer, ensures that all of the required tiles are loaded. This means calculating the overlap
      // between the viewport and the tile layer, taking into account the current origin of the canvas and the
      // zoom level (as well as, of course, the size of the viewport).
      //

    }, {
      key: "_ensureVisibleTiles",
      value: function _ensureVisibleTiles() {
        var loc = this.zoomWidget.getApparentCanvasLocation(),
            vw = this.getWidthOf(this.viewport),
            vh = this.getHeightOf(this.viewport),
            tileW = this.currentLayer.scaledImageSize * this.widgetZoom,
            tileH = this.currentLayer.scaledImageSizeH * this.widgetZoom,
            xo = loc.x < 0 ? Math.floor(-loc.x / tileW) : loc.x < vw ? 0 : null,
            yo = loc.y < 0 ? Math.floor(-loc.y / tileH) : loc.y < vh ? 0 : null,
            xf = Math.min(this.currentLayer.xTiles, Math.floor((vw - loc.x) / tileW)),
            yf = Math.min(this.currentLayer.yTiles, Math.floor((vh - loc.y) / tileH)); // if either axis outside of the viewport, exit.

        if (xo == null || yo == null) return;
        this.currentLayer.ensureLoaded(xo, yo, xf, yf);
      } // for testing.

    }, {
      key: "getCurrentLayer",
      value: function getCurrentLayer() {
        return this.currentLayer;
      }
    }, {
      key: "debounce",
      value: function debounce(fn, timeout) {
        timeout = timeout || 150;
        var _t = null;
        return function () {
          window.clearTimeout(_t);
          _t = window.setTimeout(fn, timeout);
        };
      }
    }, {
      key: "_doUpdateZoom",
      value: function _doUpdateZoom() {
        this._calculateScale(this._mapZoomToLayer());

        this._ensureVisibleTiles();
      }
    }, {
      key: "setZoom",
      value: function setZoom(z, doNotDebounce) {
        this.widgetZoom = z;
        doNotDebounce ? this._doUpdateZoom() : this._debounceUpdateZoom();
      }
    }, {
      key: "pan",
      value: function pan() {
        this._doEnsureVisibleTiles();
      }
    }, {
      key: "owns",
      value: function owns(el) {
        return el === this.canvas || el._tiledBg === true;
      }
    }, {
      key: "getHeight",
      value: function getHeight() {
        return this.height;
      }
    }, {
      key: "getWidth",
      value: function getWidth() {
        return this.width;
      }
    }]);

    return TiledBackground;
  }();

  var AbsoluteTiledBackground = /*#__PURE__*/function (_TiledBackground) {
    _inherits$7(AbsoluteTiledBackground, _TiledBackground);

    var _super = _createSuper$7(AbsoluteTiledBackground);

    function AbsoluteTiledBackground(params) {
      _classCallCheck$c(this, AbsoluteTiledBackground);

      return _super.call(this, params);
    }

    _createClass$c(AbsoluteTiledBackground, [{
      key: "getTileSpecs",
      value: function getTileSpecs(zoom) {
        var divisor = Math.pow(2, this.maxZoom - zoom); // how much to divide the dimensions by when calculating image dimensions

        var xTiles = Math.ceil(this.width / divisor / this.tileSize[0]),
            // tiles in x axis
        yTiles = Math.ceil(this.height / divisor / this.tileSize[1]); // tiles in y axis

        return [xTiles, yTiles, xTiles * this.tileSize[0] / this.width, yTiles * this.tileSize[1] / this.height];
      }
    }]);

    return AbsoluteTiledBackground;
  }(TiledBackground);

  var SimpleBackground = /*#__PURE__*/function () {
    function SimpleBackground(params) {
      var _this = this;

      _classCallCheck$c(this, SimpleBackground);

      _defineProperty$b(this, "canvas", void 0);

      _defineProperty$b(this, "onBackgroundReady", void 0);

      _defineProperty$b(this, "backgroundImage", void 0);

      this.canvas = params.canvas;

      this.onBackgroundReady = params.onBackgroundReady || function () {};

      this.backgroundImage = new Image();

      this.backgroundImage.onload = function () {
        _this.canvas.style.backgroundImage = "url('" + _this.backgroundImage.src + "')";
        _this.canvas.style.backgroundRepeat = "no-repeat";
        _this.canvas.style.width = _this.backgroundImage.width + "px";
        _this.canvas.style.height = _this.backgroundImage.height + "px";

        _this.onBackgroundReady(_this);
      };

      this.backgroundImage.src = params.img ? params.img.src : params.url;
    }

    _createClass$c(SimpleBackground, [{
      key: "owns",
      value: function owns(el) {
        return el === this.canvas;
      }
    }, {
      key: "getWidth",
      value: function getWidth() {
        return this.backgroundImage.width || 0;
      }
    }, {
      key: "getHeight",
      value: function getHeight() {
        return this.backgroundImage.height || 0;
      }
    }, {
      key: "setZoom",
      value: function setZoom(zoom, doNotDebounce) {}
    }, {
      key: "pan",
      value: function pan() {}
    }]);

    return SimpleBackground;
  }();

  var LogarithmicTiledBackground = /*#__PURE__*/function (_TiledBackground) {
    _inherits$7(LogarithmicTiledBackground, _TiledBackground);

    var _super = _createSuper$7(LogarithmicTiledBackground);

    function LogarithmicTiledBackground(params) {
      _classCallCheck$c(this, LogarithmicTiledBackground);

      return _super.call(this, params);
    }

    _createClass$c(LogarithmicTiledBackground, [{
      key: "getTileSpecs",
      value: function getTileSpecs(zoom) {
        var arx = this.width > this.height ? 1 : this.width / this.height,
            ary = this.height > this.width ? 1 : this.height / this.width;

        var _w = Math.pow(2, zoom + 1) * this.tileSize[0] * arx,
            _h = Math.pow(2, zoom + 1) * this.tileSize[1] * ary,
            _xTiles = Math.ceil(_w / this.tileSize[0]),
            _yTiles = Math.ceil(_h / this.tileSize[1]);

        return [_xTiles, _yTiles, _w / this.width, _h / this.height];
      }
    }]);

    return LogarithmicTiledBackground;
  }(TiledBackground);

  var FixLeft = "left";
  var FixTop = "top";
  var FixedLayer = /*#__PURE__*/function () {
    function FixedLayer(panZoom) {
      _classCallCheck$c(this, FixedLayer);

      this.panZoom = panZoom;

      _defineProperty$b(this, "fixedElements", {});
    }

    _createClass$c(FixedLayer, [{
      key: "_fixElements",
      value: function _fixElements(elId) {
        var _this = this;

        var acl;
        var zoom;

        for (var fe in this.fixedElements) {
          if (this.fixedElements.hasOwnProperty(fe)) {
            var _ret = function () {
              // lazy load this acl and cache it. if there are no elements in this layer it never asks the panzoom for its location
              acl = acl || _this.panZoom.getApparentCanvasLocation(); // same with zoom.

              zoom = zoom == null ? _this.panZoom.getZoom() : zoom;

              if (elId != null && elId !== fe) {
                return "continue";
              }

              var ce = _this.fixedElements[fe];

              var _one = function _one(prop, idx) {
                if (ce[prop]) {
                  if (acl[idx] / zoom + ce.pos[idx] < 0) {
                    ce.el.style[prop] = -(acl[idx] / zoom) + "px";
                  } else {
                    ce.el.style[prop] = ce.pos[idx] + "px";
                  }
                }
              };

              _one(FixLeft, 0);

              _one(FixTop, 1);
            }();

            if (_ret === "continue") continue;
          }
        }
      }
    }, {
      key: "pan",
      value: function pan() {
        this._fixElements();
      }
    }, {
      key: "append",
      value: function append(el, constraints, pos) {
        if (el == null) return;
        var _el = el;
        constraints = constraints || {};
        var elId = this.panZoom.idFunction(el);
        this.fixedElements[elId] = {
          el: _el,
          left: constraints.left,
          top: constraints.top,
          pos: pos
        };
        _el.style.position = "absolute";
        _el.style.left = pos.x + "px";
        _el.style.top = pos.y + "px";
        this.panZoom.canvasElement.appendChild(el);

        this._fixElements(elId);
      }
    }]);

    return FixedLayer;
  }();

  /**
   * Implementation of layout adapter that is the parent of the `CanvasLayoutAdapter` and `GroupLayoutAdapter`, providing
   * the functionality shared by those two classes.
   * @internal
   */
  var BaseSurfaceLayoutAdapter = /*#__PURE__*/function (_AbstractLayoutAdapte) {
    _inherits$7(BaseSurfaceLayoutAdapter, _AbstractLayoutAdapte);

    var _super = _createSuper$7(BaseSurfaceLayoutAdapter);

    function BaseSurfaceLayoutAdapter(surface) {
      var _this;

      _classCallCheck$c(this, BaseSurfaceLayoutAdapter);

      _this = _super.call(this);
      _this.surface = surface;
      return _this;
    }

    _createClass$c(BaseSurfaceLayoutAdapter, [{
      key: "getOffset",
      value: function getOffset(el) {
        return this.surface.getOffset(el);
      }
    }, {
      key: "getViewportPosition",
      value: function getViewportPosition(obj) {
        return this.surface._getViewportPosition(obj);
      }
    }, {
      key: "getViewportPositionById",
      value: function getViewportPositionById(id) {
        return this.surface._getViewportPositionById(id);
      }
    }, {
      key: "getSize",
      value: function getSize(el) {
        return this.surface.jsplumb.getSize(el);
      }
    }]);

    return BaseSurfaceLayoutAdapter;
  }(AbstractLayoutAdapter);

  /**
   * Implementation of layout adapter that operates on a Surface canvas. Vertices that are a member of a group are
   * filtered, and `getElements` returns the list of all nodes and groups in the model, of course with those that
   * are in a group having been filtered.
   * @internal
   */

  var CanvasLayoutAdapter = /*#__PURE__*/function (_BaseSurfaceLayoutAda) {
    _inherits$7(CanvasLayoutAdapter, _BaseSurfaceLayoutAda);

    var _super = _createSuper$7(CanvasLayoutAdapter);

    function CanvasLayoutAdapter(surface) {
      var _this;

      _classCallCheck$c(this, CanvasLayoutAdapter);

      _this = _super.call(this, surface);
      _this.surface = surface;
      return _this;
    }

    _createClass$c(CanvasLayoutAdapter, [{
      key: "filter",
      value: function filter(obj) {
        return obj.group == null;
      }
    }, {
      key: "getElements",
      value: function getElements() {
        var elements = this.surface.getNodes();
        Array.prototype.push.apply(elements, this.surface.getGroups());
        elements = elements.filter(function (n, i, a) {
          return n.group == null;
        });
        return elements;
      }
    }]);

    return CanvasLayoutAdapter;
  }(BaseSurfaceLayoutAdapter);

  /**
   * Layout adapter that operates on a single group. `getElements` returns member of this group. `filter` filters out
   * vertices that are not children of this group.
   *
   * TODO why exactly does `filter` have to exist here? If `getElements` only returns group members, what's the
   * filter for?
   *
   */

  var GroupLayoutAdapter = /*#__PURE__*/function (_BaseSurfaceLayoutAda) {
    _inherits$7(GroupLayoutAdapter, _BaseSurfaceLayoutAda);

    var _super = _createSuper$7(GroupLayoutAdapter);

    function GroupLayoutAdapter(group, surface) {
      var _this;

      _classCallCheck$c(this, GroupLayoutAdapter);

      _this = _super.call(this, surface);
      _this.group = group;
      _this.surface = surface;
      return _this;
    }

    _createClass$c(GroupLayoutAdapter, [{
      key: "getElements",
      value: function getElements() {
        return this.group.getMembers();
      }
    }, {
      key: "filter",
      value: function filter(obj) {
        return (isGroup(obj) || isNode(obj)) && obj.group == this.group;
      }
    }]);

    return GroupLayoutAdapter;
  }(BaseSurfaceLayoutAdapter);

  /**
   * Models the minimum and maximum values in an allowed zoom range.
   */

  /**
   * Axes in which the canvas can be panned - x, y, or both.
   */
  var PanAxes;
  /**
   * Axes in which the canvas can be panned - x, y, or both.
   */

  (function (PanAxes) {
    PanAxes["both"] = "both";
    PanAxes["x"] = "x";
    PanAxes["y"] = "y";
  })(PanAxes || (PanAxes = {}));

  var POINTER_DOWN = "pointerdown";
  var POINTER_MOVE = "pointermove";
  var POINTER_UP = "pointerup";
  var TOUCH_START = "touchstart";
  var TOUCH_MOVE = "touchmove";
  var TOUCH_END = "touchend"; //
  // calc distance between two points
  //

  function distance(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
  }

  var PinchListener = /*#__PURE__*/function () {
    function PinchListener(_params) {
      var _this = this;

      _classCallCheck$c(this, PinchListener);

      _defineProperty$b(this, "isPointerDevice", void 0);

      _defineProperty$b(this, "isTouchDevice", void 0);

      _defineProperty$b(this, "center", void 0);

      _defineProperty$b(this, "radius", void 0);

      _defineProperty$b(this, "startRadius", void 0);

      _defineProperty$b(this, "onPinchStart", void 0);

      _defineProperty$b(this, "onPinch", void 0);

      _defineProperty$b(this, "onPinchEnd", void 0);

      _defineProperty$b(this, "eventManager", void 0);

      _defineProperty$b(this, "listenerTypes", {
        "pointer": function pointer(params) {
          var anchorMap = {},
              anchors = [],
              downCount = 0,
              needsReset = false;

          var _compute = function _compute() {
            if (downCount === 2) {
              _this.center = {
                x: (anchors[1].p[0] + anchors[0].p[0]) / 2,
                y: (anchors[1].p[1] + anchors[0].p[1]) / 2
              };
              _this.radius = distance(anchors[1].p[0], anchors[1].p[1], anchors[0].p[0], anchors[0].p[1]);
            }
          };

          var _down = function _down(e) {
            // we ignore anything more than 2 anchors, or if a pointer was released and we are
            // awaiting reset.
            if (downCount >= 2 || needsReset) return;
            anchors[downCount] = {
              e: e,
              p: [e.pageX, e.pageY]
            };
            anchorMap["" + e.pointerId] = downCount;
            downCount++;

            _compute();

            if (downCount === 2) {
              _this.startRadius = _this.radius;

              _this._fire(_this.onPinchStart);
            }
          };

          var _up = function _up(e) {
            var idx = anchorMap["" + e.pointerId];

            if (idx != null) {
              delete anchorMap["" + e.pointerId];
              downCount--; // once a finger is removed, we bail until all fingers have been removed and we can start over.

              needsReset = downCount !== 0;

              _this._fireEnd();
            }
          };

          var _move = function _move(e) {
            if (needsReset || downCount !== 2) return;
            var idx = anchorMap[e.pointerId];

            if (idx != null) {
              anchors[idx].p = [e.pageX, e.pageY]; // update this pointer's position.

              _compute(); // recomputer and fire event.


              _this._fire(_this.onPinch);
            }
          };

          _this.bind(params.el, POINTER_DOWN, _down, {
            passive: false
          });

          _this.bind(document, POINTER_UP, _up, {
            passive: false
          });

          _this.bind(document, POINTER_MOVE, _move, {
            passive: false
          });
        },
        "touch": function touch(params) {
          // for ipad/android and chrome on touch devices.
          var _touches = function _touches(e) {
            return e.touches || [];
          }; //
          // extracts the touch with the given index from the list of touches
          //


          var _getTouch = function _getTouch(touches, idx) {
            return touches.item ? touches.item(idx) : touches[idx];
          }; //
          // calculates the distance between the first two touches in the list
          //


          var distanceBetweenTouches = function distanceBetweenTouches(touches) {
            var t1 = _getTouch(touches, 0),
                t2 = _getTouch(touches, 1);

            return distance(t1.pageX, t1.pageY, t2.pageX, t2.pageY);
          }; //
          // calculates the center point of the first two touches in the list.
          //


          var _center = function _center(touches) {
            var t1 = _getTouch(touches, 0),
                t2 = _getTouch(touches, 1);

            return {
              x: (t1.pageX + t2.pageX) / 2,
              y: (t1.pageY + t2.pageY) / 2
            };
          };

          var down = false;

          var _down = function _down(e) {
            var touches = _touches(e);

            if (touches.length === 2 && params.enableWheelZoom !== false) {
              _this.center = _center(touches);
              _this.radius = _this.startRadius = distanceBetweenTouches(touches);
              down = true;

              _this.bind(document, TOUCH_MOVE, _move);

              _this.bind(document, TOUCH_END, _up);

              consume(e);

              _this._fire(_this.onPinchStart);
            }
          };

          var _up = function _up(e) {
            down = false;
            consume(e);

            _this.unbind(document, TOUCH_MOVE, _move);

            _this.unbind(document, TOUCH_END, _up);

            _this._fireEnd();
          };

          var _move = function _move(e) {
            if (down) {
              var touches = _touches(e);

              if (touches.length === 2) {
                consume(e);
                _this.radius = distanceBetweenTouches(touches);
                _this.center = _center(touches);

                _this._fire(_this.onPinch);
              }
            }
          };

          _this.bind(params.el, TOUCH_START, _down);
        }
      });

      this.eventManager = new EventManager();
      this.isPointerDevice = "onpointerdown" in document.documentElement;
      this.isTouchDevice = "ontouchstart" in document.documentElement;
      this.center = {
        x: 0,
        y: 0
      };
      this.radius = 0;
      this.startRadius = 0;
      this.onPinch = _params.onPinch;
      this.onPinchStart = _params.onPinchStart;
      this.onPinchEnd = _params.onPinchEnd;

      if (this.isPointerDevice) {
        this.listenerTypes.pointer(_params);
      } else if (this.isTouchDevice) {
        this.listenerTypes.touch(_params);
      }
    }

    _createClass$c(PinchListener, [{
      key: "_fire",
      value: function _fire(handler) {
        handler(this.center, this.startRadius, this.radius, this.radius / this.startRadius);
      }
    }, {
      key: "_fireEnd",
      value: function _fireEnd() {
        this.onPinchEnd();
      }
    }, {
      key: "bind",
      value: function bind(el, evt, handler, options) {
        this.eventManager.on(el, evt, handler);
      }
    }, {
      key: "unbind",
      value: function unbind(el, evt, handler) {
        this.eventManager.off(el, evt, handler);
      }
    }, {
      key: "destroy",
      value: function destroy() {}
    }]);

    return PinchListener;
  }();

  var TRANSFORM_ORIGIN = "transformOrigin";
  var TRANSFORM = "transform";

  function devNull() {} // calculates the total scroll of all parents leading to the given element,
  // ignoring any scroll on the document body. this latter condition is
  // only because we know all clients of this method are using
  // page locations that the browser has already taken body
  // scroll into account for: it could be taken as an argument
  // into this method whether or not to ignore body scroll.
  // originally we took into account only the viewport's scroll, but it was discovered we need to be a little
  // more exhaustive in certain situations.


  function calculateCumulativeScroll(el) {
    var _el = el,
        l = 0,
        t = 0;

    while (_el != null && _el !== document.body) {
      if (!isNaN(_el.scrollLeft)) {
        l += _el.scrollLeft;
      }

      if (!isNaN(_el.scrollTop)) {
        t += _el.scrollTop;
      }

      _el = _el.parentNode;
    }

    return {
      x: l,
      y: t
    };
  }

  function calculateOffset(el) {
    var _el = el,
        l = 0,
        t = 0;

    while (_el != null && _el !== document.body) {
      l += _el.offsetLeft;
      t += _el.offsetTop;
      _el = _el.offsetParent;
    }

    return {
      x: l,
      y: t
    };
  }
  /**
   * Provides Pan/Zoom functionality. This component is not something with which users of the Toolkit are expected to
   * work directly (although in fact it is sufficiently decoupled from the Surface that it could serve as a stand-alone
   * widget for other use cases, which is something we've slated for future investigation). Each Surface widget is
   * backed by a ZoomWidget.
   * @internal
   */


  var PanZoom = /*#__PURE__*/function () {
    // the current zoom level
    // current transform origin values (as percentages)
    // whether or not we are currently panning
    // whether or not we are currently pinch zooming
    // whether or not we are currently zooming with right-click mouse
    // whether or not we are currently mouse wheel zooming
    // the pagex/pagey of either a mousedown or single touchstart, or the center point of a 2 touch touchstart
    // set on mouse down. avoids successive hits on the 'size' method, which causes a reflow.
    // set on mouse down. avoids successive hits on the 'size' method, which causes a reflow.
    // allowed range of zoom.
    // the zoom level when zooming began
    // the maximum distance in Y that a right-click and drag
    // zoom will respond to. this effectively sets the
    // sensitivity of zooming in that way
    // the distance between touches when zooming began
    // the location of the canvas when zooming or panning starts.
    // last x pos from a mouse move (reset to -1 on mousedown)
    // last y pos from a mouse move (reset to -1 on mousedown)
    function PanZoom(surface, params) {
      var _this = this;

      _classCallCheck$c(this, PanZoom);

      this.surface = surface;

      _defineProperty$b(this, "canvasElement", void 0);

      _defineProperty$b(this, "viewportElement", void 0);

      _defineProperty$b(this, "_doWheelZoom", void 0);

      _defineProperty$b(this, "eventManager", void 0);

      _defineProperty$b(this, "pinchListener", void 0);

      _defineProperty$b(this, "position", {
        x: 0,
        y: 0
      });

      _defineProperty$b(this, "zoom", void 0);

      _defineProperty$b(this, "transformOrigin", {
        x: 0,
        y: 0
      });

      _defineProperty$b(this, "panning", false);

      _defineProperty$b(this, "pinchZooming", false);

      _defineProperty$b(this, "zooming", false);

      _defineProperty$b(this, "zoomingWithWheel", false);

      _defineProperty$b(this, "downAt", void 0);

      _defineProperty$b(this, "_viewportElementSize", void 0);

      _defineProperty$b(this, "_canvasElementSize", void 0);

      _defineProperty$b(this, "zoomRange", void 0);

      _defineProperty$b(this, "zoomAtZoomStart", void 0);

      _defineProperty$b(this, "maximumZoomTravel", 150);

      _defineProperty$b(this, "distanceAtZoomStart", void 0);

      _defineProperty$b(this, "lastDistance", void 0);

      _defineProperty$b(this, "canvasAtPanStart", void 0);

      _defineProperty$b(this, "lastMouseX", -1);

      _defineProperty$b(this, "lastMouseY", -1);

      _defineProperty$b(this, "lastMovedAt", null);

      _defineProperty$b(this, "lastVelocity", 0);

      _defineProperty$b(this, "lastAcceleration", 0);

      _defineProperty$b(this, "onZoom", void 0);

      _defineProperty$b(this, "onMaybeZoom", void 0);

      _defineProperty$b(this, "onPan", void 0);

      _defineProperty$b(this, "onMouseDown", void 0);

      _defineProperty$b(this, "onMouseUp", void 0);

      _defineProperty$b(this, "onMouseMove", void 0);

      _defineProperty$b(this, "onSetTransformOrigin", void 0);

      _defineProperty$b(this, "clamp", void 0);

      _defineProperty$b(this, "clampZoom", void 0);

      _defineProperty$b(this, "panDistance", void 0);

      _defineProperty$b(this, "enablePan", void 0);

      _defineProperty$b(this, "directRender", void 0);

      _defineProperty$b(this, "enableWheelZoom", void 0);

      _defineProperty$b(this, "enableAnimation", void 0);

      _defineProperty$b(this, "wheelFilter", void 0);

      _defineProperty$b(this, "wheelZoomRequiresMetaKey", void 0);

      _defineProperty$b(this, "wheelDirection", void 0);

      _defineProperty$b(this, "wheelSensitivity", void 0);

      _defineProperty$b(this, "wheelPan", void 0);

      _defineProperty$b(this, "wheelPanAxis", void 0);

      _defineProperty$b(this, "background", void 0);

      _defineProperty$b(this, "fixedLayer", void 0);

      _defineProperty$b(this, "_mouseMove", void 0);

      _defineProperty$b(this, "_mouseMoveEnd", void 0);

      _defineProperty$b(this, "_mouseMoveReset", void 0);

      _defineProperty$b(this, "viewport", void 0);

      _defineProperty$b(this, "consumeRightClick", void 0);

      _defineProperty$b(this, "smartMinimumZoom", void 0);

      _defineProperty$b(this, "_renderingSuspended", void 0);

      _defineProperty$b(this, "idFunction", void 0);

      _defineProperty$b(this, "enabled", void 0);

      _defineProperty$b(this, "clampToBackground", void 0);

      _defineProperty$b(this, "clampToBackgroundExtents", void 0);

      _defineProperty$b(this, "filter", void 0);

      _defineProperty$b(this, "_suspendMap", {});

      _defineProperty$b(this, "handlers", _defineProperty$b({
        "start": function start(e, touches) {
          if (_this.pinchZooming) return;
          var target = e.srcElement || e.target;

          if (_this.enabled && (target === _this.canvasElement || target === _this.viewportElement || target._jtkDecoration || _this.background && _this.background.owns(target) || _this.filter(target, e) === true)) {
            _this.zoomingWithWheel = false;
            _this.lastMouseX = -1;
            _this.lastMouseY = -1;

            if (e.which === 3 && _this.enableWheelZoom !== false && (e.mozInputSource == null || e.mozInputSource === 1)) {
              _this.zooming = true;
              _this.downAt = pageLocation(e);
              _this._viewportElementSize = size(_this.viewportElement);
              _this._canvasElementSize = size(_this.canvasElement);

              _this._setTransformOriginToEvent(e);

              _this.canvasAtPanStart = extend({}, _this.position);
              _this.zoomAtZoomStart = _this.zoom;
            } else if (touches.length <= 1) {
              _this._viewportElementSize = size(_this.viewportElement);
              _this._canvasElementSize = size(_this.canvasElement);
              _this.panning = true;
              _this.downAt = pageLocation(e);
              _this.canvasAtPanStart = extend({}, _this.position);
              consume(e);
            }
          }

          _this.onMouseDown(e, _this);
        },
        "move": function move(e, touches) {
          var dx, dy, pl;
          _this.zoomingWithWheel = false;

          if (_this.pinchZooming) {
            return;
          }

          if (_this.zooming) {
            pl = pageLocation(e);
            dx = pl.x - _this.downAt.x;
            dy = pl.y - _this.downAt.y;

            _this._zoomBy(dx, dy, e);
          } else if (_this.panning && _this.enablePan && _this.downAt != null) {
            consume(e);
            pl = pageLocation(e);
            dx = pl.x - _this.downAt.x;
            dy = pl.y - _this.downAt.y;

            var clampedMovement = _this._setCanvasPosition({
              x: _this.canvasAtPanStart.x + dx,
              y: _this.canvasAtPanStart.y + dy,
              animate: false
            });

            _this.onPan(clampedMovement.x, clampedMovement.y, _this.zoom, _this.zoom, e);

            _this.background && _this.background.pan();

            _this.fixedLayer.pan();

            consume(e);
          }

          _this.onMouseMove(e, _this);
        },
        "end": function end(e, touches) {
          if (_this.pinchZooming) {
            return;
          }

          _this.zooming = false;
          _this.downAt = null;
          _this.panning = false;
          _this._viewportElementSize = null;
          _this._canvasElementSize = null;
          _this.zoomingWithWheel = false;

          _this.eventManager.off(document, EVENT_MOUSEMOVE, _this._mouseMove);

          _this.eventManager.off(document, EVENT_MOUSEUP, _this._mouseMoveEnd);

          _this.eventManager.on(document, EVENT_MOUSEMOVE, _this._mouseMoveReset);

          _this.onMouseUp(e, _this);
        }
      }, EVENT_CONTEXTMENU, function (e) {}));

      params.events = params.events || {};
      this.zoom = params.zoom || 1;
      this.zoomRange = params.zoomRange || [0.05, 3];
      this.fixedLayer = new FixedLayer(this);
      this.eventManager = new EventManager();
      this.viewport = params.viewport;
      this.canvasElement = params.canvasElement;

      this._setCanvasPosition({
        x: 0,
        y: 0,
        animate: false
      });

      this.viewportElement = params.viewportElement;
      this.idFunction = params.idFunction;
      this.onZoom = params.events.zoom || devNull;

      this.onMaybeZoom = params.events.maybeZoom || function () {
        return true;
      };

      this.onPan = params.events.pan || devNull;
      this.onMouseDown = params.events.mousedown || devNull;
      this.onMouseUp = params.events.mouseup || devNull;
      this.onMouseMove = params.events.mousemove || devNull;
      this.onSetTransformOrigin = params.events.transformOrigin || devNull;
      this.clamp = !(params.clamp === false);
      this.clampZoom = params.clampZoom !== false;
      this.panDistance = params.panDistance || 50;
      this.enablePan = params.enablePan !== false;
      this.directRender = params.directRender === true;
      this.enableAnimation = params.enableAnimation !== false;
      var wheelParams = params.wheel || {};
      this.enableWheelZoom = wheelParams.zoom !== false;

      this.wheelFilter = wheelParams.filter || function () {
        return true;
      };

      this.wheelZoomRequiresMetaKey = wheelParams.useMetaKey === true;
      this.wheelDirection = wheelParams.reverse === true ? -1 : 1;
      this.wheelSensitivity = this.wheelDirection * (wheelParams.sensitivity || 10);
      this.wheelPan = wheelParams.pan === true;
      this.wheelPanAxis = wheelParams.axis || PanAxes.both;
      this.consumeRightClick = params.consumeRightClick !== false;
      this.smartMinimumZoom = params.smartMinimumZoom;
      this._renderingSuspended = false;

      this._mouseMove = function (e) {
        this._call("move", e);
      }.bind(this);

      this._mouseMoveEnd = function (e) {
        this._call("end", e);
      }.bind(this);

      this._mouseMoveReset = function (e) {
        this.zoomingWithWheel = false;
      }.bind(this);

      this.enabled = !(params.enabled === false);
      this.clampToBackground = params.clampToBackground;
      this.clampToBackgroundExtents = params.clampToBackgroundExtents;

      this.filter = params.filter || function () {
        return false;
      };

      if (this.enableWheelZoom || this.wheelPan) {
        this._doWheelZoom = function (e, dx, dy, isMeta) {
          return _this.wheelPanOrZoom(e, dx, dy, isMeta);
        };

        addWheelListener(this.viewportElement, this._doWheelZoom, true, this.wheelZoomRequiresMetaKey);
      }

      this.pinchListener = new PinchListener({
        el: this.viewportElement,
        enableWheelZoom: this.enableWheelZoom,
        onPinch: function onPinch(center, startRadius, radius, ratio) {
          _this._zoom(ratio * _this.zoomAtZoomStart);

          var dx = center.x - _this.downAt.x,
              dy = center.y - _this.downAt.y;

          _this._setCanvasPosition({
            x: _this.canvasAtPanStart.x + dx,
            y: _this.canvasAtPanStart.y + dy,
            animate: false
          });
        },
        onPinchStart: function onPinchStart(center, startRadius) {
          _this.pinchZooming = true;
          _this.downAt = center;
          _this.distanceAtZoomStart = _this.lastDistance = startRadius;
          _this.zoomAtZoomStart = _this.zoom;

          _this._setTransformOriginToPoint(_this.downAt.x, _this.downAt.y);

          _this.canvasAtPanStart = extend({}, _this.position);
        },
        onPinchEnd: function onPinchEnd() {
          _this.pinchZooming = false;
          _this.downAt = null;
        }
      }); // force transform origin and scale

      this._zoom(this.zoom, null, false, false, true);

      this._writeTransformOrigin();

      if (params.background) {
        this.setBackground(params.background);
      } // bind start event. it is responsible for attaching move event and end event to the document


      this.eventManager.on(this.viewportElement, EVENT_MOUSEDOWN, function (e) {
        _this.start(e);
      });
      this.eventManager.on(document, EVENT_MOUSEMOVE, this._mouseMoveReset); //

      this.eventManager.on(this.viewportElement, EVENT_CONTEXTMENU, function (e) {
        _this._call(EVENT_CONTEXTMENU, e);
      });
    } // ------------------------ these are the variables/functions used to keep track of the content bounds --------------------


    _createClass$c(PanZoom, [{
      key: "_setCanvasPosition",
      value: function _setCanvasPosition(params) {
        this.position = this._clamp(params.x, params.y);

        if (this.enableAnimation && params.animate) {
          this._animateTransform(null, params.onComplete);
        } else {
          this._writeTransform();

          params.onComplete && params.onComplete(this.position);
        }

        return this.position;
      }
    }, {
      key: "_moveCanvas",
      value: function _moveCanvas(dx, dy, animate, onComplete) {
        var p = this.position;
        return this._setCanvasPosition({
          x: p.x + dx,
          y: p.y + dy,
          animate: animate,
          onComplete: onComplete
        });
      }
    }, {
      key: "_wheelPan",
      value: function _wheelPan(e, dx, dy, isMeta) {
        if (!isMeta) {
          this.pan(-dx * 100, -dy * 100);
        }
      }
    }, {
      key: "_wheelZoom",
      value: function _wheelZoom(e, dx, dy, isMeta) {
        this.zoomAtZoomStart = this.zoom;

        if (!this.zoomingWithWheel) {
          this._setTransformOriginToEvent(e);

          this.zoomingWithWheel = true;
        }

        this._zoomBy(0, e.normalizedWheelDelta * this.wheelSensitivity, e, true);
      }
    }, {
      key: "wheelPanOrZoom",
      value: function wheelPanOrZoom(e, dx, dy, isMeta) {
        if (this.wheelFilter(e)) {
          e.preventDefault && e.preventDefault();
          e.stopPropagation && e.stopPropagation();

          if (!this.wheelPan || isMeta) {
            this._wheelZoom(e, dx, dy, isMeta);
          } else {
            dx = this.wheelPanAxis === PanAxes.both || this.wheelPanAxis === PanAxes.x ? dx : 0;
            dy = this.wheelPanAxis === PanAxes.both || this.wheelPanAxis === PanAxes.y ? dy : 0;

            this._wheelPan(e, dx, dy, isMeta);
          }
        }
      }
      /**
       * Sets whether or not rendering is suspended, which for the moment means that when updateBounds is
       * called, the widget doesn't sort the bounds, since we know there will be more changes to the
       * positions and/or sizes of elements.
       * @param val True to suspend rendering, false to re-enable rendering. If an update was called during the
       * time that rendering was suspended, the positions are sorted once rendering is re-enabled.
       */

    }, {
      key: "setSuspendRendering",
      value: function setSuspendRendering(val) {
        this._renderingSuspended = val;
      } // ----------------------------- pan buttons ---------------------------------------------------------------
      // ----------------------------- /pan buttons --------------------------------------------------------------

    }, {
      key: "_cssAnimation",
      value: function _cssAnimation(keyframes, duration, onComplete) {
        var _this2 = this;

        this.canvasElement.animate(keyframes, {
          duration: duration || 250
        }).finished.then(function () {
          for (var _p in keyframes) {
            _this2.canvasElement.style[_p] = keyframes[_p];
          }

          if (onComplete) {
            onComplete(_this2.position);
          }
        });
      }
    }, {
      key: "_constructTransformProperty",
      value: function _constructTransformProperty() {
        return "scale(".concat(this.zoom, ") translateX(").concat(this.position.x / this.zoom, "px) translateY(").concat(this.position.y / this.zoom, "px)");
      }
    }, {
      key: "_writeTransform",
      value: function _writeTransform() {
        this.canvasElement.style[TRANSFORM] = this._constructTransformProperty();
      }
      /**
       * For browsers that support it, use an element animate to set the transform. For browsers that don't support it, just set the transform.
       * @param duration
       * @param onComplete
       * @internal
       */

    }, {
      key: "_animateTransform",
      value: function _animateTransform(duration, onComplete) {
        if (this.canvasElement.animate != null) {
          var frames = _defineProperty$b({}, TRANSFORM, this._constructTransformProperty());

          this._cssAnimation(frames, duration, onComplete);
        } else {
          this._writeTransform();
        }
      }
    }, {
      key: "_constructTransformOriginProperty",
      value: function _constructTransformOriginProperty() {
        return this.transformOrigin.x + "% " + this.transformOrigin.y + "%";
      } //
      // writes the current transform origin into the canvas' style.
      //

    }, {
      key: "_writeTransformOrigin",
      value: function _writeTransformOrigin() {
        this.canvasElement.style[TRANSFORM_ORIGIN] = this._constructTransformOriginProperty();
      }
    }, {
      key: "_animateTransformOrigin",
      value: function _animateTransformOrigin(duration, onComplete) {
        if (this.canvasElement.animate != null) {
          this._cssAnimation(_defineProperty$b({}, TRANSFORM_ORIGIN, this._constructTransformOriginProperty()), duration, onComplete);
        } else {
          this._writeTransformOrigin();
        }
      }
    }, {
      key: "_animateTransformAndOrigin",
      value: function _animateTransformAndOrigin(duration, onComplete) {
        var _this3 = this;

        if (this.canvasElement.animate != null) {
          var _this$canvasElement$a;

          var anim = this.canvasElement.animate((_this$canvasElement$a = {}, _defineProperty$b(_this$canvasElement$a, TRANSFORM_ORIGIN, this._constructTransformOriginProperty()), _defineProperty$b(_this$canvasElement$a, TRANSFORM, this._constructTransformProperty()), _this$canvasElement$a), {
            duration: duration || 250
          });

          if (onComplete) {
            anim.onfinish = function () {
              return onComplete(_this3.position);
            };
          }
        } else {
          this._writeTransformOrigin();

          this._writeTransform();
        }
      } //  document.

    }, {
      key: "_originHelper",
      value: function _originHelper(x, y) {
        var ml = this.fromPageLocation(x, y),
            s = this._canvasElementSize || size(this.canvasElement);
        return {
          w: s.w,
          h: s.h,
          xy: ml,
          xScale: ml.x / s.w,
          yScale: ml.y / s.h,
          o: {
            x: ml.x / s.w * 100,
            y: ml.y / s.h * 100
          }
        };
      }
    }, {
      key: "_setTransformHelper",
      value: function _setTransformHelper(xy, w, h, e) {
        var dx1,
            dy1,
            dx2,
            dy2,
            xloc = this.transformOrigin.x / 100 * w,
            yloc = this.transformOrigin.y / 100 * h; // first, store the location of the canvas top/left corner

        dx1 = -(xloc * (1 - this.zoom));
        dy1 = -(yloc * (1 - this.zoom)); // now set the new transform origin

        this.transformOrigin = xy; // and write it to the element

        this._writeTransformOrigin();

        xloc = this.transformOrigin.x / 100 * w;
        yloc = this.transformOrigin.y / 100 * h; // now get the new location of the canvas top/left corner

        dx2 = -(xloc * (1 - this.zoom));
        dy2 = -(yloc * (1 - this.zoom)); // and then adjust the canvas to account for the shift caused by changing the transform origin.

        var newPos = this._moveCanvas(dx2 - dx1, dy2 - dy1, false);

        this.onSetTransformOrigin && this.onSetTransformOrigin(this.transformOrigin, newPos);
      } //
      // sets the canvas's transform-origin to the given x,y, which is a page location.
      //
      //

    }, {
      key: "_setTransformOriginToPoint",
      value: function _setTransformOriginToPoint(x, y, e) {
        var d = this._originHelper(x, y);

        this._setTransformHelper(d.o, d.w, d.h, e);
      } //
      // changes the transformOrigin of the canvas to be the point on the canvas at which the
      // given event occurred, then shifts the canvas to account for this change (the user sees
      // no shift)
      //

    }, {
      key: "_setTransformOriginToEvent",
      value: function _setTransformOriginToEvent(e) {
        var pl = pageLocation(e);

        this._setTransformOriginToPoint(pl.x, pl.y, e);
      } //
      // changes the transformOrigin of the canvas to be the given x,y, which is a point on the canvas.
      //

    }, {
      key: "_setTransformOriginToCanvasPoint",
      value: function _setTransformOriginToCanvasPoint(x, y) {
        var s = this._canvasElementSize || size(this.canvasElement);

        this._setTransformHelper({
          x: x / s.w * 100,
          y: y / s.h * 100
        }, s.w, s.h);
      } //
      // sets the current zoom and adjusts the canvas appropriately.
      //

    }, {
      key: "_zoom",
      value: function _zoom(z, e, wheel, animate, dontFireEvent) {
        var _this4 = this;

        if (this.directRender) {
          return;
        }

        if (z == null || isNaN(z) || z < 0) return;
        var minZoom = this.zoomRange[0]; // clamp to range. smartMinimumZoom means that the lower zoom range refers to a proportion of
        // content bounds, not of the viewport. So a value of 0.8 would mean that the furthest we
        // would zoom out would be to the point that the visible content is 1.25 (1 / 0.8) times
        // smaller than the viewport.  DISABLED.

        if (this.smartMinimumZoom) {
          minZoom = 0.5;
          var smz = this.getBoundsInfo().z,
              zoomToContentRatio = z / smz;
          if (zoomToContentRatio < minZoom) z = smz * minZoom;
        } else {
          //standard behaviour is just that the minimum refers to a multiple of the viewport size.
          if (z < minZoom) {
            z = minZoom;
          }
        } //test maximum.


        if (z > this.zoomRange[1]) z = this.zoomRange[1]; // the zoom operation can be overridden. miniview uses this to detect a change in zoom
        // and change its related surface instead of zooming itself.

        var oldZoom = this.zoom;
        this.zoom = z; // if the user wishes to animate the zoom then we have to do some setup first: as with zooming via the mouse,
        // the first thing to do is ascertain what the transform origin should be, set it, and adjust the canvas so it does
        // not appear to have moved. When the user uses the wheel to zoom, the transform origin is the point on the canvas that
        // maps to the wheel event on the page. When the user zooms programmatically, the transform origin is the point on the
        // canvas that lies in the middle of the viewport.
        //
        // So that's what we need first: what is the canvas location corresponding to the center of the viewport in the DOM?

        var onComplete = function onComplete(p) {
          if (!dontFireEvent) {
            _this4.onZoom(0, 0, z, oldZoom, e, wheel);
          } // update tile layer


          if (_this4.background != null) {
            _this4.background.setZoom(z);
          }

          _this4.fixedLayer.pan(); // clamp the display


          if (_this4.clampZoom) {
            var elPos = _this4.position;

            var cPos = _this4._clamp(elPos.x, elPos.y);

            if (cPos.x != elPos.x || cPos.y != elPos.y) {
              _this4._setCanvasPosition({
                x: cPos.x,
                y: cPos.y,
                animate: false
              });
            }
          }
        };

        if (animate) {
          // set the transform origin to be the point at the current center of the viewport for a programmatic animated zoom.
          var vc = this.getViewportCenter();

          this._setTransformOriginToCanvasPoint(vc.x, vc.y);

          this.zoom = z;

          this._animateTransform(null, onComplete);
        } else {
          this.zoom = z;

          this._writeTransform();

          onComplete(this.position);
        }

        return this.zoom;
      } //
      // used for right-click zooming.  It takes the amount
      // of travel in the y direction, clamps it to some maximum, and then uses zoomWithMappedRange
      // to translate that into a new zoom value.
      //

    }, {
      key: "_zoomBy",
      value: function _zoomBy(dx, dy, e, wheel) {
        if (dy < -this.maximumZoomTravel) dy = -this.maximumZoomTravel;
        if (dy > this.maximumZoomTravel) dy = this.maximumZoomTravel;

        this._zoomWithMappedRange(this.zoomAtZoomStart, dy, -this.maximumZoomTravel, this.maximumZoomTravel, e, wheel);
      } //
      // sets zoom the some value with the current range, by calculating where in the range
      // the given 'value' sits.
      //

    }, {
      key: "_zoomWithMappedRange",
      value: function _zoomWithMappedRange(startZoom, value, low, high, e, wheel) {
        var p = value / (value >= 0 ? high : low),
            idx = value >= 0 ? 1 : 0,
            z = startZoom + p * (this.zoomRange[idx] - startZoom);

        this._zoom(z, e, wheel);
      } //
      // takes a desired x,y for the canvas origin and clamps the values such that at least
      // one managed element is visible. you can suppress this behaviour by setting
      // clamp:false in the constructor, or calling setClamp(false) on the widget.
      //

    }, {
      key: "_clamp",
      value: function _clamp(x, y, padding) {
        if (!this.clamp && !this.clampToBackground && !this.clampToBackgroundExtents) return {
          x: x,
          y: y
        };else {
          var vs = this._viewportElementSize || size(this.viewportElement);

          var ao = this._apparentOffset(),
              _x = x,
              _y = y,
              bi = this.clamp ? this.getBoundsInfo() : {
            x: 0,
            y: 0,
            w: 0,
            h: 0,
            vw: vs.w,
            vh: vs.h,
            padding: padding,
            z: 1
          };

          padding = (padding || 20) * this.zoom;

          if ((this.clampToBackground || this.clampToBackgroundExtents) && this.background != null) {
            var bw = this.background.getWidth(),
                bh = this.background.getHeight(),
                xmax = Math.max(bi.x + bi.w, bw),
                ymax = Math.max(bi.y + bi.h, bh);
            bi.w = xmax - bi.w;
            bi.h = ymax - bi.h;
            var zx = bi.vw / bi.w,
                zy = bi.vh / bi.h;
            bi.z = Math.min(zx, zy); // adjust padding so that the background image never leaves the corners

            if (this.clampToBackgroundExtents) padding = Math.max(bi.vw, bi.vh);
          }

          var boundsMax = [bi.x + bi.w, bi.y + bi.h];

          if (this.background) {
            boundsMax[0] = Math.max(boundsMax[0], this.background.getWidth());
            boundsMax[1] = Math.max(boundsMax[1], this.background.getHeight());
          }

          var dxmin = x + ao.x + boundsMax[0] * this.zoom - padding,
              dymin = y + ao.y + boundsMax[1] * this.zoom - padding,
              dxmax = x + ao.x + bi.x * this.zoom + padding,
              dymax = y + ao.y + bi.y * this.zoom + padding; // x min

          if (dxmin < 0) _x -= dxmin; // x max

          if (dxmax > bi.vw) _x -= dxmax - bi.vw; // y min

          if (dymin < 0) _y -= dymin; // x max

          if (dymax > bi.vh) _y -= dymax - bi.vh;
          return {
            x: _x,
            y: _y
          };
        }
      }
    }, {
      key: "_getPosition",
      value: function _getPosition(el) {
        var _el = el;
        return {
          x: parseInt(_el.style.left, 10) || 0,
          y: parseInt(_el.style.top, 10) || 0
        };
      } //
      // gets the apparent offset of the canvas, taking zoom and transform origin
      // into account. This is relative to the [0,0] point of the canvas's parent, and when
      // zoom != 1 this will vary from what the DOM itself will tell you. For instance say you
      // have these conditions:
      // left/top : 50, 50
      // w/h      : 400, 400
      // zoom     : 0.5
      // origin   : 50% 50%
      //
      // the canvas appears to be 200,200 in size, in this case centered around 50% 50%. so the
      // apparent offset from the reported left/top will be 100,100.
      //
      // you can see from this maths that a transform origin of 0% 0% will return [0,0] from
      // this method.
      //

    }, {
      key: "_apparentOffset",
      value: function _apparentOffset() {
        var s = this._canvasElementSize || size(this.canvasElement),
            xloc = this.transformOrigin.x / 100 * s.w,
            yloc = this.transformOrigin.y / 100 * s.h;
        return {
          x: xloc * (1 - this.zoom),
          y: yloc * (1 - this.zoom)
        };
      } // event handlers. these are the core of the functionality.

    }, {
      key: "_call",
      value: function _call(type, e) {
        if (type === EVENT_CONTEXTMENU && this.consumeRightClick) {
          e.preventDefault && e.preventDefault();
        }

        var t = touches(e);
        this.handlers[type](e, t);
      }
      /**
       * Programmatically report a down event in order to kick the widget into action.
       * @param e Mouse event to use to kick things off.
       */

    }, {
      key: "start",
      value: function start(e) {
        if (this.enabled && e != null) {
          this.eventManager.off(document, EVENT_MOUSEMOVE, this._mouseMoveReset);
          this.eventManager.on(document, EVENT_MOUSEMOVE, this._mouseMove);
          this.eventManager.on(document, EVENT_MOUSEUP, this._mouseMoveEnd);
          this.handlers["start"](e, touches(e));
        }
      }
      /**
       * Gets the current bounds for the pan zoom.
       * @param padding
       * @param paddingRatio
       */

    }, {
      key: "getBoundsInfo",
      value: function getBoundsInfo(padding, paddingRatio) {
        var viewportElementSize = this._viewportElementSize || size(this.viewportElement);

        if (this.viewport.isEmpty()) {
          return {
            w: 0,
            h: 0,
            x: 0,
            y: 0,
            vw: viewportElementSize.w,
            vh: viewportElementSize.h,
            padding: padding,
            z: 1,
            zoom: 1
          };
        }

        padding = padding || 0;
        paddingRatio = paddingRatio || 0.9;
        var boundsW = this.viewport.getBoundsWidth(),
            boundsH = this.viewport.getBoundsHeight(),
            zx = viewportElementSize.w / ((boundsW + padding * 2) / paddingRatio),
            zy = viewportElementSize.h / ((boundsH + padding * 2) / paddingRatio),
            z = Math.min(zx, zy);
        return {
          w: boundsW,
          h: boundsH,
          x: this.viewport.getX(),
          y: this.viewport.getY(),
          vw: viewportElementSize.w,
          vh: viewportElementSize.h,
          padding: padding,
          z: z,
          zoom: this.zoom
        };
      } // -------------------------   public API -------------------------------------------------------

    }, {
      key: "isPinchZooming",
      value: function isPinchZooming() {
        return this.pinchZooming;
      }
      /**
       * Adds the given element to those that this widget is tracking.
       * @param el - Element to begin tracking.
       * @param id - Optional id of the element. This might be called from a context in which
       * the id is known already, so we can save some work.
       * @param pos - Optional location for the node.  If not provided, the position will be retrieved from a call to the DOM.
       */

    }, {
      key: "add",
      value: function add(el, id, pos, isDecoration) {
        if (isDecoration) {
          //bind(el, downEvent, _start)
          el._jtkDecoration = true;
        }
      }
    }, {
      key: "suspend",
      value: function suspend(el) {
        var id = typeof el === "string" ? el : this.idFunction(el);
        this._suspendMap[id] = true;

        this._removeFromTracking(id);
      }
    }, {
      key: "isSuspended",
      value: function isSuspended(el) {
        var id = typeof el === "string" ? el : this.idFunction(el);
        return this._suspendMap[id] === true;
      }
    }, {
      key: "restore",
      value: function restore(el) {
        var id = typeof el === "string" ? el : this.idFunction(el);
        delete this._suspendMap[id];
      }
      /**
       * Removes the given element from the list this widget is tracking. Note that this widget does
       * not remove the element from the DOM.
       * @param Selector|Element el Element to stop tracking.
       */

    }, {
      key: "remove",
      value: function remove(el) {
        var id = this.idFunction(el);
        delete this._suspendMap[id];

        this._removeFromTracking(id);
      } //
      // used by both `remove` and `suspend`

    }, {
      key: "_removeFromTracking",
      value: function _removeFromTracking(id) {}
      /**
       * Removes all tracked elements and resets the widget.
       */

    }, {
      key: "reset",
      value: function reset() {
        this._suspendMap = {};

        this._setCanvasPosition({
          x: 0,
          y: 0,
          animate: false
        });
      }
      /**
       * Zooms the display so that all the tracked elements fit inside the viewport. This method will also,
       * by default, increase the zoom if necessary - meaning the default behaviour is to adjust the zoom so that
       * the content fills the viewport. You can suppress zoom increase by setting `doNotZoomIfVisible:true` on the
       * parameters to this method.
       * @param params.padding Optional padding to leave around all elements. Defaults to 0.
       * @param params.fill Amount of the viewport to fill. By default, this method will zoom so that the content is 0.9 times the size of the viewport.
       * Aesthetically this makes for a more pleasing result than filling the viewport entirely.
       * @param params.onComplete Optional function to call on operation complete (centering may be animated).
       * @param params.doNotAnimate By default, the centering content step does not use animation. This is due to this method being used most often to initially setup a UI.
       * @param params.doNotZoomIfVisible If true, no action is taken if the content is currently all visible.
       * @param params.doNotFirePanEvent If true, a pan event will not be fired.
       */

    }, {
      key: "zoomToFit",
      value: function zoomToFit(params) {
        params = params || {};
        var bi = this.getBoundsInfo(params.padding, params.fill);

        if (!(params.doNotZoomIfVisible && bi.z > this.zoom)) {
          this._zoom(bi.z);
        }

        this.centerContent({
          bounds: bi,
          doNotAnimate: params.doNotAnimate !== false,
          onComplete: params.onComplete,
          doNotFirePanEvent: params.doNotFirePanEvent
        });
      }
      /**
       * Zooms the display so that all the tracked elements fit inside the viewport, but does not make any adjustments
       * to zoom if all the elements are currently visible (it still does center the content though).
       * @param params.padding Optional padding to leave around all elements.
       * @param params.fill Amount of the viewport to fill. By default, this method will zoom so that the content is 0.9 times the size of the viewport.
       * Aesthetically this makes for a more pleasing result than filling the viewport entirely.
       * @param params.onComplete Optional function to call on operation complete (centering may be animated).
       * @param params.doNotAnimate By default, the centering content step does not use animation. This is due to this method being used most often to initially setup a UI.
       */

    }, {
      key: "zoomToFitIfNecessary",
      value: function zoomToFitIfNecessary(params) {
        var p = extend(params || {}, {});
        p.doNotZoomIfVisible = true;
        this.zoomToFit(p);
      }
      /**
       * Zooms the display so that all the given elements fit inside the viewport.
       * @param zParams.elements List of DOM elements to zoom to.
       * @param zParams.fill A decimal indicating how much of the viewport to fill with the zoomed content. Defaults to 0.90.
       * @param zParams.doNotZoomIfVisible If true and the widget determines the entire selection is already
       * visible, the zoom will not be adjusted.
       * @param zParams.doNotAnimate=true By default the widget does not animate this operation. You can override that behaviour by setting doNotAnimate:false.
       */

    }, {
      key: "zoomToElements",
      value: function zoomToElements(zParams) {
        var vs = size(this.viewportElement);
        var bi = {
          x: Infinity,
          y: Infinity,
          xMax: -Infinity,
          yMax: -Infinity,
          z: 1,
          vw: vs.w,
          vh: vs.h
        };

        for (var i = 0; i < zParams.elements.length; i++) {
          var _e = zParams.elements[i],
              _p2 = this.viewport.getPosition(this.idFunction(_e));

          if (_p2) {
            bi.x = Math.min(bi.x, _p2.x);
            bi.y = Math.min(bi.y, _p2.y);
            bi.xMax = Math.max(bi.xMax, _p2.x2);
            bi.yMax = Math.max(bi.yMax, _p2.y2);
          }
        }

        var fill = zParams.fill || 0.9;
        bi.w = bi.xMax - bi.x;
        bi.h = bi.yMax - bi.y;
        bi.z = fill * Math.min(bi.vw / bi.w, bi.vh / bi.h);

        if (!(zParams.doNotZoomIfVisible && bi.z > this.zoom)) {
          this._zoom(bi.z);
        }

        this.centerContent({
          bounds: bi,
          doNotAnimate: zParams.doNotAnimate !== false,
          onComplete: zParams.onComplete,
          doNotFirePanEvent: zParams.doNotFirePanEvent
        });
      }
      /**
       * Zooms the display so that the background fits inside the viewport.
       * @param params.onComplete Optional function to call on operation complete (centering may be animated).
       * @param params.doNotAnimate If true, centering content will not use animation.
       */

    }, {
      key: "zoomToBackground",
      value: function zoomToBackground(params) {
        params = params || {};

        if (this.background != null) {
          var boundsW = this.background.getWidth(),
              boundsH = this.background.getHeight(),
              viewportSize = size(this.viewportElement),
              zx = viewportSize.w / boundsW,
              zy = viewportSize.h / boundsH,
              z = Math.min(zx, zy),
              bi = {
            w: boundsW,
            h: boundsH,
            x: 0,
            y: 0,
            vw: viewportSize.w,
            vh: viewportSize.h,
            padding: 0,
            z: z,
            zoom: z
          };

          this._zoom(bi.z);

          this.centerContent({
            bounds: bi,
            doNotAnimate: params.doNotAnimate,
            onComplete: params.onComplete
          });
        }
      }
      /**
       * Sets (or clears) the filter that will be called if the widget needs to know whether to respond to an event that would
       * start a pan. By default, the widget responds to down events on the viewport or the canvas, but not on child nodes. You
       * can supply a function that the widget will call in the event that the down event did not occur on the viewport or the canvas
       * returning true from this function will cause the pan to begin.
       * @param filterFn Function to set as the filter; may be null if you wish to clear it. The function should return true if it wants to honour the down event on the given element.
       */

    }, {
      key: "setFilter",
      value: function setFilter(filterFn) {
        this.filter = filterFn || function () {
          return false;
        };
      }
      /**
       * Position the widget so the background is centered in the viewport, without changing the current zoom.
       * @param params.onComplete Optional function to call on operation complete (centering may be animated).
       * @param params.doNotAnimate If true, centering content will not use animation.
       */

    }, {
      key: "centerBackground",
      value: function centerBackground(params) {
        if (this.background != null) {
          var bi = extend({}, this.getBoundsInfo());
          bi.x = this.background.getWidth() / 2;
          bi.y = this.background.getHeight() / 2;
          bi.w = 1;
          bi.h = 1;
          this.centerContent({
            bounds: bi,
            doNotAnimate: params.doNotAnimate,
            onComplete: params.onComplete,
            vertical: true,
            horizontal: true
          });
        }
      }
      /**
       * Positions the widget so that the edges of the background align with the viewport. This method is useful for
       * snapping to a corner of the background.
       * @param axes Spec for the axes to align to. This should be a space-separated string containing a value
       * for the x (allowed values `left` and `right`) and, optionally, y (allowed values `top` and `bottom`) axes. The
       * default value is `"left top"`.
       */

    }, {
      key: "alignBackground",
      value: function alignBackground(axes) {
        if (this.background != null) {
          var aa = axes.split(" "),
              ax = aa[0] || "left",
              ay = aa[1] || "top",
              bi = this.getBoundsInfo(),
              l = ax === "left" ? 0 : bi.vw - this.background.getWidth() * this.zoom,
              t = ay === "top" ? 0 : bi.vh - this.background.getHeight() * this.zoom,
              ap = this._apparentOffset();

          this._setCanvasPosition({
            x: l - ap.x,
            y: t - ap.y,
            animate: true
          });

          this.background.pan();
          this.fixedLayer.pan();
        }
      }
      /**
       * Places (using `style.left` and `style.top`) the given element at the given x,y, which is taken to
       * mean an x,y value on the canvas.  At zoom 1, with no panning, this will be the same as the given x,y value
       * relative to the viewport origin.  But once the canvas has been zoomed and panned we have to map
       * to the altered coordinates. This function also takes into account the difference between the offset of the
       * viewport in the page and the offset of the given element. It is assumed, just because of what this method
       * does, that the given element will be positioned `absolute`, but this method does nothing to ensure that.
       * @param el Element to position.
       * @param x X location on canvas to move element's left edge to.
       * @param y Y location on canvas to move element's top edge to.
       * @param xShift Optional absolute number of pixels to shift the element by in the x axis after calculating its position relative to the canvas. Typically you'd use this to place something other than the top left corner of your element at the desired location.
       * @param yShift Optional absolute number of pixels to shift the element by in the y axis after calculating its position relative to the canvas.
       * @param ensureOnScreen If true, will ensure that x and y positions are never negative.
       */

    }, {
      key: "positionElementAt",
      value: function positionElementAt(el, x, y, xShift, yShift, ensureOnScreen) {
        xShift = xShift || 0;
        yShift = yShift || 0;

        var ao = this._apparentOffset(),
            cp = this.position,
            p = el.parentNode,
            po = this.surface.getOffset(p),
            vo = this.surface.getOffset(this.viewportElement),
            _x = vo.x - po.x + (cp.x + ao.x) + x * this.zoom + xShift,
            _y = vo.y - po.y + (cp.y + ao.y) + y * this.zoom + yShift;

        if (ensureOnScreen && _x < 0) _x = 0;
        if (ensureOnScreen && _y < 0) _y = 0;
        el.style.left = _x + "px";
        el.style.top = _y + "px";
      }
      /**
       * Places (using `style.left` and `style.top`) the given element at the given page x,y.  It is assumed, just because of what this method
       * does, that the given element will be positioned `absolute`, but this method does nothing to ensure that.
       * @param el - Element to position.
       * @param x - X location on canvas to move element's left edge to.
       * @param y - Y location on canvas to move element's top edge to.
       * @param xShift - Optional absolute number of pixels to shift the element by in the x axis after calculating its position relative to the canvas. Typically you'd use this to place something other than the top left corner of your element at the desired location.
       * @param yShift - Optional absolute number of pixels to shift the element by in the y axis after calculating its position relative to the canvas.
       */

    }, {
      key: "positionElementAtPageLocation",
      value: function positionElementAtPageLocation(el, x, y, xShift, yShift) {
        var lt = this.fromPageLocation(x, y);
        this.positionElementAt(el, lt.x, lt.y, xShift, yShift);
      }
      /**
       * Places (using `style.left` and `style.top`) the given element at the page x,y corresponding to the given event.  It is assumed, just because of what this method
       * does, that the given element will be positioned `absolute`, but this method does nothing to ensure that.
       * @param el - Element to position.
       * @param evt - Event to position element at.
       * @param xShift - Optional absolute number of pixels to shift the element by in the x axis after calculating its position relative to the canvas. Typically you'd use this to place something other than the top left corner of your element at the desired location.
       * @param yShift - Optional absolute number of pixels to shift the element by in the y axis after calculating its position relative to the canvas.
       */

    }, {
      key: "positionElementAtEventLocation",
      value: function positionElementAtEventLocation(el, evt, xShift, yShift) {
        var lt = this.mapEventLocation(evt);
        this.positionElementAt(el, lt.x, lt.y, xShift, yShift);
      }
      /**
       * Zooms the component by the given increment, centered on the location at which the given event occurred.
       * @param e - Browser event
       * @param increment Amount to zoom by (a positive or negative number). If this takes the component out of the current zoom range, it will be clamped.
       */

    }, {
      key: "zoomToEvent",
      value: function zoomToEvent(e, increment) {
        this._setTransformOriginToEvent(e);

        this._zoom(this.zoom + increment, e);
      }
      /**
       * Tells the widget that a relayout has occurred. If panning is
       * disabled, the widget will move the canvas element so that all
       * content is visible, and adjust the transform origin so that the ui
       * zooms from the apparent top left corner. Nothing happens as a result of
       * this method if panning is enabled.
       * @param extents Bounds information, as an arry of [minX, minY, maxX, maxY.
       */

    }, {
      key: "relayout",
      value: function relayout(extents) {
        if (this.enablePan === false) {
          var width = extents[2] - extents[0],
              height = extents[3] - extents[1],
              s = window.getComputedStyle(this.viewportElement),
              zw = 1,
              zh = 1,
              maxWidth = parseInt(s.getPropertyValue("max-width"), 10),
              maxHeight = parseInt(s.getPropertyValue("max-height"), 10);

          if (!isNaN(maxWidth) && width > maxWidth) {
            zw = maxWidth / width;
            width = maxWidth;
          }

          if (!isNaN(maxHeight) && height > maxHeight) {
            zh = maxHeight / height;
            height = maxHeight;
          }

          var z = Math.min(zw, zh); // this stuff is when in 'direct render' mode, need to look at this once the translate code is working for the normal mode

          this.canvasElement.style.width = width + "px";
          this.canvasElement.style.height = height + "px";
          this.canvasElement.style.left = "0";
          this.canvasElement.style.top = "0";
          var tx = extents[0] < 0 ? -extents[0] : 0,
              ty = extents[1] < 0 ? -extents[1] : 0;
          this.canvasElement.style.transform = "translateX(" + tx * z + "px) translateY(" + ty * z + "px) scale(" + z + ")";
          this.setTransformOrigin(0, 0);
        }
      }
      /**
       * Nudges the zoom by the given amount. Zoom will be clamped to the current zoom range in effect and the
       * value that was ultimately set is returned from this function.
       * @param delta Amount to change zoom by. The value you pass in here is multiplied by
       * 100 to give a percentage value: 1 is 100%, for instance, 0.05 is 5%. You can pass in negative numbers to
       * zoom out.
       * @param e Original event that caused the nudge. May be null.
       * @returns The zoom that was set. Zoom will be clamped to the allowed range.
       */

    }, {
      key: "nudgeZoom",
      value: function nudgeZoom(delta, e) {
        // first set transform origin to be center of viewport
        var vo = this.surface.jsplumb.getOffsetRelativeToRoot(this.viewportElement),
            s = size(this.viewportElement),
            mx = vo.x + s.w / 2,
            my = vo.y + s.h / 2;

        this._setTransformOriginToPoint(mx, my);

        return this._zoom(this.zoom + delta, e);
      }
      /**
       * Nudges the wheel zoom by the given amount. This function is intended for use by components that control
       * zoom via the mouse wheel, and not for general usage. See `nudgeZoom` for a more general version of this.
       * @param delta Amount to change zoom by.
       * @param e Original event that caused the nudge. May be null.
       */

    }, {
      key: "nudgeWheelZoom",
      value: function nudgeWheelZoom(delta, e) {
        this.zoomAtZoomStart = this.zoom;

        this._zoomBy(0, delta, e, true);
      }
      /**
       * Centers the tracked content inside the viewport, but does not adjust the current zoom.
       * @param params Method parameters.
       * @param params.bounds Bounds info. This is in an internal format and only used when this method is called by the widget itself. Otherwise it is calculated.
       * @param params.horizontal True by default. Indicates the content should be centered in the X axis.
       * @param params.vertical True by default. Indicates the content should be centered in the Y axis.
       * @param params.doNotAnimate If true, don't animate while centering.
       * @param params.onComplete Optional function to call on operation complete (centering may be animated).
       * @param params.doNotFirePanEvent If true, a pan event will not be fired.
       */

    }, {
      key: "centerContent",
      value: function centerContent(params) {
        var _this5 = this;

        if (this.directRender) return;
        params = params || {};
        var bi = params.bounds || this.getBoundsInfo();

        var ao = this._apparentOffset(),
            midBoundsX = bi.x * this.zoom + bi.w * this.zoom / 2,
            midBoundsY = bi.y * this.zoom + bi.h * this.zoom / 2,
            l = bi.vw / 2 - midBoundsX,
            t = bi.vh / 2 - midBoundsY,
            cp = this.position;

        var x = params.horizontal !== false ? l - ao.x : cp.x,
            y = params.vertical !== false ? t - ao.y : cp.y;

        this._setCanvasPosition({
          x: x,
          y: y,
          animate: !params.doNotAnimate,
          onComplete: function onComplete() {
            if (!params.doNotFirePanEvent) {
              _this5.onPan(params.horizontal !== false ? l - cp.x : 0, params.vertical !== false ? t - cp.y : 0, _this5.zoom, _this5.zoom);
            }

            _this5.background && _this5.background.pan();

            _this5.fixedLayer.pan();

            if (params.onComplete) {
              params.onComplete({
                x: x,
                y: y
              });
            }
          }
        });
      }
      /**
       * Centers the tracked content inside the viewport horizontally, but does not adjust the current zoom.
       * @param params Method parameters.
       * @param params.bounds Bounds info. This is in an internal format and only used when this method is called by the widget itself. Otherwise it is calculated.
       * @param params.doNotAnimate If true, don't animate while centering.
       * @param params.onComplete Optional function to call on operation complete (centering may be animated).
       * @param params.doNotFirePanEvent If true, a pan event will not be fired.
       */

    }, {
      key: "centerContentHorizontally",
      value: function centerContentHorizontally(params) {
        this.centerContent(extend({
          horizontal: true,
          vertical: false
        }, params));
      }
      /**
       * Centers the tracked content inside the viewport vertically, but does not adjust the current zoom.
       * @param params Method parameters.
       * @param params.bounds Bounds info. This is in an internal format and only used when this method is called by the widget itself. Otherwise it is calculated.
       * @param params.doNotAnimate If true, don't animate while centering.
       * @param params.onComplete Optional function to call on operation complete (centering may be animated).
       * @param params.doNotFirePanEvent If true, a pan event will not be fired.
       */

    }, {
      key: "centerContentVertically",
      value: function centerContentVertically(params) {
        this.centerContent(extend({
          vertical: true,
          horizontal: false
        }, params));
      }
      /**
       * Centers the given element in the viewport, vertically and/or horizontally.
       * @param element Element, or element id, to center.
       * @param cparams Optional extra parameters.
       * @param cparams.horizontal Whether or not to center horizontally. Defaults to true.
       * @param cparams.vertical Whether or not to center vertically. Defaults to true.
       * @param cparams.doNotAnimate If true, animation will not be switched on for the operation.
       * @param cparams.onComplete Optional on complete callback
       */

    }, {
      key: "centerOn",
      value: function centerOn(element, cparams) {
        var _this6 = this;

        cparams = cparams || {};

        var bi = extend({}, this.getBoundsInfo()),
            p = this._getPosition(element),
            s = size(element);

        bi.x = p.x;
        bi.y = p.y;
        bi.w = s.w;
        bi.h = s.h;

        var onComplete = function onComplete() {
          _this6._setTransformOriginToCanvasPoint(p.x + s.w / 2, p.y + s.h / 2);

          cparams.onComplete && cparams.onComplete(p);
        };

        this.centerContent({
          bounds: bi,
          doNotAnimate: cparams.doNotAnimate,
          onComplete: onComplete,
          vertical: cparams.vertical !== false,
          horizontal: cparams.horizontal !== false
        });
      }
      /**
       * Centers the given element in the viewport, horizontally only.
       * @param element Element, or element id, to center.
       * @param cparams Optional extra parameters.
       * @param cparams.doNotAnimate If true, animation will not be switched on for the operation.
       * @param cparams.onComplete Optional on complete callback
       */

    }, {
      key: "centerOnHorizontally",
      value: function centerOnHorizontally(element, cparams) {
        this.centerOn(element, {
          vertical: false,
          doNotAnimate: cparams.doNotAnimate,
          onComplete: cparams.onComplete
        });
      }
      /**
       * Centers the given element in the viewport, vertically only.
       * @param element Element, or element id, to center.
       * @param cparams Optional extra parameters.
       * @param cparams.doNotAnimate If true, animation will not be switched on for the operation.
       * @param cparams.onComplete Optional on complete callback
       */

    }, {
      key: "centerOnVertically",
      value: function centerOnVertically(element, cparams) {
        this.centerOn(element, {
          horizontal: false,
          doNotAnimate: cparams.doNotAnimate,
          onComplete: cparams.onComplete
        });
      }
      /**
       * Centers on the given element and then adjusts the zoom of the widget so that the short axis of the viewport
       * is [1 / fillRatio] larger than its corresponding axis on the centered node. `fillRatio` is basically
       * a measure of how much context you want to see around the node on which you centered.
       * @param element - Element, or element id, to center.
       * @param cparams Optional extra params
       * @param cparams.fillRatio - Proportional ratio of the corresponding node's edge to the viewport's short edge. Defaults to 0.6.
       * @param cparams.doNotAnimate - By default, this operation is animated.
       * @internal
       */

    }, {
      key: "centerOnAndZoom",
      value: function centerOnAndZoom(element, cparams) {
        var _this7 = this;

        var fillRatio = cparams.fillRatio || 0.6;

        var dim = size(element),
            p = this._getPosition(element),
            bi = this.getBoundsInfo(),
            shortAxis = bi.vw < bi.vh ? [bi.vw, "w"] : [bi.vh, "h"],
            shortAxisApparentLength = fillRatio * shortAxis[0],
            desiredZoom = shortAxisApparentLength / dim[shortAxis[1]];

        if (desiredZoom < this.zoomRange[0]) {
          desiredZoom = this.zoomRange[0];
        }

        if (desiredZoom > this.zoomRange[1]) {
          desiredZoom = this.zoomRange[1];
        }

        this.zoom;
            desiredZoom - this.zoom;

        this._setTransformOriginToCanvasPoint(p.x + dim.w / 2, p.y + dim.h / 2);

        this.centerOn(element, {
          onComplete: function onComplete() {
            _this7._zoom(desiredZoom, null, null, !cparams.doNotAnimate);
          }
        });
      }
      /**
       * Gets the canvas location that corresponds to the center of the viewport.  Note that this may describe
       * a point outside of the content bounds.
       * @returns x,y location of the logical position on the canvas corresponding to the center of the viewport.
       */

    }, {
      key: "getViewportCenter",
      value: function getViewportCenter() {
        var bi = extend({}, this.getBoundsInfo()),
            ao = this._apparentOffset(),
            cp = this.position,
            p = {
          x: bi.vw / 2,
          y: bi.vh / 2
        };

        return {
          x: (p.x - (cp.x + ao.x)) / this.zoom,
          y: (p.y - (cp.y + ao.y)) / this.zoom
        };
      }
      /**
       * Sets the location of the canvas such that the given point appears at the center of the viewport.
       * @param xy - location of the point on the canvas to position in the center of the viewport.
       */

    }, {
      key: "setViewportCenter",
      value: function setViewportCenter(xy) {
        var bi = extend({}, this.getBoundsInfo()),
            ao = this._apparentOffset(),
            p = {
          x: bi.vw / 2,
          y: bi.vh / 2
        };

        var _ = {
          x: -(xy.x * this.zoom - p.x + ao.x),
          y: -(xy.y * this.zoom - p.y + ao.y)
        };

        this._setCanvasPosition({
          x: _.x,
          y: _.y,
          animate: false
        });
      }
      /**
       * Sets whether or not the widget clamps the movement of the canvas during pan/zoom
       * to ensure that the managed content never disappears from view.
       * @param c Whether or not to clamp movement.
       */

    }, {
      key: "setClamping",
      value: function setClamping(c) {
        this.clamp = c;
      }
      /**
       * Returns whether or not the widget clamps the movement of the canvas during pan/zoom/
       */

    }, {
      key: "isClamping",
      value: function isClamping() {
        return this.clamp;
      }
      /**
       * Sets the current zoom, clamping it to the allowed range.
       * @param z - Zoom value. If this is outside the allowed bounds it will be clamped.
       * @param animate - Whether to animate the change in zoom, or just go straight to the new zoom level.
       * @returns Current zoom. This may or may not be the value you asked for - it might have been clamped to the current allowed zoom range.
       */

    }, {
      key: "setZoom",
      value: function setZoom(z, animate) {
        return this._zoom(z, null, null, animate
        /*, dontFireEvent*/
        );
      }
      /**
       * Sets the current zoom range. By default, this method checks if the current zoom is within
       * the new range, and if it is not then `setZoom` is called, which will cause the zoom to be clamped
       * to an allowed value in the new range. You can disable this by passing `true` for `doNotClamp`.
       *
       * @param zr New range, as an array consisting of [lower, upper] values. Lower must be less than upper.
       * @param doNotClamp If true, will not check the current zoom to ensure it falls within the new range.
       * @returns Array of [min, max] current zoom values.
       */

    }, {
      key: "setZoomRange",
      value: function setZoomRange(zr, doNotClamp) {
        if (zr != null && zr.length === 2 && zr[0] < zr[1] && zr[0] != null && zr[1] != null && zr[0] > 0 && zr[1] > 0) {
          this.zoomRange = zr;

          if (!doNotClamp) {
            if (this.zoom < this.zoomRange[0] || this.zoom > this.zoomRange[1]) this._zoom(this.zoom);
          }
        }

        return this.zoomRange;
      }
      /**
       * Gets the current zoom range.
       * @returns Array of [min, max] current zoom values.
       */

    }, {
      key: "getZoomRange",
      value: function getZoomRange() {
        return this.zoomRange;
      }
      /**
       * Gets the current zoom.
       */

    }, {
      key: "getZoom",
      value: function getZoom() {
        return this.zoom;
      }
      /**
       * Gets the current position of the panned content.
       * @returns location, in pixels, of the panned content, where 0,0 is the origin of the viewport.
       */

    }, {
      key: "getPan",
      value: function getPan() {
        return extend({}, this.position);
      }
      /**
       * Pans the content by dx and dy.
       * @param dx Amount to pan in X direction
       * @param dy Amount to pan in Y direction
       * @param animate Whether or not to animate the pan.
       * @param onComplete - function to call once the pan is complete
       */

    }, {
      key: "pan",
      value: function pan(dx, dy, animate, onComplete) {
        var _this8 = this;

        this._moveCanvas(dx, dy, animate, function (m) {
          _this8.onPan(m.x, m.y, _this8.zoom, _this8.zoom);

          _this8.background && _this8.background.pan();

          _this8.fixedLayer.pan();

          onComplete && onComplete(m);
        });
      }
      /**
       * Sets the position of the panned content's origin.
       * @param left - Position in pixels of the left edge of the panned content.
       * @param top - Position in pixels of the top edge of the panned content.
       * @param animate - Whether or not to animate the pan.
       * @param onComplete - If `animate` is set to true, an optional callback for the end of the pan. This function is
       * passed a PointArray containing the final position.
       */

    }, {
      key: "setPan",
      value: function setPan(left, top, animate, onComplete) {
        return this._setCanvasPosition({
          x: left,
          y: top,
          animate: animate,
          onComplete: onComplete
        });
      }
      /**
       * Sets the current transform origin, in pixels. Used mainly to support save/restore state.
       * @param x - Position of the X coordinate of the transform origin.
       * @param y - Position of the Y coordinate of the transform origin.
       */

    }, {
      key: "setTransformOrigin",
      value: function setTransformOrigin(x, y) {
        this.transformOrigin = {
          x: x,
          y: y
        };

        this._writeTransformOrigin();
      }
      /**
       * Maps the given page location to a value relative to the viewport origin, allowing for
       * zoom and pan of the canvas. This takes into account the offset of the viewport in the page so that what
       * you get back is the mapped position relative to the target element's [left,top] corner. If
       * you wish, you can supply true for 'doNotAdjustForOffset', to suppress that behavior.
       * @param left X location
       * @param top Y location
       * @param doNotAdjustForOffset Whether or not to adjust for the offset of the viewport in the page.
       * @returns The mapped location, as a PointXY object.
       */

    }, {
      key: "fromPageLocation",
      value: function fromPageLocation(left, top, doNotAdjustForOffset) {
        var ao = this._apparentOffset(),
            cp = this.position,
            s = calculateCumulativeScroll(this.viewportElement),
            viewportOffset = doNotAdjustForOffset ? {
          x: 0,
          y: 0
        } : calculateOffset(this.viewportElement);

        return {
          x: (left - (cp.x + ao.x) - viewportOffset.x + s.x) / this.zoom,
          y: (top - (cp.y + ao.y) - viewportOffset.y + s.y) / this.zoom
        };
      }
      /**
       * Maps the given location on the canvas to a point relative to the page origin, allowing for zoom and
       * pan of the canvas. This takes into account the offset of the viewport in the page so that what
       * you get back is the mapped position computed relative to the target element's [left,top] corner. If
       * you wish, you can supply true for 'doNotAdjustForOffset', to suppress that behavior.
       * @param left
       * @param top
       * @param doNotAdjustForOffset
       */

    }, {
      key: "toPageLocation",
      value: function toPageLocation(left, top, doNotAdjustForOffset) {
        var ao = this._apparentOffset(),
            cp = this.position,
            s = calculateCumulativeScroll(this.viewportElement),
            viewportOffset = doNotAdjustForOffset ? {
          x: 0,
          y: 0
        } : calculateOffset(this.viewportElement);

        return {
          x: left * this.zoom - s.x + viewportOffset.x + cp.x + ao.x,
          y: top * this.zoom - s.y + viewportOffset.y + cp.y + ao.y
        };
      }
      /**
       * Maps the page location of the given event to a value relative to the viewport origin, allowing for
       * zoom and pan of the canvas. This takes into account the offset of the viewport in the page so that what
       * you get back is the mapped position relative to the target element's [left,top] corner. If
       * you wish, you can supply true for 'doNotAdjustForOffset', to suppress that behavior.
       * @param event Browser event
       * @param doNotAdjustForOffset Whether or not to adjust for the offset of the viewport in the page.
       * @returns The mapped location, as {left:number, top:number}
       */

    }, {
      key: "mapEventLocation",
      value: function mapEventLocation(event, doNotAdjustForOffset) {
        var pl = pageLocation(event);
        return this.fromPageLocation(pl.x, pl.y, doNotAdjustForOffset);
      }
      /**
       * Sets whether or not the component should respond to mouse events.
       * @param state Whether or not to respond to mouse events.
       */

    }, {
      key: "setEnabled",
      value: function setEnabled(state) {
        this.enabled = state;
      }
      /**
       * Takes some element that is in the DOM and moves it so that it appears at the given x,y over the canvas,
       * allowing for the current zoom and pan.  It is expected that the element is not one that is currently
       * managed by the widget - a common use case for this is some dialog, which you do not want to append to
       * the canvas since it would have the zoom effect applied.
       * @param el Selector, DOM element or element id representing the element to move.
       * @param x X location to move to.
       * @param y Y location to move to.
       */

    }, {
      key: "showElementAt",
      value: function showElementAt(el, x, y) {
        var dep = el.parentNode,
            depo = this.surface.getOffset(dep),
            vpo = this.surface.getOffset(this.viewportElement),
            _ao = this._apparentOffset(),
            _x = depo.x - vpo.x + _ao.x + x,
            _y = depo.y - vpo.y + _ao.y + y;

        el.style.left = _x + "px";
        el.style.top = _y + "px";
      }
      /**
       * Returns the apparent origin of the canvas inside the viewport - the coordinates, in real pixel
       * values, of where the origin of the canvas appears to be. This apparent origin is not necessarily the
       * same as the origin values of the canvas, because the transform origin and zoom values change
       * things.  This function can be used in conjunction with the content bounds by widgets such as the miniview,
       * to calculate what is actually visible in the viewport at some point in time.
       * @returns Position of the canvas, relative to the viewport's 0,0.
       */

    }, {
      key: "getApparentCanvasLocation",
      value: function getApparentCanvasLocation() {
        var ao = this._apparentOffset(),
            cp = this.position;

        return {
          x: cp.x + ao.x,
          y: cp.y + ao.y
        };
      }
      /**
       * Sets the apparent canvas location - see the notes for getApparentCanvasLocation.
       * @param left - Value in pixels for left edge of canvas.
       * @param top - Value in pixels for top edge of canvas.
       * @returns Position of the actual origin set, after clamping.
       */

    }, {
      key: "setApparentCanvasLocation",
      value: function setApparentCanvasLocation(left, top) {
        var ao = this._apparentOffset();

        var actual = this._setCanvasPosition({
          x: left - ao.x,
          y: top - ao.y,
          animate: false
        });

        this.background && this.background.pan();
        this.fixedLayer.pan();
        return actual;
      }
      /**
       * Appends an element to the viewport so that it floats above the content that is being zoomed and panned.
       * The element will have `position:absolute` set on it. You can float any element you like, but note that the
       * responsibility for setting an appropriate z index is yours.
       * @param el - Element to float.
       * @param pos - Position to float the element at.
       */

    }, {
      key: "floatElement",
      value: function floatElement(el, pos) {
        if (el == null) return;
        var _el = el;
        _el.style.position = "absolute";
        _el.style.left = pos.x + "px";
        _el.style.top = pos.y + "px";
        this.viewportElement.appendChild(el);
      }
      /**
       * Appends an element to the viewport such that it is zoomed with everything else, but constrains pan
       * in one or both axes so that the element remains fixed with respect to the viewport origin.
       * @param el The DOM element to append.
       * @param constraints Flags to indicate optional constraint to each axis.
       * @param pos Location of the element's origin.
       */

    }, {
      key: "fixElement",
      value: function fixElement(el, constraints, pos) {
        this.fixedLayer.append(el, constraints, pos);
      }
      /**
       * Finds all nodes that intersect to any extent the rectangle defined by the given origin
       * and dimensions. This rectangle is taken to be in the coordinate space of the page, ie. a value
       * of [0,0] for the origin means the page's top/left corner. A future version could take an optional
       * third argument specifying the element whose origin to use.
       * @param origin Center of search. IMPORTANT: This is relative to the page origin.
       * @param dimensions Width and height of search area.
       * @param enclosed Defaults to false. If true, returns only nodes that are enclosed by the given search area. Otherwise returns nodes that both intersect and are enclosed.
       * @param filter Optional filter function. This is passed the (id, node, boundingRect) of some element and should return true for elements that should be included in results.
       * @returns A list of objects that either intersect or are enclosed by the search area.
       */

    }, {
      key: "findIntersectingElements",
      value: function findIntersectingElements(origin, dimensions, enclosed, filter) {
        var _this9 = this;

        // TODO the bulk of this method would ideally be pushed into the viewport. but how much of it? viewport doesnt know about zoom etc.
        var cl = this.getApparentCanvasLocation(),
            vo = this.surface.getOffset(this.viewportElement),
            sl = this.viewportElement.scrollLeft,
            st = this.viewportElement.scrollTop,
            n = [],
            r = {
          x: origin.x,
          y: origin.y,
          w: dimensions.w,
          h: dimensions.h
        },
            compFn = function compFn(r1, r2) {
          if (enclosed) {
            return encloses(r1, r2);
          } else {
            return intersects(r1, r2);
          }
        }; // cl gives us the apparent origin of the canvas relative to the viewport,
        // and vo is the origin's viewport, so acl will give us the adjusted origin:


        var acl = {
          x: vo.x + cl.x - sl,
          y: vo.y + cl.y - st
        };
        var candidates = this.viewport.getElements();
        candidates.forEach(function (e, id) {
          if (!_this9._suspendMap[id]) {
            var r1 = {
              x: acl.x + e.x * _this9.zoom,
              y: acl.y + e.y * _this9.zoom,
              w: e.w * _this9.zoom,
              h: e.h * _this9.zoom
            };

            if (compFn(r, r1) && (filter == null || filter(e, r1, id))) {
              n.push({
                id: id,
                r: r1
              });
            }
          }
        });
        return n;
      }
      /**
       * Finds all nodes whose centers are within a rectangle with `origin` as its center, and
       * a width and height of `radius / 2`.
       * @param origin Location for center of search. IMPORTANT: This is relative to the page origin.
       * @param radius Radius of search.
       * @param mustBeInViewport If true, first check that the given origin is within the viewport.
       * @param filter Optional filter function. Should return true for elements that should be included in results.
       * @returns A list of objects containing {id:id, el:element, r:bounding rect}, sorted in ascending order of distance of the center of the bounding rectangle from the given origin.
       */

    }, {
      key: "findNearbyElements",
      value: function findNearbyElements(origin, radius, mustBeInViewport, filter) {
        var nodes = [];

        if (!mustBeInViewport || this.isInViewport(origin.x, origin.y)) {
          nodes = this.findIntersectingElements({
            x: origin.x - radius,
            y: origin.y - radius
          }, {
            w: radius * 2,
            h: radius * 2
          }, false, filter); // map the origin to one that is in the same coord space as the nodes.

          var mappedOrigin = this.fromPageLocation(origin.x, origin.y);
          nodes.sort(function (n1, n2) {
            var c1 = {
              x: n1.x + n1.w / 2,
              y: n1.y + n1.h / 2
            },
                c2 = {
              x: n2.x + n2.w / 2,
              y: n2.y + n2.h / 2
            },
                d1 = lineLength({
              x: mappedOrigin.x,
              y: mappedOrigin.y
            }, c1),
                d2 = lineLength({
              x: mappedOrigin.x,
              y: mappedOrigin.y
            }, c2);
            return d1 < d2 ? -1 : d1 > d2 ? 1 : 0;
          });
        }

        return nodes;
      }
      /**
       * Returns whether or not the given point (relative to page origin) is within the viewport for the widget.
       * @param x X location of point to test
       * @param y Y location of point to test
       * @returns true if the point is within the viewport, false if not.
       */

    }, {
      key: "isInViewport",
      value: function isInViewport(x, y) {
        var o = this.surface.getOffset(this.viewportElement),
            s = this.surface.jsplumb.getSize(this.viewportElement);
        return o.x <= x && x <= o.x + s.w && o.y <= y && y <= o.y + s.h;
      }
      /**
       * Sets the filter used to determine whether or not a given wheel event should be responded to.
       * @param f A function that will be given the current mouse event. You must return false from the function if you wish for the wheel event to be responded to.
       */

    }, {
      key: "setWheelFilter",
      value: function setWheelFilter(f) {
        this.wheelFilter = f || function (e) {
          return true;
        };
      }
      /**
       * Sets the background for the canvas element.
       */

    }, {
      key: "setBackground",
      value: function setBackground(params) {
        var type = params.type || "simple",
            clazz = {
          "simple": SimpleBackground,
          "tiled": params.tiling === "absolute" ? AbsoluteTiledBackground : LogarithmicTiledBackground
        };
        this.background = new clazz[type]({
          canvas: this.canvasElement,
          viewport: this.viewportElement,
          url: params.url,
          zoomWidget: this,
          onBackgroundReady: params.onBackgroundReady,
          options: params,
          img: params.img
        });
      }
      /**
       * Gets the current background layer.
       * @returns current background layer. you can use the `getWidth` and `getHeight` methods on this object to find out the background size.
       */

    }, {
      key: "getBackground",
      value: function getBackground() {
        return this.background;
      }
      /**
       * Cleans up the pan zoom widget - removes all event bindings, and all elements from the DOM.
       */

    }, {
      key: "destroy",
      value: function destroy() {
        //params.unbind(document, "mouseup", clearPanTimer)
        if (this._doWheelZoom != null) {
          removeWheelListener(this.viewportElement, this._doWheelZoom);
        }

        this.pinchListener.destroy();
      }
    }]);

    return PanZoom;
  }();
  /**
   * Create a debounced version of the given function.
   * @param fn
   * @param timeout
   */

  function debounce(fn, timeout) {
    timeout = timeout || 150;
    var _t = null;
    return function () {
      window.clearTimeout(_t);
      _t = window.setTimeout(fn, timeout);
    };
  }
  /**
   * Basic ajax function.
   * @param params
   */

  function ajax(params) {
    var req = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject("Microsoft.XMLHTTP");
    var verb = params.type || "GET";

    if (req) {
      var responder = params.dataType === "json" ? function (d) {
        return JSON.parse(d);
      } : function (d) {
        return d;
      };
      req.open(verb, params.url, true);
      var headers = params.headers || {};

      for (var h in headers) {
        req.setRequestHeader(h, headers[h]);
      }

      req.onreadystatechange = function () {
        if (req.readyState === 4) {
          if (("" + req.status)[0] === "2") {
            params.success(responder(req.responseText));
          } else {
            params.error && params.error(req.responseText, req.status);
          }
        }
      };

      req.send(params.data ? JSON.stringify(params.data) : null);
    } else {
      params.error && params.error("ajax not supported");
    }
  }
  /**
   * Returns the position of the given element, as reported by the `left` and `top` properties of the element's `style`.
   * @param element
   */

  function getAbsolutePosition(element) {
    var _el = element;
    return {
      x: parseInt(_el.style.left, 10),
      y: parseInt(_el.style.top, 10)
    };
  }
  /**
   * Sets the position of the given DOM element, by setting values for `left` and `top` on the element's `style`.
   * @param element
   * @param x Left position, in pixels.
   * @param y Top position, in pixels.
   */

  function setAbsolutePosition(element, x, y) {
    var _el = element;
    _el.style.left = x + "px";
    _el.style.top = y + "px";
  }
  /**
   * Sets the size of the given DOM element, by setting values for `width` and `height` on the element's `style`.
   * @param element
   * @param w Width, in pixels.
   * @param h Height, in pixels.
   */

  function setSize(element, w, h) {
    var _el = element;
    _el.style.width = w + "px";
    _el.style.height = h + "px";
  }
  /**
   * Sets the position and size of the given element. This method is equivalent to first calling `setAbsolutePosition` and then `setSize` on
   * the given element.
   * @param element
   * @param origin
   * @param size
   */

  function setBoundingRect(element, origin, size) {
    setAbsolutePosition(element, origin.x, origin.y);
    setSize(element, size.w, size.h);
  }

  /**
   * Concrete instance of the Toolkit that uses ajax to load data asynchronously.
   */

  var BrowserUIBase = /*#__PURE__*/function (_JsPlumbToolkit) {
    _inherits$7(BrowserUIBase, _JsPlumbToolkit);

    var _super = _createSuper$7(BrowserUIBase);

    function BrowserUIBase() {
      _classCallCheck$c(this, BrowserUIBase);

      return _super.apply(this, arguments);
    }

    _createClass$c(BrowserUIBase, [{
      key: "loadData",
      value: function loadData(options) {
        ajax(options);
      }
    }]);

    return BrowserUIBase;
  }(JsPlumbToolkit);
  /**
   * Defines a template renderer
   */

  function attWithValue(att, value) {
    return "[" + att + "='" + value + "']";
  }
  /**
   * This method is not intended to be used by a library user - you should use the `render` method on the Toolkit instance instead.
   *
   * Configures the given element as a Surface, registering it so that it reflects any changes to the underlying data. If
   * there is any data in the Toolkit at the time of this call it is rendered; any data subsequently loaded is automatically
   * rendered. You can supply layout arguments to this method (layout type + layout specific parameters), as well as jsPlumb rules for
   * endpoints, paint styles etc.
   * @param toolkit The JsPlumbToolkit to render
   * @param container The Element to render into
   * @param renderer Template renderer to use - abstracts out the Toolkit's own templates vs Angular/React/Vue etc
   * @param options Render options
   * @internal
   */

  function render(toolkit, container, renderer, options) {
    var p = extend({
      dataSource: toolkit,
      container: container
    }, options || {}); //p.templateRenderer = renderer
    // if a selection supplied, set that as the toolkit (model supplier, basically). two cases
    // are supported: one, that `selection` is a pre-prepared Selection, in which case we use it.
    // second case is that `selection` is just some function that can populate a selection, in
    // which case we make a new Selection and set what we were given as its "generator".

    if (p.selection != null) {
      if (!(typeof p.selection === "function")) {
        p.dataSource = p.selection;
      } else {
        p.dataSource = new Selection(toolkit, {
          generator: p.selection
        });
      }
    }

    p.toolkitInstance = toolkit;
    var id = p.id || uuid();
    var surface = new Surface(p, renderer);
    toolkit.addRenderer(surface, id);
    return surface;
  }

  var DEFAULT = "default";
  var DEFAULT_MERGE_OVERRIDES = ["anchor", "anchors", "cssClass", "connector", "paintStyle", "hoverPaintStyle", "endpoint", "endpoints"];
  var DEFAULT_MERGE_PARENT_ATTRIBUTE = "parent";
  function shouldOverrideEndpoints(p, from) {
    return p === "endpoints" && isFunction(from.endpoints);
  }
  /**
   * Extract the definition(s) with the given type and merge them,
   * @param type Type, or types, to extract. If a single type is specified that is what will be returned. If an array of types are specified they will all be merged together.
   * @param map Map from which to retrieve individual types
   * @param shouldOverride
   */

  function mergeWithParents(type, map, shouldOverride) {
    var _def = function _def(id) {
      return id ? map[id] : null;
    };

    var _parent = function _parent(def) {
      return def ? _def(def[DEFAULT_MERGE_PARENT_ATTRIBUTE]) : null;
    };

    var _one = function _one(parent, def) {
      if (parent == null) {
        return def;
      } else {
        var overrides = DEFAULT_MERGE_OVERRIDES.slice();

        if (def.mergeStrategy === "override") {
          Array.prototype.push.apply(overrides, ["events", "overlays"]);
        } //Array.prototype.push.apply(overrides, overrideParameters || [])
        // in certain cases - endpoints, for example - the type of the parameter determines whether or not we want to override the parent. When `endpoints` is a Function we


        if (shouldOverride != null) {
          overrides = overrides.filter(function (p) {
            return shouldOverride(p, def);
          });
        }

        var _d = merge(parent, def, [], overrides);

        return _one(_parent(parent), _d);
      }
    };

    var _getDef = function _getDef(t) {
      if (t == null) {
        return {};
      }

      if (typeof t === "string") {
        return _def(t);
      } else if (t.length) {
        var done = false,
            i = 0,
            _dd;

        while (!done && i < t.length) {
          _dd = _getDef(t[i]);

          if (_dd) {
            done = true;
          } else {
            i++;
          }
        }

        return _dd;
      }
    };

    var d = _getDef(type);

    if (d) {
      return _one(_parent(d), d);
    } else {
      return {};
    }
  }
  /**
   * A Model describes the appearance and behaviour of a set of Nodes, Edges, Ports and Groups. You do not create one of these directly; instead you pass a definition to a `jsPlumbToolkit.render` or
   * `jsPlumbToolkitBrowserUI.newInstance()` call. Although the Model has the same syntax in each context, you are
   * encouraged to configure model-specific things in the Model you pass to the `newInstance` method (such as,
   * which Nodes/Ports can be connected to which others, what is the maximum number of connections, etc), and
   * view-specific things (such as css classes, paint styles, connector appearance etc) to the model you pass to
   * the `render` method. The `render` method automatically merges in a Node/Port/Edge definition from a Model
   * defined on the associated Toolkit, if there is one. Only the Surface widget provides this. The Toolkit instance creates a Model but it is headless.
   */

  var BrowserUIModel = /*#__PURE__*/function () {
    /**
     * @param params Model parameters
     * @param _jsPlumb An instance of jsPlumb on which to register associated Connection and Endpoint types.
     * @param params
     * @param _jsPlumb
     */
    function BrowserUIModel(toolkit, dataModel, viewOptions, _jsPlumb) {
      _classCallCheck$c(this, BrowserUIModel);

      this.toolkit = toolkit;
      this.viewOptions = viewOptions;

      _defineProperty$b(this, "defMap", {
        nodes: new Map(),
        edges: new Map(),
        groups: new Map(),
        ports: new Map()
      });

      _defineProperty$b(this, "nodes", void 0);

      _defineProperty$b(this, "edges", void 0);

      _defineProperty$b(this, "groups", void 0);

      _defineProperty$b(this, "ports", void 0);

      this.viewOptions = this.viewOptions || {};
      this.nodes = this.viewOptions.nodes || {};
      this.edges = this.viewOptions.edges || {};
      this.ports = this.viewOptions.ports || {};
      this.groups = this.viewOptions.groups || {};
      var def, i, pDef; // populate the connection and endpoint types in the supplied jsPlumb instance (if it was supplied. The Toolkit does not
      // provide a jsPlumb instance; it is headless.

      if (typeof _jsPlumb != "undefined") {
        // edges (connections)
        for (var di in this.viewOptions.edges) {
          def = this.getEdgeDefinition(di); // now look for listeners registered on overlays. we actually want to replace those	with our
          // own listeners, because jsPlumb passes only the overlay and the event, whereas we want to pass
          // the event and the overlay as well as the edge and connection.

          if (def.overlays) {
            for (i = 0; i < def.overlays.length; i++) {
              var anOverlay = def.overlays[i];

              if (isFullOverlaySpec(anOverlay)) {
                var overlayOptions = anOverlay.options;

                for (var j in overlayOptions.events) {
                  overlayOptions.events[j] = function (fn, overlay) {
                    return function (p) {
                      fn.call(overlay, {
                        overlay: p.overlay,
                        e: p.e,
                        connection: p.overlay.component,
                        edge: p.overlay.component.edge
                      });
                    };
                  }(overlayOptions.events[j], anOverlay);
                }
              }
            }
          }

          _jsPlumb.registerConnectionType(di, def);
        } // ports (endpoints)


        for (i in this.viewOptions.ports) {
          pDef = this.getPortDefinition(i);

          _jsPlumb.registerEndpointType(i, pDef);
        }
      }
    }

    _createClass$c(BrowserUIModel, [{
      key: "getEdgeDefinition",
      value: function getEdgeDefinition(typeId) {
        if (typeId == null) {
          return null;
        }

        if (!this.defMap.edges.has(typeId)) {
          var _def = mergeWithParents([typeId, DEFAULT], this.edges); // inject label if provided at root level of edge def


          if (_def.label != null) {
            _def.overlays = _def.overlays || [];
            var lbl = {
              type: LabelOverlay.type,
              options: {
                id: "label",
                label: _def.label
              }
            };

            if (_def.labelClass) {
              lbl.options.cssClass = _def.labelClass;
            }

            if (_def.labelLocation) {
              lbl.options.location = _def.labelLocation;
            }

            if (_def.labelLocationAttribute) {
              lbl.options.labelLocationAttribute = _def.labelLocationAttribute;
            }

            _def.overlays.push(lbl);

            delete _def.label;
          }

          delete _def.parent;
          this.defMap.edges.set(typeId, _def);
          return _def;
        } else {
          return this.defMap.edges.get(typeId);
        }
      }
    }, {
      key: "getNodeDefinition",
      value: function getNodeDefinition(typeId) {
        if (typeId == null) {
          return null;
        }

        if (!this.defMap.nodes.has(typeId)) {
          var _def = mergeWithParents([typeId, DEFAULT], this.nodes, shouldOverrideEndpoints);

          delete _def.parent;
          this.defMap.nodes.set(typeId, _def);
          return _def;
        } else {
          return this.defMap.nodes.get(typeId);
        }
      }
    }, {
      key: "getPortDefinition",
      value: function getPortDefinition(typeId) {
        if (typeId == null) {
          return null;
        }

        if (!this.defMap.ports.has(typeId)) {
          var _def = mergeWithParents([typeId, DEFAULT], this.ports, shouldOverrideEndpoints);

          delete _def.parent;
          this.defMap.ports.set(typeId, _def);
          return _def;
        } else {
          return this.defMap.ports.get(typeId);
        }
      }
    }, {
      key: "getGroupDefinition",
      value: function getGroupDefinition(typeId) {
        if (typeId == null) {
          return null;
        }

        if (!this.defMap.groups.has(typeId)) {
          var _def = mergeWithParents([typeId, DEFAULT], this.groups, shouldOverrideEndpoints);

          delete _def.parent;
          this.defMap.groups.set(typeId, _def);
          return _def;
        } else {
          return this.defMap.groups.get(typeId);
        }
      }
    }, {
      key: "getTypeDefinition",
      value: function getTypeDefinition(obj) {
        var typeId = this.toolkit.getType(obj);

        if (isNode(obj)) {
          return this.getNodeDefinition(typeId);
        } else if (isGroup(obj)) {
          return this.getGroupDefinition(typeId);
        } else if (isPort(obj)) {
          return this.getPortDefinition(typeId);
        }
      }
    }]);

    return BrowserUIModel;
  }();

  /**
   * A wrapper around the Toolkit's path object, which offers a few DOM specific methods.
   */
  var UIPath = /*#__PURE__*/function () {
    /**
     * @param path Underlying path object.
     * @param surface The surface that constructed this path.
     */
    function UIPath(path, surface) {
      _classCallCheck$c(this, UIPath);

      this.path = path;
      this.surface = surface;
    }
    /**
     * Gets the count of vertices in the path.
     */


    _createClass$c(UIPath, [{
      key: "getVertexCount",
      value: function getVertexCount() {
        return this.path.getVertexCount();
      }
      /**
       * Gets the total number of edges in the path.
       */

    }, {
      key: "getEdgeCount",
      value: function getEdgeCount() {
        return this.path.getEdgeCount();
      }
      /**
       * Sets the visible state of all vertices and edges in the path
       * @param val
       */

    }, {
      key: "setVisible",
      value: function setVisible(val) {
        this.surface.setVisible(this.path, val);
      }
      /**
       * Adds a CSS class to the elements representing the vertices in the path
       * @param clazz
       */

    }, {
      key: "addVertexClass",
      value: function addVertexClass(clazz) {
        var _this = this;

        this.path.eachVertex(function (i, n) {
          _this.surface.addClass(n, clazz);
        });
      }
      /**
       * Removes a CSS class from the elements representing the vertices in the path
       * @param clazz
       */

    }, {
      key: "removeVertexClass",
      value: function removeVertexClass(clazz) {
        var _this2 = this;

        this.path.eachVertex(function (i, n) {
          _this2.surface.removeClass(n, clazz);
        });
      }
      /**
       * Adds a CSS class to the elements representing the edges in the path
       * @param clazz
       */

    }, {
      key: "addEdgeClass",
      value: function addEdgeClass(clazz) {
        var _this3 = this;

        this.path.eachEdge(function (i, e) {
          _this3.surface.connMap[e.getId()].addClass(clazz);
        });
      }
      /**
       * Removes a CSS class from the elements representing the edges in the path
       * @param clazz
       */

    }, {
      key: "removeEdgeClass",
      value: function removeEdgeClass(clazz) {
        var _this4 = this;

        this.path.eachEdge(function (i, e) {
          _this4.surface.connMap[e.getId()].removeClass(clazz);
        });
      }
      /**
       * Adds a CSS class to the elements representing the vertices and edges in the path
       * @param clazz
       */

    }, {
      key: "addClass",
      value: function addClass(clazz) {
        this.addVertexClass(clazz);
        this.addEdgeClass(clazz);
      }
      /**
       * Removes a CSS class from the elements representing the vertices and edges in the path
       * @param clazz
       */

    }, {
      key: "removeClass",
      value: function removeClass(clazz) {
        this.removeVertexClass(clazz);
        this.removeEdgeClass(clazz);
      }
    }]);

    return UIPath;
  }();

  var SurfaceMode;

  (function (SurfaceMode) {
    SurfaceMode["PAN"] = "pan";
    SurfaceMode["SELECT"] = "select";
    SurfaceMode["DISABLED"] = "disabled";
  })(SurfaceMode || (SurfaceMode = {}));

  /**
   * The default attribute used to model a vertex's position in the X axis in its backing data
   */
  var DEFAULT_LEFT_ATTRIBUTE = "left";
  /**
   * The default attribute used to model a vertex's position in the X axis in its backing data
   */

  var DEFAULT_TOP_ATTRIBUTE = "top"; // const _defaultTemplate = "<div data-jtk-node-id=\"${id}\" class=\"" + CLASS_NODE + "\"></div>"

  var DEFAULT_LABEL_LOCATION_ATTRIBUTE = "labelLocation";
  var localEvents = [EVENT_CANVAS_CLICK, EVENT_CANVAS_DBL_CLICK, EVENT_CONTEXTMENU, EVENT_NODE_ADDED, EVENT_NODE_REMOVED, EVENT_NODE_RENDERED, EVENT_GROUP_ADDED$1, EVENT_GROUP_REMOVED$1, EVENT_GROUP_MOVE_END, EVENT_GROUP_MEMBER_ADDED$1, EVENT_GROUP_MEMBER_REMOVED$1, EVENT_GROUP_COLLAPSE, EVENT_GROUP_EXPAND, EVENT_GROUP_RELAYOUT, EVENT_GROUP_RESIZE, EVENT_NODE_MOVE_START, EVENT_NODE_MOVE_END, EVENT_PORT_ADDED, EVENT_NODE_MOVE, EVENT_PORT_REMOVED, EVENT_EDGE_ADDED, EVENT_EDGE_ADDED, EVENT_EDGE_TYPE_CHANGED, EVENT_DATA_LOAD_END, EVENT_ANCHOR_CHANGED, EVENT_OBJECT_REPAINTED, EVENT_SURFACE_MODE_CHANGED, EVENT_LASSO_END, EVENT_PAN, EVENT_ZOOM, EVENT_RELAYOUT, EVENT_CLICK, EVENT_TAP, EVENT_DBL_TAP, EVENT_STATE_RESTORED, EVENT_NODE_VISIBILITY, EVENT_AFTER_LAYOUT_REFRESH, EVENT_DESTROY, EVENT_ROTATE];

  function bothEndpointsVisible(connection) {
    return connection.endpoints[0].element._jtkVisible !== false && connection.endpoints[1].element._jtkVisible !== false;
  }

  function maybeToggleEndpoint(connection, endpoint, state) {
    if (endpoint.connections.length === 1) {
      endpoint.setVisible(state, true);
    } else {
      if (state) {
        endpoint.setVisible(true, true);
      } else {
        // else we're hiding, check if all the other connections are also not visible
        for (var i = 0; i < endpoint.connections.length; i++) {
          if (endpoint.connections[i] !== connection && endpoint.connections[i].isVisible()) {
            return;
          }
        }

        endpoint.setVisible(false, true);
      }
    }
  }
  /**
   * Extracts an endpoint definition from the given value source, which may be a DOM element or a JS object. For internal use.
   * @param valueSource
   * @internal
   */


  function _extractEndpointDefinitionFromValueSource(valueSource) {
    var portId = valueSource.value(ATTRIBUTE_JTK_PORT);
    var portType = valueSource.value(ATTRIBUTE_JTK_PORT_TYPE);
    var anchorX = valueSource.value(ATTRIBUTE_ANCHOR_X);
    var anchorY = valueSource.value(ATTRIBUTE_ANCHOR_Y);
    var offsetX = valueSource.value(ATTRIBUTE_OFFSET_X);
    var offsetY = valueSource.value(ATTRIBUTE_OFFSET_Y);
    var orientationX = valueSource.value(ATTRIBUTE_ORIENTATION_X);
    var orientationY = valueSource.value(ATTRIBUTE_ORIENTATION_Y);
    var edgeType = valueSource.value(ATTRIBUTE_JTK_EDGE_TYPE);
    var source = valueSource.value(ATTRIBUTE_JTK_SOURCE);
    var target = valueSource.value(ATTRIBUTE_JTK_TARGET);
    var def = filterNull({
      portId: portId,
      portType: portType,
      source: source,
      target: target,
      edgeType: edgeType
    });

    if (anchorX != null && anchorY != null) {
      def.anchor = [parseFloat(anchorX), parseFloat(anchorY), parseInt(orientationX || "0", 10), parseInt(orientationY || "0", 10), parseFloat(offsetX || "0"), parseFloat(offsetY || "0")];
    }

    return def;
  }

  function isDOMElement(el) {
    return el.nodeType != null && el.nodeType !== 3 && el.nodeType !== 8;
  }

  function _initialiseDecorators(dlist, adapter, container) {
    if (dlist == null) {
      return [];
    }

    var out = [];

    var _resolve = function _resolve(d) {
      var fnName = typeof d === "string" ? d : d.type,
          fnParams = typeof d === "string" ? {} : d.options,
          fn = Decorators.get(fnName, fnParams, adapter, container);

      if (!fn) {
        log("Decorator [" + fnName + "] nor registered on jsPlumbToolkit.Layouts.Decorators. Not fatal.");
        return null;
      }

      return fn;
    };

    for (var i = 0; i < dlist.length; i++) {
      var d = _resolve(dlist[i]);

      if (d) {
        out.push(d);
      }
    }

    return out;
  }

  var MagnetizeProfile = function MagnetizeProfile(opts, gridProfile) {
    _classCallCheck$c(this, MagnetizeProfile);

    this.gridProfile = gridProfile;

    _defineProperty$b(this, "afterGroupCollapse", void 0);

    _defineProperty$b(this, "afterGroupExpand", void 0);

    _defineProperty$b(this, "afterGroupResize", void 0);

    _defineProperty$b(this, "afterGroupShrink", void 0);

    _defineProperty$b(this, "afterGroupGrow", void 0);

    _defineProperty$b(this, "afterLayout", void 0);

    _defineProperty$b(this, "afterDrag", void 0);

    _defineProperty$b(this, "constant", void 0);

    _defineProperty$b(this, "constrainToViewport", void 0);

    _defineProperty$b(this, "repositionDraggedElement", void 0);

    _defineProperty$b(this, "grid", void 0);

    if (opts != null) {
      this.afterDrag = opts.afterDrag === true;
      this.constant = opts.constant === true;
      this.constrainToViewport = opts.constrainToViewport === true;
      this.repositionDraggedElement = opts.repositionDraggedElement === true;
      this.afterLayout = opts.afterLayout === true;
      this.afterGroupResize = opts.afterGroupResize === true;
      this.afterGroupShrink = opts.afterGroupShrink === true || this.afterGroupResize && opts.afterGroupShrink !== false;
      this.afterGroupGrow = opts.afterGroupGrow === true || this.afterGroupResize && opts.afterGroupGrow !== false;
      this.afterGroupCollapse = opts.afterGroupCollapse === true;
      this.afterGroupExpand = opts.afterGroupExpand === true; // sanity check

      if (this.constant && this.afterDrag) {
        this.constant = false;
      }

      if (this.constant) {
        this.repositionDraggedElement = false;
      }
    }
  };

  var GridProfile = function GridProfile(opts) {
    _classCallCheck$c(this, GridProfile);

    _defineProperty$b(this, "grid", void 0);

    _defineProperty$b(this, "snap", false);

    _defineProperty$b(this, "fitGroupsToGrid", false);

    if (opts != null) {
      this.snap = opts.snap === true;
      this.grid = opts.size;
      this.fitGroupsToGrid = opts.fitGroupsToGrid !== false;
    }
  };

  var Surface = /*#__PURE__*/function (_OptimisticEventGener) {
    _inherits$7(Surface, _OptimisticEventGener);

    var _super = _createSuper$7(Surface);

    function Surface(params, templateRenderer) {
      var _this;

      _classCallCheck$c(this, Surface);

      _this = _super.call(this);
      _this.templateRenderer = templateRenderer;

      _defineProperty$b(_assertThisInitialized$7(_this), "_debug", void 0);

      _defineProperty$b(_assertThisInitialized$7(_this), "magnetizeProfile", void 0);

      _defineProperty$b(_assertThisInitialized$7(_this), "gridProfile", void 0);

      _defineProperty$b(_assertThisInitialized$7(_this), "viewport", void 0);

      _defineProperty$b(_assertThisInitialized$7(_this), "_layoutMap", new Map());

      _defineProperty$b(_assertThisInitialized$7(_this), "dataSource", void 0);

      _defineProperty$b(_assertThisInitialized$7(_this), "toolkitInstance", void 0);

      _defineProperty$b(_assertThisInitialized$7(_this), "_layout", void 0);

      _defineProperty$b(_assertThisInitialized$7(_this), "container", void 0);

      _defineProperty$b(_assertThisInitialized$7(_this), "containerId", void 0);

      _defineProperty$b(_assertThisInitialized$7(_this), "containerElement", void 0);

      _defineProperty$b(_assertThisInitialized$7(_this), "canvasElement", void 0);

      _defineProperty$b(_assertThisInitialized$7(_this), "logicalPorts", void 0);

      _defineProperty$b(_assertThisInitialized$7(_this), "_storePositionsInModel", void 0);

      _defineProperty$b(_assertThisInitialized$7(_this), "decorators", void 0);

      _defineProperty$b(_assertThisInitialized$7(_this), "vertexList", []);

      _defineProperty$b(_assertThisInitialized$7(_this), "connMap", {});

      _defineProperty$b(_assertThisInitialized$7(_this), "unrenderedEdges", []);

      _defineProperty$b(_assertThisInitialized$7(_this), "nodeRenderer", void 0);

      _defineProperty$b(_assertThisInitialized$7(_this), "portRenderer", void 0);

      _defineProperty$b(_assertThisInitialized$7(_this), "groupRenderer", void 0);

      _defineProperty$b(_assertThisInitialized$7(_this), "_suspendRendering", void 0);

      _defineProperty$b(_assertThisInitialized$7(_this), "_refreshAutomatically", void 0);

      _defineProperty$b(_assertThisInitialized$7(_this), "objectFilter", void 0);

      _defineProperty$b(_assertThisInitialized$7(_this), "_modelTopAttribute", void 0);

      _defineProperty$b(_assertThisInitialized$7(_this), "_modelLeftAttribute", void 0);

      _defineProperty$b(_assertThisInitialized$7(_this), "elementsDraggable", void 0);

      _defineProperty$b(_assertThisInitialized$7(_this), "enhancedView", void 0);

      _defineProperty$b(_assertThisInitialized$7(_this), "dragGroupAssigner", void 0);

      _defineProperty$b(_assertThisInitialized$7(_this), "_ignoreToolkitEvents", false);

      _defineProperty$b(_assertThisInitialized$7(_this), "view", void 0);

      _defineProperty$b(_assertThisInitialized$7(_this), "dragOptions", void 0);

      _defineProperty$b(_assertThisInitialized$7(_this), "refreshLayoutOnEdgeConnect", void 0);

      _defineProperty$b(_assertThisInitialized$7(_this), "jsplumb", void 0);

      _defineProperty$b(_assertThisInitialized$7(_this), "id", void 0);

      _defineProperty$b(_assertThisInitialized$7(_this), "panZoom", void 0);

      _defineProperty$b(_assertThisInitialized$7(_this), "contentBounds", null);

      _defineProperty$b(_assertThisInitialized$7(_this), "plugins", void 0);

      _defineProperty$b(_assertThisInitialized$7(_this), "pluginMap", new Map());

      _defineProperty$b(_assertThisInitialized$7(_this), "wheelReverse", void 0);

      _defineProperty$b(_assertThisInitialized$7(_this), "directRender", void 0);

      _defineProperty$b(_assertThisInitialized$7(_this), "zoomToFitOnLoad", void 0);

      _defineProperty$b(_assertThisInitialized$7(_this), "mode", SurfaceMode.PAN);

      _defineProperty$b(_assertThisInitialized$7(_this), "autoExitSelectMode", true);

      _defineProperty$b(_assertThisInitialized$7(_this), "_pendingDragGroupAssignments", []);

      _defineProperty$b(_assertThisInitialized$7(_this), "_boundToolkitEvents", []);

      var jsPlumbParams = merge(params.defaults || {}, {
        container: params.container,
        managedElementsSelector: att(ATTRIBUTE_MANAGED, ATTRIBUTE_JTK_PORT)
      });
      _this.logicalPorts = params.logicalPorts === true;
      _this.jsplumb = params.jsPlumbInstance || newInstance$1(jsPlumbParams);
      _this.viewport = _this.jsplumb.viewport;
      _this.decorators = _initialiseDecorators(params.decorators, _assertThisInitialized$7(_this), params.container);
      _this._debug = params.debug === true;
      _this.container = params.container;
      _this.dataSource = params.dataSource;
      _this.toolkitInstance = params.toolkitInstance;
      _this.containerElement = _this.container;
      _this.containerId = _this.jsplumb.getId(_this.containerElement);
      _this.dragOptions = params.dragOptions || {};
      _this.refreshLayoutOnEdgeConnect = params.refreshLayoutOnEdgeConnect === true;
      _this.elementsDraggable = !(params.elementsDraggable === false);
      _this._suspendRendering = false;
      _this._refreshAutomatically = params.refreshAutomatically !== false;
      _this.enhancedView = params.enhancedView !== false;
      _this.dragGroupAssigner = params.assignDragGroup;
      _this._modelLeftAttribute = params.modelLeftAttribute || _this.toolkitInstance.modelLeftAttribute || LEFT$2;
      _this._modelTopAttribute = params.modelTopAttribute || _this.toolkitInstance.modelTopAttribute || TOP$2;
      _this._storePositionsInModel = params.storePositionsInModel !== false;

      _this.objectFilter = params.objectFilter || function (b) {
        return true;
      };

      _this.gridProfile = new GridProfile(params.grid);
      _this.magnetizeProfile = new MagnetizeProfile(params.magnetize, _this.gridProfile);
      _this._layout = Layouts.get(EmptyLayout.type, {
        adapter: new CanvasLayoutAdapter(_assertThisInitialized$7(_this)),
        toolkit: _this.toolkitInstance,
        container: params.container,
        options: {}
      });
      _this._storePositionsInModel = params.storePositionsInModel !== false;

      _this.jsplumb.bind(INTERCEPT_BEFORE_START_DETACH, _this.beforeStartDetach.bind(_assertThisInitialized$7(_this)));

      _this.jsplumb.bind(INTERCEPT_BEFORE_DETACH, _this.beforeDetach.bind(_assertThisInitialized$7(_this)));

      _this.jsplumb.bind(INTERCEPT_BEFORE_DRAG, _this.beforeDrag.bind(_assertThisInitialized$7(_this)));

      _this.jsplumb.bind(INTERCEPT_BEFORE_DROP, _this.beforeDrop.bind(_assertThisInitialized$7(_this))); // *************** events ********************************


      if (params.events) {
        for (var evt in params.events) {
          _this.bind(evt, params.events[evt]);
        }
      } // *************** /events ********************************
      // *************** interceptors ********************************


      if (params.interceptors) {
        for (var _int in params.interceptors) {
          _this.bind(_int, params.interceptors[_int]);
        }
      } // create a view.


      _this.setView(params.view); // configure edge drag/drop


      _this._setSelectors();

      _this._bindToJsPlumb();

      _this._bindToolkitEvents();

      _this.nodeRenderer = _this.createRenderer("node", _this.dataSource.getNodeId.bind(_this.dataSource), _this.dataSource.getNodeType.bind(_this.dataSource));
      _this.portRenderer = _this.createRenderer("port", _this.dataSource.getPortId.bind(_this.dataSource), _this.dataSource.getPortType.bind(_this.dataSource));
      _this.groupRenderer = _this.createRenderer("group", _this.dataSource.getNodeId.bind(_this.dataSource), _this.dataSource.getNodeType.bind(_this.dataSource));
      _this.id = params.id || uuid();
      _this.canvasElement = _this._createElement({
        position: Constants.relative,
        width: Constants.nominalSize,
        height: Constants.nominalSize,
        left: 0,
        top: 0,
        clazz: CLASS_SURFACE_CANVAS
      }, _this.containerElement);

      _this.jsplumb.setContainer(_this.canvasElement);

      if (_this.dragOptions.filter != null) {
        _this.jsplumb.addDragFilter(_this.dragOptions.filter, true);
      }

      if (_this.gridProfile.grid != null) {
        _this.jsplumb.setDragGrid(_this.gridProfile.grid);
      }

      _this.directRender = params.directRender === true;
      _this.wheelReverse = params.wheel && params.wheel.reverse === true;
      addClass(_this.containerElement, CLASS_SURFACE);

      if (_this.directRender) {
        addClass(_this.containerElement, CLASS_SURFACE_DIRECT);
      } // optionally set the jtk-surface-nopan class


      if (params.enablePan === false) {
        addClass(_this.containerElement, CLASS_SURFACE_NO_PAN);
      }

      var _canvasBind = function _canvasBind(evt, alias, alias2) {
        var cc = function cc(e) {
          var t = e.srcElement || e.target;

          if (t === _this.containerElement || t === _this.canvasElement) {
            var a = e.button === 2 && alias2 != null ? alias2 : alias;

            _this.fire(a, _assertThisInitialized$7(_this), e);
          }
        };

        _this.jsplumb.on(_this.containerElement, evt, cc);
      };

      _canvasBind(EVENT_TAP, EVENT_CANVAS_CLICK, EVENT_CONTEXTMENU);

      _canvasBind(EVENT_DBL_TAP, EVENT_CANVAS_DBL_CLICK);

      _this.zoomToFitOnLoad = params.zoomToFit === true;
      _this.panZoom = new PanZoom(_assertThisInitialized$7(_this), {
        viewport: _this.viewport,
        viewportElement: _this.containerElement,
        canvasElement: _this.canvasElement,
        consumeRightClick: params.consumeRightClick,
        idFunction: function idFunction(el) {
          return _this.jsplumb.getId(el);
        },
        panDistance: params.panDistance,
        directRender: _this.directRender,
        enablePan: !_this.directRender && params.enablePan !== false,
        wheel: _this._getWheelOptions(params),
        enableAnimation: params.enableAnimation,
        clamp: params.clamp,
        clampToBackground: params.clampToBackground,
        clampToBackgroundExtents: params.clampToBackgroundExtents,
        events: {
          pan: function pan(x, y, z, oldZoom, e) {
            _this.fire(EVENT_PAN, {
              x: x,
              y: y,
              zoom: z,
              oldZoom: oldZoom,
              event: e
            });
          },
          zoom: function zoom(x, y, z, oldZoom, e) {
            _this.jsplumb.setZoom(z);

            _this.fire(EVENT_ZOOM, {
              x: x,
              y: y,
              zoom: z,
              oldZoom: oldZoom,
              event: e
            });
          },
          mousedown: function mousedown() {
            _this.addClass(_this.containerElement, CLASS_SURFACE_PANNING);

            _this.addClass(document.body, CLASS_SELECT_DEFEAT);
          },
          mouseup: function mouseup() {
            _this.removeClass(_this.containerElement, CLASS_SURFACE_PANNING);

            _this.removeClass(document.body, CLASS_SELECT_DEFEAT);
          }
        },
        zoom: params.zoom,
        zoomRange: params.zoomRange
      });
      _this.autoExitSelectMode = params.autoExitSelectMode !== false;
      var pluginsToCreate = params.plugins || [];
      _this.plugins = [];
      forEach(pluginsToCreate, function (pluginSpec) {
        _this.addPlugin(pluginSpec);
      }); // ------ event binding
      // bind to relayout and tell the panzoom

      _this.bind(EVENT_RELAYOUT, function () {
        _this.panZoom.relayout(_this._layout._getExtents());
      }); // bind to noderemoved and tell the panzoom


      _this.bind(EVENT_NODE_REMOVED, function (p) {
        _this.panZoom.remove(p.el);
      }); // bind to groupremoved and tell the panzoom


      _this.bind(EVENT_GROUP_REMOVED$1, function (p) {
        _this.panZoom.remove(p.el);

        if (p.childrenRemoved === false) {
          for (var i = 0; i < p.children.length; i++) {
            var nodeEl = _this.jsplumb.getManagedElement(p.children[i].id);

            if (nodeEl) {
              _this.panZoom.restore(nodeEl);
            }
          }
        }
      });

      _this.jsplumb.bind(EVENT_DRAG_START, function (params) {
        if (_this.elementsDraggable && !_this.panZoom.isPinchZooming() && _this.mode !== SurfaceMode.DISABLED) {
          _this.toolkitInstance.openTransaction();

          _this.contentBounds = _this.panZoom.getBoundsInfo();
          addClass(_this.containerElement, CLASS_SURFACE_ELEMENT_DRAGGING);
          forEach(_this.containerElement.querySelectorAll("." + CLASS_MOST_RECENTLY_DRAGGED), function (el) {
            removeClass(el, CLASS_MOST_RECENTLY_DRAGGED);
          }); // get the vertex this element represents

          var vertex = _this.getModelObjectFromElement(params.el);

          _this.fire(EVENT_NODE_MOVE_START, {
            domEl: params.el,
            pos: getAbsolutePosition(params.el),
            elementId: _this.jsplumb.getId(params.el),
            originalPosition: params.originalPosition,
            vertex: vertex
          }); // return vertex as payload to the drag listener. this
          // will be passed as `payload` in the drag move and stop events.


          return {
            vertex: vertex
          };
        } else {
          return false;
        }
      });

      _this.jsplumb.bind(EVENT_DRAG_MOVE, function (params) {
        var jtkEl = params.el;
        var vertex = params.payload.vertex,
            dragInfo = {
          el: jtkEl,
          vertex: vertex,
          pos: params.pos,
          e: params.e,
          type: vertex.objectType,
          originalPosition: params.originalPosition,
          renderer: _assertThisInitialized$7(_this)
        };

        if (_this.magnetizeProfile.constant && !isNodeInsideAGroup(dragInfo.vertex) && !isNestedGroup(dragInfo.vertex)) {
          // without this cast to any, typescript infers a type of 'never' for dragInfo.vertex!
          _this._setMagnetizedPosition(dragInfo.vertex.id, dragInfo.pos.x, dragInfo.pos.y, true, _this._layout);
        }

        _this.fire(EVENT_NODE_MOVE, dragInfo);
      });

      _this.jsplumb.bind(EVENT_DRAG_STOP, function (params) {
        // a node/group drag has stopped. the payload may include a `dropGroup`, which indicates that the vertex was dragged into
        // a group. it may also include an `originalGroup`, which is the group the vertex was originally in, if any.
        try {
          var verticesToMagnetize = [];
          var verticesToSetDirectly = [];
          var groupsToResize = new Map();
          removeClass(_this.containerElement, CLASS_SURFACE_ELEMENT_DRAGGING);
          forEach(_this.containerElement.querySelectorAll("." + CLASS_MOST_RECENTLY_DRAGGED), function (el) {
            removeClass(el, CLASS_MOST_RECENTLY_DRAGGED);
          });
          forEach(params.elements, function (e) {
            addClass(e.el, CLASS_MOST_RECENTLY_DRAGGED);
            var jtkEl = e.el;

            var vertex = _this.getModelObjectFromElement(e.el);

            if (vertex != null && (isNode(vertex) || isGroup(vertex))) {
              var dragInfo = {
                el: jtkEl,
                vertex: vertex,
                pos: e.pos,
                e: params.e,
                type: vertex.objectType,
                originalPosition: e.originalPos,
                renderer: _assertThisInitialized$7(_this)
              };
              var isNestedElement = isNodeInsideAGroup(dragInfo.vertex) || isNestedGroup(dragInfo.vertex);
              e.redrawResult.c.forEach(function (c) {
                var edge = c.edge;

                if (edge != null && edge.geometry != null) {
                  _this.dataSource.setEdgeGeometry(edge, c.connector.exportGeometry(), _assertThisInitialized$7(_this));
                }
              });
              var layoutToUse = isNestedElement ? _this._layoutMap.get(dragInfo.vertex.group.id) : _this._layout;
              var lp = layoutToUse.getPosition(dragInfo.vertex.id);
              dragInfo.originalPosition = {
                x: lp.x,
                y: lp.y
              };

              if (e.dropGroup == null) {
                // we magnetize only if:
                // no 'dropGroup' was supplied in the callback, ie. the node/group was not dropped on a group
                // the node/group is not inside a group
                // we have `afterDrag` turned on in the magnetize profile
                if (_this.magnetizeProfile.afterDrag && !isNestedElement) {
                  verticesToMagnetize.push({
                    id: dragInfo.vertex.id,
                    x: dragInfo.pos.x,
                    y: dragInfo.pos.y
                  });
                } else {
                  verticesToSetDirectly.push({
                    id: dragInfo.vertex.id,
                    x: dragInfo.pos.x,
                    y: dragInfo.pos.y,
                    layout: layoutToUse
                  });

                  if (isNestedElement) {
                    var g = dragInfo.vertex.group;

                    var groupDef = _this.view.getGroupDefinition(_this.dataSource.getNodeType(g.data));

                    groupsToResize.set(g.id, [g, groupDef]);
                  }
                }
              }
            }
          }); // position directly set elements

          forEach(verticesToSetDirectly, function (p) {
            _this._setDirectPosition(p.id, p.x, p.y, false, p.layout);
          }); // auto size groups

          groupsToResize.forEach(function (g) {
            _this._autoSizeAGroup(g[0], g[1], null, false);
          }); // position magnetized elements.

          _this._setMagnetizedPositions(verticesToMagnetize, !_this.magnetizeProfile.repositionDraggedElement, true, _this._layout);
        } catch (e) {
          log("Could not process dragged vertex", e);
        } finally {
          _this.toolkitInstance.commitTransaction();
        }
      });

      if (params.layout) {
        _this.setLayout(params.layout, true);
      } // load existing data. we suspend rendering etc first. we do that here as this is the only call site for
      // loadExistingData, and that method is overridden by a subclass, so we avoid having to repeat the housekeeping code.


      _this.dataSource.setSuspendGraph(true); // // suspend drawing until its all loaded


      _this._loadStartFn();

      var somethingLoaded = _this._loadExistingData(params);

      _this.dataSource.setSuspendGraph(false);

      _this._loadEndFn(!somethingLoaded);

      return _this;
    }

    _createClass$c(Surface, [{
      key: "_getWheelOptions",
      value:
      /**
       * Defaults to false. When true, if a port is added to a vertex programmatically, the surface treats the vertex's DOM
       * element as the DOM element for the port if it cannot find a specific element for the port.
       */
      // TODO its dubious whether we need this list. the only time it is accessed is when doing a full cleanup, and the template renderer is
      // current bounds as tracked by the panzoom
      // current mode.
      function _getWheelOptions(params) {
        var zoomEnabled = params.wheel != null ? params.wheel.zoom !== false : true;
        var f = params.wheel ? params.wheel.filter : null;
        return {
          filter: f ? function (e) {
            var t = e.srcElement || e.target;
            return !matchesSelector$1(t, f);
          } : null,
          reverse: params.wheel != null ? params.wheel.reverse === true : false,
          pan: params.wheel != null ? params.wheel.pan === true : false,
          zoom: !this.directRender && zoomEnabled,
          useMetaKey: params.wheel != null ? params.wheel.useMetaKey === true : false,
          axis: params.wheel ? params.wheel.axis : 'both'
        };
      }
    }, {
      key: "_updateMovedElements",
      value: function _updateMovedElements(movedElements, event) {
        for (var id in movedElements) {
          var el = this.jsplumb.getManagedElement(id);
          this.setAbsolutePosition(el, movedElements[id].current);
          this.repaint(el);
          var obj = this.toolkitInstance.getVertex(id);
          var moveParams = {
            el: el,
            vertex: obj,
            e: event,
            type: obj.objectType,
            renderer: this,
            pos: movedElements[id].current,
            originalPosition: movedElements[id].original
          };

          if (this._storePositionsInModel !== false) {
            var originalData = extend({}, obj.data);
            this.storePositionInModel({
              obj: obj,
              id: id,
              leftAttribute: this._modelLeftAttribute,
              topAttribute: this._modelTopAttribute
            });
            var updates = {};
            updates[this._modelLeftAttribute] = movedElements[id].current.x;
            updates[this._modelTopAttribute] = movedElements[id].current.y;

            if (isNode(obj)) {
              this.toolkitInstance.fire(EVENT_NODE_UPDATED, {
                vertex: obj,
                updates: updates,
                originalData: originalData,
                reason: UPDATE_NODE_REASON_MOVED
              }, null);
            } else if (isGroup(obj)) {
              this.toolkitInstance.fire(EVENT_GROUP_UPDATED, {
                vertex: obj,
                updates: updates,
                originalData: originalData,
                reason: UPDATE_NODE_REASON_MOVED
              }, null);
            }
          }

          if (isNode(obj)) {
            this.fire(EVENT_NODE_MOVE_END, moveParams);
          } else if (isGroup(obj)) {
            this.fire(EVENT_GROUP_MOVE_END, moveParams);
          }
        }
      }
    }, {
      key: "_setMagnetizedPosition",
      value: function _setMagnetizedPosition(id, x, y, dontMoveFocusVertex, layoutToUse) {
        var originalPosition = extend({}, this._layout.getPosition(id));
        var movedElements = {};
        movedElements[id] = {
          original: originalPosition,
          current: {
            x: x,
            y: y
          }
        };
        extend(movedElements, layoutToUse.setMagnetizedPosition(id, x, y, dontMoveFocusVertex, this.gridProfile.grid)); // if the element did not move at all dont report that it has

        if (movedElements[id].current.x === movedElements[id].original.x && movedElements[id].current.y === movedElements[id].original.y) {
          delete movedElements[id];
        } // if not moving the focus vertex we have to set its position in the viewport, as the magnetizer will not
        // have done that.


        if (dontMoveFocusVertex === true) {
          this.setAbsolutePosition(this.jsplumb.getManagedElement(id), {
            x: x,
            y: y
          });
        } else {
          // if moving focus vertex the actual initial position of the element is the one before any magnetizer
          // activity, so we reset it.
          movedElements[id].original = originalPosition;
        }

        this._updateMovedElements(movedElements);

        return movedElements;
      }
    }, {
      key: "_setMagnetizedPositions",
      value: function _setMagnetizedPositions(entries, dontMoveFocusVertex, updateMove, layoutToUse) {
        var _this2 = this;

        var movedElements = {};

        if (entries.length > 0) {
          forEach(entries, function (entry) {
            extend(movedElements, _this2._setMagnetizedPosition(entry.id, entry.x, entry.y, !_this2.magnetizeProfile.repositionDraggedElement, layoutToUse));
          });
        }

        return movedElements;
      }
    }, {
      key: "_setDirectPosition",
      value: function _setDirectPosition(id, x, y, doNotCalculateExtents, layout) {
        var movedElements = layout.setPosition(id, x, y, doNotCalculateExtents);

        this._updateMovedElements(movedElements);
      }
    }, {
      key: "getNodes",
      value: function getNodes() {
        return this.vertexList.filter(isNode);
      }
    }, {
      key: "getGroups",
      value: function getGroups() {
        return this.vertexList.filter(isGroup);
      }
      /**
       * Sets the current view for this renderer.
       * @param view View to set.
       */

    }, {
      key: "setView",
      value: function setView(view) {
        // we merge in the model that has optionally been registered on the toolkit
        // when we do this.  this allows us to register data model stuff on the toolkit (such as max
        // connections etc), and render level stuff on this object.
        this.view = new BrowserUIModel(this.toolkitInstance, this.dataSource.getModel(), view, this.jsplumb);
      }
    }, {
      key: "_ensureTemplate",
      value: function _ensureTemplate(def) {
        if (def != null && def.template && def.templateId == null) {
          if (this.templateRenderer.addTemplate) {
            def.templateId = uuid();
            this.templateRenderer.addTemplate(def.templateId, def.template);
          }
        }

        return def;
      }
    }, {
      key: "getGroupDefinition",
      value: function getGroupDefinition(group) {
        return this._ensureTemplate(this.view.getGroupDefinition(this.dataSource.getNodeType(group.data)));
      }
    }, {
      key: "getPortDefinition",
      value: function getPortDefinition(port) {
        return this._ensureTemplate(this.view.getPortDefinition(this.dataSource.getPortType(port.data)));
      }
    }, {
      key: "getNodeDefinition",
      value: function getNodeDefinition(node) {
        return this._ensureTemplate(this.view.getNodeDefinition(this.dataSource.getNodeType(node.data)));
      }
      /**
       * For the given element, acting as either a source or target for a drag, find the related model information - the
       * specific model object, if found (may not yet have been created in the case of a port), and the related
       * type definition from the view.
       * @param el
       * @param asSource
       * @private
       */

    }, {
      key: "_getModelInfoForDragElement",
      value: function _getModelInfoForDragElement(el, asSource) {
        var declaredPortType = null;
        var actualPortType = null;
        var declaredPortId = null;
        var parentDOMElement = findParent(el, att(ATTRIBUTE_MANAGED), this.jsplumb.getContainer(), true); // find the related model object.

        var modelObject = this.getModelObjectFromElement(parentDOMElement); // ensure we have a model object to work with

        if (modelObject != null) {
          // if it's a port, get its vertex parent. otherwise it's the vertex we want.
          var vertex = isPort(modelObject) ? modelObject.getParent() : modelObject; // always return at least an empty type.

          var modelObjectType = {}; // if modelObject is not a port already, check to see if the element declared a port id, then try to get that port.

          if (!isPort(modelObject)) {
            // list of attributes to check to derive the id, if any, of the port this element refers to.
            var portIdAttributes = asSource ? [ATTRIBUTE_JTK_SOURCE_PORT, ATTRIBUTE_JTK_SOURCE_PORT_ID] : [ATTRIBUTE_JTK_TARGET_PORT, ATTRIBUTE_JTK_TARGET_PORT_ID]; // see if the element refers to a port id, or if it just points to the main vertex

            declaredPortId = el.getAttribute(portIdAttributes[0]) || el.getAttribute(portIdAttributes[1]) || el.getAttribute(ATTRIBUTE_JTK_PORT) || el.getAttribute(ATTRIBUTE_JTK_PORT_ID); // if a port if was defined, try to get that port. fall back to the vertex otherwise.

            if (declaredPortId != null) {
              modelObject = modelObject.getPort(declaredPortId) || modelObject;
            }
          }

          if (isPort(modelObject)) {
            declaredPortId = modelObject.id;
            actualPortType = this.toolkitInstance.getPortType(modelObject);
          } // if the element has declared a port type, we use that to get the typedef


          var portTypeAttribute = asSource ? ATTRIBUTE_JTK_SOURCE_PORT_TYPE : ATTRIBUTE_JTK_TARGET_PORT_TYPE;
          declaredPortType = el.getAttribute(portTypeAttribute) || el.getAttribute(ATTRIBUTE_JTK_PORT_TYPE);

          if (declaredPortType != null) {
            modelObjectType = this.view.getPortDefinition(declaredPortType);
          } else {
            // finally, get the related type definition for our model object.
            modelObjectType = this.view.getTypeDefinition(modelObject);
          }

          return {
            obj: modelObject,
            vertex: vertex,
            typeDef: modelObjectType,
            portType: declaredPortType || actualPortType,
            portId: declaredPortId
          };
        } else {
          return null;
        }
      } //
      // TODO there seems to be considerable overlap between the responsibilities of this method and of the _extractEndpointDefinitionFromValueSource
      // method. One subtle difference is in the way the two methods derive a portId: this method first checks for port attributes that have the
      // `-id` suffix,  `_extractEndpointDefinitionFromValueSource` ignores those variants. The `-id` suffix variants are used to say "this element
      // does not itself have this id, you'll use it for anything created from this element", whereas the non `-id` suffix variants indicate that
      // the element itself has the given id. That's why this method uses the `-id` variants by preference, because this method is used when
      // dragging starts, and the drag may be on a totally different element from where the connection will end up.
      //

    }, {
      key: "_setSelectors",
      value: function _setSelectors() {
        var _this3 = this;

        var canAcceptConnection = function canAcceptConnection(el, e, source) {
          // el is a DOM element that declares one or more attributes containing information about dragging - whether it is a source,
          // or a target, and whether it represents a port, and if so, what type, etc. This method is required to identify the
          // specific model object this dom element refers to, then check if any `maxConnections` is specified for that model object.
          // if so, we reject a new connection if the given model object is full.\
          var info = _this3._getModelInfoForDragElement(el, source);

          if (info == null) {
            return false;
          } else {
            // if no model object, or maxConnections not defined, or maxConnections not unlimited, check
            // that the allowed number hasnt been exceeded.  This does not, of course, support maxConnections:0.
            if (info.obj != null && info.typeDef.maxConnections != null && info.typeDef.maxConnections !== -1) {
              return info.obj.getEdges().length < info.typeDef.maxConnections;
            } else {
              return true;
            }
          }
        };

        var _parameterExtractor = function parameterExtractor(eventTarget, source, target, event) {
          var vs = _extractEndpointDefinitionFromValueSource(new AttributeExtractor(eventTarget)); //
          // The port id for the associated element can be derived in a number of ways. In order, we test:
          //
          // 1. the `data-jtk-port-id` attribute
          // 2. if a source, the `data-jtk-source-port-id` attribute, or if a target, `data-jtk-target-port-id` attribute
          // 3. the `data-jtk-port` attribute
          // 4. if a source, the `data-jtk-source-port` attribute, or if a target, `data-jtk-target-port` attribute
          //
          // const portId = eventTarget.getAttribute(ATTRIBUTE_JTK_PORT_ID) ||
          //     (source ? eventTarget.getAttribute(ATTRIBUTE_JTK_SOURCE_PORT_ID) : target ? eventTarget.getAttribute(ATTRIBUTE_JTK_TARGET_PORT_ID) : null) ||
          //     vs.portId ||
          //     (source ? eventTarget.getAttribute(ATTRIBUTE_JTK_SOURCE_PORT) : target ? eventTarget.getAttribute(ATTRIBUTE_JTK_TARGET_PORT) : null)
          //
          // port type is derived with these rules:
          //
          // 1. if a source, try to get the `data-jtk-source-port-type` attribute, or if a target, try to get the `data-jtk-target-port-type` attribute
          // 2. try to get the `data-jtk-port-type` attribute
          //
          // this is another difference with `_extractEndpointDefinitionFromValueSource` - in that method we only check `data-jtk-port-type`.
          //
          // let portType =
          //     (source ? eventTarget.getAttribute(ATTRIBUTE_JTK_SOURCE_PORT_TYPE) : target ? eventTarget.getAttribute(ATTRIBUTE_JTK_TARGET_PORT_TYPE) : null)
          //     || vs.portType


          var edgeType = vs.edgeType;
          var parameters = {
            edgeType: edgeType
          };
          var p = filterNull({
            edgeType: edgeType
          });

          var dragInfo = _this3._getModelInfoForDragElement(eventTarget, source);

          if (dragInfo != null) {
            var _modelObject = dragInfo.obj || dragInfo.vertex;

            parameters.portId = dragInfo.portId;
            parameters.portType = dragInfo.portType;
            parameters.vertexId = dragInfo.vertex.id;
            extend(p, dragInfo.typeDef);

            if (dragInfo.typeDef.anchorPositionFinder != null) {
              var elxy = getPositionOnElement(event, eventTarget, _this3.jsplumb.currentZoom);
              var maybeAnchor = dragInfo.typeDef.anchorPositionFinder(eventTarget, elxy, dragInfo.vertex, dragInfo.typeDef, event);

              if (maybeAnchor != null) {
                p.anchor = maybeAnchor;
              }
            } // allow for dynamic values in the definition (ie 'edgeType:"${type}"' - the value for edgeType comes from the model object)


            if (_modelObject != null) {
              p.data = _modelObject.data;
            }
          }

          p.parameters = filterNull(parameters); // if an anchor was encoded in the element, it overrides any other anchor spec
          // (such as we may have derived from an edge or port type)

          if (vs.anchor) {
            p.anchor = vs.anchor;
          }

          return p;
        };

        this.jsplumb.addSourceSelector(attWithValue(ATTRIBUTE_JTK_SOURCE, TRUE$1), {
          parameterExtractor: function parameterExtractor(el, eventTarget, event) {
            return _parameterExtractor(eventTarget, true, false, event);
          },
          parentSelector: att(ATTRIBUTE_JTK_PORT, ATTRIBUTE_JTK_SOURCE_PORT, ATTRIBUTE_JTK_TARGET_PORT),
          canAcceptNewConnection: function canAcceptNewConnection(el, e) {
            return canAcceptConnection(el, e, true);
          }
        });
        this.jsplumb.addTargetSelector(attWithValue(ATTRIBUTE_JTK_TARGET, TRUE$1), {
          parameterExtractor: function parameterExtractor(el, eventTarget, event) {
            return _parameterExtractor(el, false, true, event);
          },
          parentSelector: att(ATTRIBUTE_JTK_PORT, ATTRIBUTE_JTK_SOURCE_PORT, ATTRIBUTE_JTK_TARGET_PORT),
          canAcceptNewConnection: function canAcceptNewConnection(el, e) {
            return canAcceptConnection(el, e, false);
          }
        });
      }
      /**
       * Add a plugin to the Surface. You can provide a type parameter to this method to avoid having to cast the return value, if you need to
       * retain a reference to the plugin.
       * @param pluginSpec
       */

    }, {
      key: "addPlugin",
      value: function addPlugin(pluginSpec) {
        var pType = isString(pluginSpec) ? pluginSpec : pluginSpec.type;
        var pParams = isString(pluginSpec) ? {} : pluginSpec.options || {};
        pParams.viewport = this.viewport;
        var p = SurfacePlugins.get(pType);

        if (p != null) {
          // if ((p as ModalSurfacePlugin).getModeId()) {
          //     this.modeAssocations.set((p as ModalSurfacePlugin).getModeId(), p as ModalSurfacePlugin);
          // }
          p.initialise(this, pParams);
          this.plugins.push(p);
          this.pluginMap.set(pType, p);
          return p;
        }
      }
      /**
       * Gets the plugin registered for the given type, null if nothing matching found.
       * @param pluginType
       */

    }, {
      key: "getPlugin",
      value: function getPlugin(pluginType) {
        return this.pluginMap.get(pluginType);
      }
      /**
       * Sets whether hover events are currently suspended. Used by some plugins.
       * @param s
       */

    }, {
      key: "setHoverSuspended",
      value: function setHoverSuspended(s) {
        this.jsplumb.hoverSuspended = s;
      } //
      // TODO extract the select mode from this - it's now in the lasso plugin.

      /**
       * Sets the current mode for the surface.
       * @param mode
       * @param doNotClearSelection Defaults to false - when true, a mode change will not first cause the selection in the
       * underlying Toolkit to be cleared.
       */

    }, {
      key: "setMode",
      value: function setMode(mode, doNotClearSelection) {
        var _this4 = this,
            _modes;

        var modes = (_modes = {}, _defineProperty$b(_modes, SurfaceMode.PAN, function () {
          _this4.panZoom.setEnabled(true);
        }), _defineProperty$b(_modes, SurfaceMode.SELECT, function () {
          _this4.jsplumb.clearDragSelection();

          _this4.panZoom.setEnabled(false);
        }), _defineProperty$b(_modes, SurfaceMode.DISABLED, function () {
          _this4.jsplumb.clearDragSelection();

          _this4.panZoom.setEnabled(false);
        }), _modes);

        if (modes[mode]) {
          this.mode = mode;
          modes[mode]();

          if (mode === Constants.select && !doNotClearSelection) {
            // clear existing selection
            this.toolkitInstance.clearSelection();
          }

          this.fire(EVENT_SURFACE_MODE_CHANGED, mode);
        } else {
          throw new TypeError("Surface: unknown mode '" + mode + "'");
        }
      }
    }, {
      key: "_selectEdges",
      value: function _selectEdges(params, edgeSelectFunction) {
        var p = extend({}, params);
        p.source = this.getObjectInfo(params.source).obj;
        p.target = this.getObjectInfo(params.target).obj;
        p.element = this.getObjectInfo(params.element).obj;
        var edges = this.toolkitInstance[edgeSelectFunction](p),
            connections = this.getConnectionsForEdges(edges);
        return this.jsplumb.select({
          connections: connections
        });
      }
      /**
       * Selects a set of edges. If you supply a DOM element for any of the arguments here, the underlying graph object - a Node or a Port - will be
       * determined, and the edges for that object will be retrieved.  Note that for a Port this method does the same thing as
       * `selectAllEdges`, but for a Node, which may have Ports registered on it, this method will retrieve only the Edges directly
       * registered on the Node itself.  You may need to use `selectAllEdges` if you want everything from some Node.
       * @param params Selection parameters
       * @param params.source  Source node, as a Node, a DOM element, a selector, or a String (including support for wildcard '*')
       * @param params.target  Target node, as a Node, a DOM element, a selector, or a String (including support for wildcard '*')
       * @param params.element Source or target node, as a Node, a DOM element, a selector, or a String (including support for wildcard '*')
       */

    }, {
      key: "selectEdges",
      value: function selectEdges(params) {
        return this._selectEdges(params, "getEdges");
      }
      /**
       * Selects a set of Edges.  Parameters are the same as for selectEdges; the difference here is that when you're working with
       * Vertices, this method will return all of the vertex's Edges as well as those of all the Ports registered on the Vertex.
       * @param params Selection parameters
       * @param params.source  Source node, as a Node/Group, a DOM element, or a string (including support for wildcard '*')
       * @param params.target  Target node, as a Node/Group, a DOM element, or a string (including support for wildcard '*')
       * @param params.element Source or target node, as a Node/Group, a DOM element, or a string (including support for wildcard '*')
       *
       */

    }, {
      key: "selectAllEdges",
      value: function selectAllEdges(params) {
        return this._selectEdges(params, "getAllEdges");
      }
      /**
       * Create a DOM element. Used internally.
       * @param parent
       * @internal
       */

    }, {
      key: "_createElement",
      value: function _createElement(params, parent) {
        var style = {
          width: params.width,
          height: params.height,
          position: params.position || Constants.absolute
        };
        var atts = {};

        if (params.display != null) {
          style.display = params.display;
        }

        if (params.id != null) {
          atts.id = params.id;
        }

        if (params.top != null) {
          style.top = params.top + "px";
        }

        if (params.left != null) {
          style.left = params.left + "px";
        }

        if (params.right != null) {
          style.right = params.right + "px";
        }

        if (params.bottom != null) {
          style.bottom = params.bottom + "px";
        }

        var d = createElement(params.type || Constants.div, style, params.clazz, atts);

        if (parent != null) {
          this.jsplumb._appendElement(d, parent); // this too will be handled by jsPlumb when not in a browser.

        }

        return d;
      } // wont actually fire an event if there is no delta unless you specify `force:true`

    }, {
      key: "_fireNodeMovedEvent",
      value: function _fireNodeMovedEvent(vertex, x, y, previousX, previousY, force) {
        if (force || x !== previousX || y !== previousY) {
          var info = this.getObjectInfo(vertex);

          if (info.el) {
            this.fire(EVENT_NODE_MOVE_END, {
              el: info.el,
              id: info.id,
              pos: {
                x: x,
                y: y
              },
              vertex: info.obj,
              e: null,
              type: info.obj.objectType,
              originalPosition: {
                x: previousX,
                y: previousY
              },
              renderer: this
            });
          }
        }
      }
      /**
       * Gets the offset for the given DOM element.
       * @param el
       */

    }, {
      key: "getOffset",
      value: function getOffset(el) {
        return this.jsplumb.getOffset(el);
      }
      /**
       * Sets the position of the given vertex, snapping it to a grid and applying the magnetizer, if necessary. If the
       * given vertex is the child of some group then the group's layout is updated with the new position (and no
       * magnetizer is run); otherwise the main layout is updated with the new position.
       *
       * Other elements may be moved as a result of this method due to the magnetizer potentially running (Although if it runs,
       * it is not guaranteed to move other elements). For each moved element, a node moved event is fired. All of the
       * move events are contained within a single transaction on the Toolkit so if you undo this operation, all of the
       * affected elements will return to where they were prior to the move.
       *
       * @param vertex - The vertex to set the position for
       * @param x - X position to set
       * @param y - Y position to set
       */

    }, {
      key: "setPosition",
      value: function setPosition(vertex, x, y) {
        this.toolkitInstance.openTransaction(APPEND_TO_CURRENT);

        try {
          var movedElements = this._setPosition({
            vertex: vertex,
            x: x,
            y: y,
            doRevalidate: true
          });

          if (this.gridProfile.snap) {
            extend(movedElements, this.snapToGrid(vertex));
          }

          var info = this.getObjectInfo(vertex);

          if (info.obj) {
            var pos = movedElements[info.id];

            this._fireNodeMovedEvent(vertex, pos.current.x, pos.current.y, pos.original.x, pos.original.y);
          }
        } catch (e) {
          log("Exception thrown when setting position", e);
        } finally {
          this.toolkitInstance.commitTransaction();
        }
      }
      /**
       * Set the absolute position of the given element. Does not update the pan/zoom or any plugins - this is meant to be
       * used as a helper method for positioning elements not directly under the Surface's control.
       * @param el
       * @param p
       */

    }, {
      key: "setAbsolutePosition",
      value: function setAbsolutePosition$1(el, p) {
        setAbsolutePosition(el, p.x, p.y);
      }
      /**
       * Adds a class to the DOM element represented by `el`, which can be a Selection, or an instance of many
       * different types - see the `SupportsClassManipulation` interface for a complete list.
       * @param el
       * @param clazz
       */

    }, {
      key: "addClass",
      value: function addClass(el, clazz) {
        var _this5 = this;

        if (el.constructor === Selection) {
          el.eachVertex(function (idx, v) {
            return _this5.addClass(v, clazz);
          });
          el.eachEdge(function (idx, e) {
            return _this5.addClass(e, clazz);
          });
        } else {
          this._classOperation(el, clazz, this.jsplumb.addClass);
        }
      }
    }, {
      key: "_classOperation",
      value: function _classOperation(el, clazz, fn) {
        var _this6 = this;

        var _one = function _one(el) {
          var info = _this6.getObjectInfo(el);

          if (info.el) {
            fn(info.el, clazz);
          } else if (isDOMElement(el)) {
            fn(el, clazz);
          }
        };

        if (el != null) {
          if (isNodeList(el)) {
            fn(el, clazz);
          } else if (isArrayLike(el)) {
            forEach(el, function (_el) {
              return _one(_el);
            });
          } else {
            _one(el);
          }
        }
      }
      /**
       * Removes a class from the DOM element represented by `el`, which can be a Selection, or an instance of many
       * different types - see the `SupportsClassManipulation` interface for a complete list.
       * @param el
       * @param clazz
       */

    }, {
      key: "removeClass",
      value: function removeClass(el, clazz) {
        var _this7 = this;

        if (el.constructor === Selection) {
          el.eachVertex(function (idx, v) {
            return _this7.removeClass(v, clazz);
          });
          el.eachEdge(function (idx, e) {
            return _this7.removeClass(e, clazz);
          });
        } else {
          this._classOperation(el, clazz, this.jsplumb.removeClass);
        }
      }
      /**
       * Toggles a class on the DOM element represented by `el`, which can be a Selection, or an instance of many
       * different types - see the `SupportsClassManipulation` interface for a complete list.
       * @param el
       * @param clazz
       */

    }, {
      key: "toggleClass",
      value: function toggleClass(el, clazz) {
        var _this8 = this;

        if (el.constructor === Selection) {
          el.eachVertex(function (idx, v) {
            return _this8.toggleClass(v, clazz);
          });
          el.eachEdge(function (idx, e) {
            return _this8.toggleClass(e, clazz);
          });
        } else {
          this._classOperation(el, clazz, this.jsplumb.toggleClass);
        }
      }
      /**
       * Returns whether the DOM element represented by `el` - which can be an Edge, Connection, Node, Group, DOM element, or
       * ID of some model object - has the given class.
       * @param el
       * @param clazz
       */

    }, {
      key: "hasClass",
      value: function hasClass(el, clazz) {
        if (el != null) {
          var info = this.getObjectInfo(el);

          if (info.el) {
            return this.jsplumb.hasClass(info.el, clazz);
          } else {
            if (isDOMElement(el)) {
              return this.jsplumb.hasClass(el, clazz);
            } else {
              return false;
            }
          }
        }
      }
      /**
       * Bind an event listener to the given DOM Element. This is a utility function that can be used on any element in the DOM, not just
       * things rendered by the Toolkit.
       * @param el Element, or elements, to bind the event listener to.
       * @param event Name of the event to bind to
       * @param callbackOrSelector Either a callback, or if 4 args are given, this is a selector identifying some element(s) within the given element.
       * @param callback Event callback.
       */

    }, {
      key: "on",
      value: function on(el, event, callbackOrSelector, callback) {
        this.jsplumb.on(el, event, callbackOrSelector, callback);
      }
      /**
       * Unbind an event listener from the given DOM Element. This is a utility function that can be used on any element in the DOM, not just
       * things rendered by the Toolkit.
       * @param el Element, or elements, from which to remove the event binding.
       * @param event Name of the event to unbind
       * @param handler The function to unbind
       */

    }, {
      key: "off",
      value: function off(el, event, handler) {
        var fnToUnbind = handler.__tkWrapper || handler;
        this.jsplumb.off(el, event, fnToUnbind);
      }
      /**
       * Binds to a mouse event occurring on a given model object. This is a wrapper around the `on` event binding method, which
       * searches for an associated model object for the given event. For instance, you might have a node template that has a button inside of it
       * that you want to respond to. When the button is clicked you want to know the node associated with the button. This method provides that.
       * It is possible to find the associated model object yourself, via the `getObjectInfo` method of the Surface, called with the event's target,
       * but this method does that for you.
       *
       * You can, optionally, provide a type hint to this method in order to fix the type of the returned model object, but note that this is erased at
       * runtime and the type of the returned object is not guaranteed by the surface.
       *
       * This method binds a delegated event handler on the container element used by the surface. You do not need to provide an element to which to bind; you
       * just need to provide an appropriate selector
       *
       * @param event Name of the event to bind to.
       * @param selector CSS3 selector that identifies children of a vertex DOM element on which the event handler should be bound.
       * @param callback Function to call when the event is fired.
       */

    }, {
      key: "bindModelEvent",
      value: function bindModelEvent(event, selector, callback) {
        var _this9 = this;

        // TODO this could be done somewhere "higher up" - there is a click handler on the container already, right? so
        // why not just add selectors to it from this method?
        var wrapper = function wrapper(event, target) {
          var modelInfo = _this9.getObjectInfo(target);

          if (modelInfo.obj != null) {
            callback(event, target, modelInfo);
          }
        };

        callback.__tkWrapper = wrapper;
        this.jsplumb.on(this.canvasElement, event, selector, wrapper);
      }
      /**
       * Unbinds a listener for a model event.
       * @param event Name of the event to unbind.
       * @param handler Function to unbind.
       */

    }, {
      key: "unbindModelEvent",
      value: function unbindModelEvent(event, handler) {
        if (handler.__tkWrapper != null) {
          this.jsplumb.off(this.canvasElement, event, handler.__tkWrapper);
        }
      }
      /**
       * Gets the origin and size of the DOM element representing a Vertex that is being managed by the Surface. Origin
       * is reported in pixels, relative to the parent container of the given Vertex: for a Vertex inside a group, the parent
       * container is group's DOM element (or the group's DOM element's internal parent for children); for a Vertex that is at
       * the root level of the dataset, the container is the canvas.
       *
       * @param el Vertex id, element, or Vertex to get position for.
       * @param relativeToCanvasRoot - Defaults to false, meaning the behaviour is as described above. If true, then all
       * values are reported with respect to the canvas origin. This flag is used, for instance, in the copy/paste module,
       * for determining the canvas offset for some node being copied out of a group into the root of the dataset.
       * @returns A RectangleXY if element was found, otherwise null.
       * @public
       */

    }, {
      key: "getCoordinates",
      value: function getCoordinates(el, relativeToCanvasRoot) {
        if (this._layout) {
          var info = this.getObjectInfo(el);

          if (info.obj) {
            var s = this.jsplumb.getSize(info.el);
            var parentGroup = isNodeInsideAGroup(info.obj) || isNestedGroup(info.obj) ? info.obj.group : null;
            var layout = parentGroup != null ? this._layoutMap.get(parentGroup.id) : this._layout;

            var _p = layout.getPosition(info.id),
                out = {
              x: _p.x,
              y: _p.y
            };

            if (relativeToCanvasRoot && parentGroup != null) {
              var groupEl = this.getRenderedElement(parentGroup),
                  groupOffset = this.jsplumb.getOffset(groupEl),
                  maybeContentArea = groupEl.querySelector(SELECTOR_GROUP_CONTAINER);
              out.x += groupOffset.x;
              out.y += groupOffset.y;

              if (maybeContentArea != null) {
                var mrbr = maybeContentArea.getBoundingClientRect(),
                    gbr = groupEl.getBoundingClientRect();
                out.x += mrbr.left - gbr.left;
                out.y += mrbr.top - gbr.top;
              }
            }

            return {
              x: out.x,
              y: out.y,
              w: s.w,
              h: s.h
            };
          } else {
            return {
              x: 0,
              y: 0,
              w: 0,
              h: 0
            };
          }
        }
      }
      /**
       * Snaps one or all vertices to the current grid or to the grid provided to this method.
       * @param el ID of vertex, Vertex, or DOM element representing a Vertex.
       * @param grid Optional grid to snap to. If not provided, the Surface will use the `grid` passed in to its constructor. If that is
       * also null, nothing will be snapped.
       */

    }, {
      key: "snapToGrid",
      value: function snapToGrid(el, grid) {
        grid = grid || this.gridProfile.grid;
        var elementId;

        if (grid) {
          if (el != null) {
            var info = this.getObjectInfo(el);

            if (info.obj) {
              elementId = info.obj.id;
            }
          }

          var result = this._layout.snapToGrid(grid, elementId);

          this._updateMovedElements(result);

          return result;
        }
      }
      /**
       * Appends an element to the viewport such that it is zoomed with everything else, but constrains pan
       * in one or both axes so that the element remains fixed with respect to the viewport origin.
       * @param el The DOM element to append.
       * @param constraints Flags to indicate optional constraint to each axis.
       * @param pos Location of the element's origin.
       */

    }, {
      key: "fixElement",
      value: function fixElement(el, constraints, pos) {
        this.panZoom.fixElement(el, constraints, pos);
      }
      /**
       * Appends an element to the viewport so that it floats above the content that is being zoomed and panned.
       * The element will have `position:absolute` set on it. You can float any element you like, but note that the
       * responsibility for setting an appropriate z index is yours.
       * @param el Element to float.
       * @param pos Position to float the element at.
       */

    }, {
      key: "floatElement",
      value: function floatElement(el, pos) {
        this.panZoom.floatElement(el, pos);
      }
      /**
       * Zooms the display so that all the tracked elements fit inside the viewport. This method will also,
       * by default, increase the zoom if necessary - meaning the default behaviour is to adjust the zoom so that
       * the content fills the viewport. You can suppress zoom increase by setting `doNotZoomIfVisible:true` on the
       * parameters to this method.
       * @param params.padding Optional padding to leave around all elements. Defaults to 0.
       * @param params.fill Amount of the viewport to fill. By default, this method will zoom so that the content is 0.9 times the size of the viewport.
       * Aesthetically this makes for a more pleasing result than filling the viewport entirely.
       * @param params.onComplete Optional function to call on operation complete (centering may be animated).
       * @param params.onStep Optional function to call on operation step (centering may be animated).
       * @param params.doNotAnimate By default, the centering content step does not use animation. This is due to this method being used most often to initially setup a UI.
       * @param params.doNotZoomIfVisible Defaults to false. If true, no action is taken if the content is currently all visible.
       */

    }, {
      key: "zoomToFit",
      value: function zoomToFit(params) {
        this.panZoom.zoomToFit(params);
      }
      /**
       * Zooms the display so that all the tracked elements fit inside the viewport, but does not make any adjustments
       * to zoom if all the elements are currently visible (it still does center the content though).
       * @param params.padding Optional padding to leave around all elements. Defaults to 0.
       * @param params.fill Amount of the viewport to fill. By default, this method will zoom so that the content is 0.9 times the size of the viewport.
       * Aesthetically this makes for a more pleasing result than filling the viewport entirely.
       * @param params.onComplete Optional function to call on operation complete (centering may be animated).
       * @param params.onStep Optional function to call on operation step (centering may be animated).
       * @param params.doNotAnimate By default, the centering content step does not use animation. This is due to this method being used most often to initially setup a UI.
       */

    }, {
      key: "zoomToFitIfNecessary",
      value: function zoomToFitIfNecessary(params) {
        this.panZoom.zoomToFitIfNecessary(params);
      }
      /**
       * Zooms the viewport so that all of the given elements are visible.
       * @param zParams
       */

    }, {
      key: "zoomToElements",
      value: function zoomToElements(zParams) {
        this.panZoom.zoomToElements(zParams);
      }
      /**
       * Maps the location of the given event on the page onto the coordinate space of this widget, returning a value representing where the given event appears to
       * be with respect to the origin of the Surface's viewport.
       * @param event
       * @param doNotAdjustForOffset
       */

    }, {
      key: "mapEventLocation",
      value: function mapEventLocation(event, doNotAdjustForOffset) {
        return this.panZoom.mapEventLocation(event, doNotAdjustForOffset);
      }
      /**
       * Centers the tracked content inside the viewport, but does not adjust the current zoom.
       * @param params Method parameters.
       * @param params.bounds Bounds info. This is in an internal format and only used when this method is called by the widget itself. Otherwise it is calculated.
       * @param params.horizontal True by default. Indicates the content should be centered in the X axis.
       * @param params.vertical True by default. Indicates the content should be centered in the Y axis.
       * @param params.doNotAnimate=false If true, don't animate while centering.
       * @param params.onComplete Optional function to call on operation complete (centering may be animated).
       * @param params.onStep Optional function to call on operation step (centering may be animated).
       * @param params.doNotFirePanEvent=false If true, a pan event will not be fired.
       */

    }, {
      key: "centerContent",
      value: function centerContent(params) {
        this.panZoom.centerContent(params);
      }
      /**
       * Zooms the display so that the current selected nodes are all visible, optionally animating the transition.
       * @param params Optional method params
       * @param params.fill A decimal indicating how much of the viewport to fill with the zoomed content. Defaults to a value of 0.90.
       * @param params.selection Optional Selection to which to zoom. If omitted, the default is to use the Toolkit's
       * current selection.
       * @param params.doNotZoomIfVisible If true, no action is taken if the content is currently all visible. Defaults to false.
       * @param params.doNotAnimate By default the widget does not animate this operation. You can override that behaviour by setting doNotAnimate:false.
       * @param params.filter Optional function to use as a filter; we create the selection by running this filter by the Toolkit's `filter` method.
       */

    }, {
      key: "zoomToSelection",
      value: function zoomToSelection(params) {
        var _this10 = this;

        params = params || {};

        var prepareSelection = function prepareSelection() {
          if (params.filter) {
            return _this10.toolkitInstance.filter(params.filter);
          } else {
            return _this10.toolkitInstance.getSelection();
          }
        };

        var sel = params.selection || prepareSelection(),
            els = [];
        sel.eachNode(function (idx, n) {
          els.push(_this10.getRenderedElement(n.id));
        });
        sel.eachGroup(function (idx, n) {
          els.push(_this10.getRenderedElement(n.id));
        });

        if (els.length > 0) {
          this.panZoom.zoomToElements({
            elements: els,
            fill: params.fill,
            doNotZoomIfVisible: params.doNotZoomIfVisible,
            doNotAnimate: params.doNotAnimate
          });
        }
      }
      /**
       * Gets a Path from some source Vertex to some target Vertex. This method is a wrapper around the Toolkit's `getPath`
       * method, adding a few ui specific functions to the result.
       * @param params Path spec params
       * @param params.source Source node or port, or id of source node/port
       * @param params.target Target node or port, or id of target node/port
       * @param params.strict Defaults to true. Sets whether or not paths are searched strictly by the given source/target. If, for instance, you supply a node as the source, but there are only edges connected to ports on that node, by default these edges will be ignored. Switching `strict` to false will mean these edges are considered.
       * @param params.nodeFilter Optional function that is given each Node's backing data and asked to return true or false - true means include the Node, false means exclude it.
       * @param params.edgeFilter Optional function that is given each Edge's backing data and asked to return true or false - true means include the Edge, false means exclude it.
       * @returns A Path object. Even if no path exists you will get a return value - but it will just be empty.
       */

    }, {
      key: "getPath",
      value: function getPath(params) {
        return new UIPath(this.toolkitInstance.getPath(params), this);
      } // Appends the given element to the display. For internal use.

    }, {
      key: "_append",
      value: function _append(el, id, pos, isDecoration) {
        this.canvasElement.appendChild(el);
        this.panZoom.add(el, id, pos, isDecoration);
      }
    }, {
      key: "_getGroupDragArea",
      value: function _getGroupDragArea(group) {
        var uiGroup = this.jsplumb.getGroup(group.id);
        return uiGroup ? this.jsplumb.getGroupContentArea(uiGroup) : null;
      }
    }, {
      key: "_doAssignDragGroup",
      value: function _doAssignDragGroup(el, v) {
        if (this.dragGroupAssigner != null) {
          if (!this._suspendRendering) {
            var dragGroup = this.dragGroupAssigner(v);

            if (dragGroup != null) {
              this.jsplumb.addToDragGroup(dragGroup, el);
            } else {
              this.jsplumb.removeFromDragGroup(el);
            }
          } else {
            this._pendingDragGroupAssignments.push([el, v]);
          }
        }
      }
    }, {
      key: "_assignPendingDragGroups",
      value: function _assignPendingDragGroups() {
        if (this.dragGroupAssigner != null) {
          for (var i = 0; i < this._pendingDragGroupAssignments.length; i++) {
            this._doAssignDragGroup.apply(this, this._pendingDragGroupAssignments[i]);
          }
        }
      }
      /**
       * Runs each of the given objects through the code that automatically assigns them to a drag group.
       * @param objects
       */

    }, {
      key: "assignToDragGroup",
      value: function assignToDragGroup() {
        var _this11 = this;

        for (var _len = arguments.length, objects = new Array(_len), _key = 0; _key < _len; _key++) {
          objects[_key] = arguments[_key];
        }

        forEach(objects, function (o) {
          var info = _this11.getObjectInfo(o);

          if (info.el) {
            _this11._doAssignDragGroup(info.el, info.obj);
          }
        });
      }
      /**
       * Removes the given object(s) from any drag group they may belong to. You don't need to specify the name of the drag group
       * since an object may belong to only one at a time.
       * @param objects
       */

    }, {
      key: "removeFromDragGroup",
      value: function removeFromDragGroup() {
        var _this$jsplumb,
            _this12 = this;

        for (var _len2 = arguments.length, objects = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          objects[_key2] = arguments[_key2];
        }

        (_this$jsplumb = this.jsplumb).removeFromDragGroup.apply(_this$jsplumb, _toConsumableArray$1(objects.map(function (o) {
          return _this12.getObjectInfo(o).el;
        }).filter(function (e) {
          return e != null;
        })));
      }
      /**
       * Adds the given objects to the given drag group.
       * @param spec Spec for the drag group. If you supply a string, then all objects are added to the drag group with that name, and they
       * are marked "active". If you supply an object in the form { id:string, active?:boolean } then all the objects are added to the drag
       * group with the active state you provide.
       * @param objects Objects to add.
       */

    }, {
      key: "addToDragGroup",
      value: function addToDragGroup(spec) {
        var _this$jsplumb2,
            _this13 = this;

        for (var _len3 = arguments.length, objects = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
          objects[_key3 - 1] = arguments[_key3];
        }

        (_this$jsplumb2 = this.jsplumb).addToDragGroup.apply(_this$jsplumb2, [spec].concat(_toConsumableArray$1(objects.map(function (o) {
          return _this13.getObjectInfo(o).el;
        }).filter(function (e) {
          return e != null;
        }))));
      }
      /**
       * Sets the current grid for element dragging, magnetization and group sizing.
       * @param grid Grid to use. If you provide null as the value the grid will be cleared.
       */

    }, {
      key: "setGrid",
      value: function setGrid(grid) {
        this.gridProfile.grid = grid;
        this.jsplumb.setDragGrid(grid);
      }
      /**
       * Get the current grid.
       */

    }, {
      key: "getGrid",
      value: function getGrid() {
        return this.gridProfile.grid;
      }
      /**
       * Returns the apparent [left,top] of the canvas inside the viewport - the coordinates, in real pixel
       * values, of where the origin of the canvas appears to be. This apparent origin is not necessarily the
       * same as the [left,top] values of the canvas, because the transform origin and zoom values change
       * things.  This function can be used in conjunction with the content bounds by widgets such as the miniview,
       * to calculate what is actually visible in the viewport at some point in time.
       * @returns  Top left location of the canvas, relative to the viewport's 0,0.
       */

    }, {
      key: "getApparentCanvasLocation",
      value: function getApparentCanvasLocation() {
        return this.panZoom.getApparentCanvasLocation();
      }
      /**
       * Sets the apparent canvas location - see the notes for getApparentCanvasLocation.
       * @param left Value in pixels for left edge of canvas.
       * @param top Value in pixels for top edge of canvas.
       * @returns Location of the actual origin set, after clamping.
       */

    }, {
      key: "setApparentCanvasLocation",
      value: function setApparentCanvasLocation(left, top) {
        return this.panZoom.setApparentCanvasLocation(left, top);
      }
      /**
       * Gets the current bounds information.
       */

    }, {
      key: "getBoundsInfo",
      value: function getBoundsInfo() {
        return this.panZoom.getBoundsInfo();
      }
      /**
       * Sets the current zoom, clamping it to the allowed range.
       * @param zoom - Zoom value. If this is outside the allowed bounds it will be clamped.
       * @param animate - If true, the surface will animate the transition in zoom by stepping through several intermediate levels in succession.
       * @returns Current zoom. This may or may not be the value you asked for - it might have been clamped to the current allowed zoom range.
       */

    }, {
      key: "setZoom",
      value: function setZoom(zoom, animate) {
        return this.panZoom.setZoom(zoom, animate);
      }
      /**
       * Sets the current zoom range. By default, this method checks if the current zoom is within
       * the new range, and if it is not then `setZoom` is called, which will cause the zoom to be clamped
       * to an allowed value in the new range. You can disable this by passing `true` for `doNotClamp`.
       * @param zr New range, as an array consisting of [lower, upper] values. Lower must be less than upper.
       * @param doNotClamp If true, will not check the current zoom to ensure it falls within the new range.
       * @returns Array of [min, max] current zoom values.
       */

    }, {
      key: "setZoomRange",
      value: function setZoomRange(zr, doNotClamp) {
        return this.panZoom.setZoomRange(zr, doNotClamp);
      }
      /**
       * Gets the current zoom range.
       * @returns Array of [min, max] current zoom values.
       */

    }, {
      key: "getZoomRange",
      value: function getZoomRange() {
        return this.panZoom.getZoomRange();
      }
      /**
       * Gets the current zoom.
       * @returns Current zoom value
       */

    }, {
      key: "getZoom",
      value: function getZoom() {
        return this.panZoom.getZoom();
      }
      /**
       * Nudges the zoom by the given amount. Zoom will be clamped to the current zoom range in effect and the
       * value that was ultimately set is returned from this function. The value you pass in here is multiplied by
       * 100 to give a percentage value: 1 is 100%, for instance, 0.05 is 5%.
       * @param delta Amount to change zoom by.
       * @param e Original event that caused the nudge. May be null.
       * @returns The zoom that was set. Zoom will be clamped to the allowed range.
       */

    }, {
      key: "nudgeZoom",
      value: function nudgeZoom(delta, e) {
        return this.panZoom.nudgeZoom(delta, e);
      }
      /**
       * Nudges the wheel zoom by the given amount. This function is intended for use by components that control
       * zoom via the mouse wheel, and not for general usage. See `nudgeZoom` for a more general version of this.
       * @param delta Amount to change zoom by.
       * @param e Original event that caused the nudge. May be null.
       */

    }, {
      key: "nudgeWheelZoom",
      value: function nudgeWheelZoom(delta, e) {
        this.panZoom.nudgeWheelZoom(delta, e);
      }
      /**
       * Gets the current origin of the panned content.
       * @returns Position, in pixels, of the panned content, where 0,0 is the origin of the viewport.
       */

    }, {
      key: "getPan",
      value: function getPan() {
        return this.panZoom.getPan();
      }
      /**
       * Pans the content by dx and dy.
       * @param dx - Amount to pan in X direction
       * @param dy - Amount to pan in Y direction
       * @param doNotAnimate - By default this operation uses animation.
       */

    }, {
      key: "pan",
      value: function pan(dx, dy, doNotAnimate) {
        this.panZoom.pan(dx, dy, !doNotAnimate);
      }
      /**
       * Sets the position of the panned content's origin.
       * @param left - Position in pixels of the left edge of the panned content.
       * @param top - Position in pixels of the top edge of the panned content.
       * @param animate - Whether or not to animate the pan. Defaults to false.
       * @param onComplete - If `animate` is set to true, an optional callback for the end of the pan
       */

    }, {
      key: "setPan",
      value: function setPan(left, top, animate, onComplete) {
        this.panZoom.setPan(left, top, animate, onComplete);
      }
      /**
       * Sets the pan and zoom for the Surface in one pass.
       * @param x - Value for pan in x axis
       * @param y - Value for pan in Y axis
       * @param zoom - Value fo zoom
       * @param animate - Defaults to false. If true, the changes will be made with the widget animating.
       */

    }, {
      key: "setPanAndZoom",
      value: function setPanAndZoom(x, y, zoom, animate) {
        this.setPan(x, y, animate);
        this.setZoom(zoom, animate);
      }
      /**
       * Center on the current object and zoom in on it.
       * @param element - The element to center. Can be a DOM element, vertex id, or a Node/Group
       * @param fillRatio How much of the viewport to fill with the object we zoom in on. This will be limited by the current zoom range. Defaults to 0.6.
       * @param doNotAnimate - by default, this operation will be animated.
       */

    }, {
      key: "centerOnAndZoom",
      value: function centerOnAndZoom(element, fillRatio, doNotAnimate) {
        var info = this.getObjectInfo(element);

        if (info.el != null) {
          this.panZoom.centerOnAndZoom(info.el, {
            fillRatio: fillRatio,
            doNotAnimate: doNotAnimate
          });
        }
      }
      /**
       * Center on the given object
       * @param element
       */

    }, {
      key: "centerOn",
      value: function centerOn(element) {
        var info = this.getObjectInfo(element);

        if (info.el != null) {
          this.panZoom.centerOn(info.el);
        }
      }
      /**
       * Center on the given object horizontally
       * @param element
       */

    }, {
      key: "centerOnHorizontally",
      value: function centerOnHorizontally(element) {
        var info = this.getObjectInfo(element);

        if (info.el != null) {
          this.panZoom.centerOnHorizontally(info.el, {});
        }
      }
      /**
       * Center on the given object vertically
       * @param element
       */

    }, {
      key: "centerOnVertically",
      value: function centerOnVertically(element) {
        var info = this.getObjectInfo(element);

        if (info.el != null) {
          this.panZoom.centerOnVertically(info.el, {});
        }
      }
      /**
       * Sets whether or not the widget clamps the movement of the canvas during pan/zoom
       * to ensure that the managed content never disappears from view.
       * @param c Whether or not to clamp movement.
       */

    }, {
      key: "setClamping",
      value: function setClamping(c) {
        this.panZoom.setClamping(c);
      }
      /**
       * Returns whether or not the widget clamps the movement of the canvas during pan/zoom/
       */

    }, {
      key: "isClamping",
      value: function isClamping() {
        return this.panZoom.isClamping();
      }
      /**
       * Returns the element used as container for the Surface.
       */

    }, {
      key: "getContainer",
      value: function getContainer() {
        return this.jsplumb.getContainer();
      }
      /**
       * Returns whether or not the given point (relative to page origin) is within the viewport for the widget.
       * @param x X location of point to test
       * @param y Y location of point to test
       * @returns True if the point is within the viewport, false if not.
       */

    }, {
      key: "isInViewport",
      value: function isInViewport(x, y) {
        return this.panZoom.isInViewport(x, y);
      }
      /**
       * Maps the given page location to a value relative to the viewport origin, allowing for
       * zoom and pan of the canvas. This takes into account the offset of the viewport in the page so that what
       * you get back is the mapped position relative to the target element's [left,top] corner. If
       * you wish, you can supply true for 'doNotAdjustForOffset', to suppress that behavior.
       * @param left X location
       * @param top Y location
       * @param doNotAdjustForOffset Whether or not to adjust for the offset of the viewport in the page. Defaults to false.
       * @returns The mapped location, as a PointXY object.
       */

    }, {
      key: "fromPageLocation",
      value: function fromPageLocation(left, top, doNotAdjustForOffset) {
        return this.panZoom.fromPageLocation(left, top, doNotAdjustForOffset);
      }
      /**
       * Maps the given location relative to the viewport origin, to a page location, allowing for
       * zoom and pan of the canvas. This takes into account the offset of the viewport in the page so that what
       * you get back is the mapped position relative to the target element's [left,top] corner. If
       * you wish, you can supply true for 'doNotAdjustForOffset', to suppress that behavior.
       * @param left X location
       * @param top Y location
       * @param doNotAdjustForOffset Whether or not to adjust for the offset of the viewport in the page. Defaults to false.
       * @returns The mapped location, as a PointXY object.
       */

    }, {
      key: "toPageLocation",
      value: function toPageLocation(left, top, doNotAdjustForOffset) {
        return this.panZoom.toPageLocation(left, top, doNotAdjustForOffset);
      }
      /**
       * Finds vertices - Nodes or Groups - that intersect a rectangle defined by the given origin and dimensions.
       * @param origin Origin of the rectangle to test
       * @param dimensions Width and height of the rectangle to test
       * @param enclosed If true, vertices must be fully enclosed by the rectangle
       * @param dontIncludeGroups If true, Groups are omitted from the search
       * @param dontIncludeNodes If true, Nodes are omitted from the search
       * @param dontIncludeNodesInsideGroups If true, Nodes inside Groups are omitted from the search
       * @param dontIncludeNestedGroups If true, Groups that are nested inside other Groups are omitted from the search
       */

    }, {
      key: "findIntersectingVertices",
      value: function findIntersectingVertices(origin, dimensions, enclosed, dontIncludeGroups, dontIncludeNodes, dontIncludeNodesInsideGroups, dontIncludeNestedGroups) {
        var _this14 = this;

        if (dontIncludeNodes === true && dontIncludeGroups === true && dontIncludeNodesInsideGroups === true) {
          return [];
        }

        var elements = this.panZoom.findIntersectingElements(origin, dimensions, enclosed, function (r, r2, id) {
          // this filter returns all elements that are a node or a group,
          var v = _this14.toolkitInstance.getVertex(id);

          if (v != null) {
            var n = isNode(v),
                ng = n && isNodeInsideAGroup(v),
                g = isGroup(v),
                gg = g && isNestedGroup(v),
                _n = dontIncludeNodes === true && n,
                _g = dontIncludeGroups === true && g,
                _ng = dontIncludeNodesInsideGroups && ng,
                _gg = dontIncludeNestedGroups && gg;

            return !(_n || _g || _ng || _gg);
          } else {
            return false;
          }
        });
        return elements.map(function (e) {
          return {
            enclosed: enclosed,
            id: e.id,
            r: e.r,
            v: _this14.toolkitInstance.getVertex(e.id),
            el: _this14.getRenderedElement(e.id)
          };
        });
      }
      /**
       * Finds Nodes (not Groups) - that intersect a rectangle defined by the given origin and dimensions.
       * @param origin Origin of the rectangle to test
       * @param dimensions Width and height of the rectangle to test
       * @param enclosed If true, vertices must be fully enclosed by the rectangle
       * @param dontIncludeNodesInsideGroups If true, Nodes inside Groups are omitted from the search
       */

    }, {
      key: "findIntersectingNodes",
      value: function findIntersectingNodes(origin, dimensions, enclosed, dontIncludeNodesInsideGroups) {
        return this.findIntersectingVertices(origin, dimensions, enclosed, true, false, dontIncludeNodesInsideGroups, true);
      }
      /**
       * Finds Groups (not Nodes) - that intersect a rectangle defined by the given origin and dimensions.
       * @param origin Origin of the rectangle to test
       * @param dimensions Width and height of the rectangle to test
       * @param enclosed If true, vertices must be fully enclosed by the rectangle
       * @param dontIncludeNestedGroups If true, Nodes inside Groups are omitted from the search
       */

    }, {
      key: "findIntersectingGroups",
      value: function findIntersectingGroups(origin, dimensions, enclosed, dontIncludeNestedGroups) {
        return this.findIntersectingVertices(origin, dimensions, enclosed, true, false, true, true);
      }
      /**
       * Redraw all connections.
       */

    }, {
      key: "repaintEverything",
      value: function repaintEverything() {
        this.jsplumb.repaintEverything();
      }
      /**
       * When the Surface is rendering a Selection, this method triggers a reload on the selection, causing the UI to be cleared and
       * recreated.
       * @public
       */

    }, {
      key: "reload",
      value: function reload() {
        if (this.dataSource instanceof Selection) {
          this.dataSource.reload();
        } else {
          console.log("JSPLUMB: Surface not rendering a selection, `reload` has no effect.");
        }
      }
      /**
       * Cleans up the Surface.  When using a library integration such as Angular/React/Vue, this method will be called
       * automatically when the associated component is unloaded. If you're using vanilla Toolkit, you might want to call
       * this method if you're cleaning up your UI and you don't need this Surface any longer.
       * @public
       */

    }, {
      key: "destroy",
      value: function destroy() {
        // we have to unbind all the stuff we bound on the toolkit
        var _boundEvt;

        for (var i = 0; i < this._boundToolkitEvents.length; i++) {
          try {
            _boundEvt = this._boundToolkitEvents[i];
            this.dataSource.unbind(_boundEvt.event, _boundEvt.fn);
          } catch (e) {
            console.log("WARN: Could not unbind event " + _boundEvt.event + " during destroy operation.");
          }
        } // do we also need to unbind everything on the jsplumb instance?


        this.panZoom.destroy();
        this.canvasElement.parentNode.removeChild(this.canvasElement);
        removeClass(this.containerElement, CLASS_SURFACE);
        removeClass(this.containerElement, CLASS_SURFACE_DIRECT);
        removeClass(this.containerElement, CLASS_SURFACE_NO_PAN);
        forEach(this.plugins, function (p) {
          p.destroy();
        });
        this.fire(EVENT_DESTROY, this);
      } // /**
      //  * Associate the given mode with the given plugin. Plugins use this to register a mode on the surface, and then if that mode is
      //  * activated, the `activated` method is called on the plugin whenever that mode is set. An example is the lasso plugin, which is associated
      //  * with the `select` mode.
      //  * @param modeId
      //  * @param plugin
      //  */
      // associateMode(modeId:string, plugin:SurfacePlugin) {
      //     this.modeAssocations.set(modeId, plugin);
      // }

    }, {
      key: "_loadExistingData",
      value: function _loadExistingData(params) {
        var _this15 = this;

        var i, n, j, g, k;
        var somethingLoaded = false; // get groups

        for (i = 0, j = this.dataSource.getGroupCount(); i < j; i++) {
          g = this.dataSource.getGroupAt(i);

          if (this.objectFilter(g)) {
            this._doRenderGroup(g);

            somethingLoaded = true;
          }
        } // now add nodes for all vertices


        for (i = 0, j = this.dataSource.getNodeCount(); i < j; i++) {
          n = this.dataSource.getNodeAt(i);

          if (this.objectFilter(n)) {
            this._doRenderNode(n);

            somethingLoaded = true;
          }
        }

        var connectANodeOrGroup = function connectANodeOrGroup(n) {
          var edges = _this15.dataSource.getAllEdgesFor(n);

          for (k = 0; k < edges.length; k++) {
            var thisNode = resolveNode(edges[k].source);

            if (thisNode === n) {
              var _def = _this15.view.getEdgeDefinition(_this15.dataSource.getNodeType(edges[k].data));

              if (_def && _def.ignore === true) continue;

              var connectionParams = _this15._prepareConnectionParams(edges[k]);

              if (connectionParams.source != null && connectionParams.target != null) {
                var conn = _this15._connect(connectionParams, edges[k], _def);

                if (conn != null) {
                  // set geometry, if provided and supported.
                  var connector = conn.connector;

                  if (connectionParams.geometry && connector.importGeometry) {
                    connector.importGeometry(connectionParams.geometry, conn);
                  }

                  conn.edge = edges[k];
                  _this15.connMap[edges[k].getId()] = conn;
                }
              } else {
                // if DOM elements not yet available for both source and target, push to unrendered list.
                // this situation can happen with some of the library integrations, particular Vue3 if you
                // pass data to the surface component.
                _this15._enqueueEdge(edges[k]);
              }
            }
          }
        }; // next, connect all nodes and groups


        for (i = 0, j = this.dataSource.getNodeCount(); i < j; i++) {
          n = this.dataSource.getNodeAt(i);
          connectANodeOrGroup(n);
        }

        for (i = 0, j = this.dataSource.getGroupCount(); i < j; i++) {
          n = this.dataSource.getGroupAt(i);
          connectANodeOrGroup(n);
        }

        return somethingLoaded;
      }
    }, {
      key: "fireNodeAdded",
      value: function fireNodeAdded(p) {
        this.fire(EVENT_NODE_ADDED, p); //this.fire<VertexAddedParams>(Events.vertexAdded, p)
      }
    }, {
      key: "createRenderer",
      value: function createRenderer(objectType, idFunctionToUse, typeFunctionToUse) {
        var _this16 = this;

        return function (object, data, parentNode, def, eventInfo) {
          idFunctionToUse(data);
              var typeId = typeFunctionToUse(data),
              _data = data,
              i; // enhanced views are models supporting preconfigured values, and
          // functions as parameter values. This is switched on by default. If you use
          // something that does two-way data binding, such as angular, you will
          // probably want to switch it off, because creating a duplicate of the data here
          // causes the two-way binding to fail.

          if (_this16.enhancedView) {
            _data = extend({}, def ? def.parameters || {} : {}); // then merge node on top, so its values take priority.

            extend(_data, data);
            var mappedData = {};

            for (i in _data) {
              if (_data.hasOwnProperty(i)) {
                if (_data[i] != null) {
                  if (_data[i].constructor == Function) mappedData[i] = _data[i](data);else mappedData[i] = _data[i];
                }
              }
            }

            _data = mappedData;
          }

          if (def) {
            var tmplId = def.templateId || "jtk-template-" + typeId;

            _this16.templateRenderer.render(tmplId, _data, _this16.dataSource, objectType, _this16, def, object, parentNode, eventInfo);
          }
        };
      }
    }, {
      key: "_handleClickOrTap",
      value: function _handleClickOrTap(el, evt, outputEventName) {
        var obj = this.getModelObjectFromElement(el);

        if (obj != null) {
          var _def2 = isNode(obj) ? this.getNodeDefinition(obj) : isGroup(obj) ? this.getGroupDefinition(obj) : isPort(obj) ? this.getPortDefinition(obj) : null;

          if (_def2 && _def2.events && _def2.events[outputEventName]) {
            _def2.events[outputEventName]({
              el: el,
              obj: obj,
              e: evt,
              toolkit: this.dataSource,
              renderer: this
            });
          }
        }
      }
      /**
       * @internal
       * @param ep
       * @param evt
       * @param eventName
       */

    }, {
      key: "_handleEndpointClick",
      value: function _handleEndpointClick(ep, evt, eventName) {
        var obj = this.getModelObjectFromEndpoint(ep);

        if (obj != null) {
          if (isPort(obj)) {
            var _def3 = this.getPortDefinition(obj);

            if (_def3 && _def3.events && _def3.events[eventName]) {
              _def3.events[eventName]({
                el: ep,
                obj: obj,
                e: evt,
                toolkit: this.dataSource,
                renderer: this
              });
            }
          }
        }
      }
      /**
       * @internal
       */

    }, {
      key: "_bindToJsPlumb",
      value: function _bindToJsPlumb() {
        var _this17 = this;

        this.jsplumb.bind(EVENT_CONNECTION, function (info) {
          if (info.connection.edge != null) return;

          var sourceParams = info.sourceEndpoint.parameters,
              targetParams = info.targetEndpoint.parameters,
              sourcePortId = sourceParams.portId,
              sourceVertexId = sourceParams.vertexId,
              targetPortId = targetParams.portId,
              targetVertexId = targetParams.vertexId,
              sourcePortTypeId = info.sourceEndpoint.parameters[Parameters.portType] || DEFAULT$1,
              sourcePortType = _this17.view.getPortDefinition(sourcePortTypeId),
              edgeType = sourcePortType != null && sourcePortType.edgeType ? sourcePortType.edgeType : info.sourceEndpoint.parameters[Parameters.edgeType] || "default";

          var source = _this17.getModelObjectFromEndpoint(info.sourceEndpoint),
              target = _this17.getModelObjectFromEndpoint(info.targetEndpoint),
              sourceId = source.getFullId(),
              targetId = target.getFullId();

          var params = {
            sourceVertexId: sourceVertexId,
            sourcePortId: sourcePortId,
            targetVertexId: targetVertexId,
            targetPortId: targetPortId,
            type: edgeType,
            source: source,
            target: target,
            sourceId: sourceId,
            targetId: targetId,
            sourceType: source.objectType,
            targetType: target.objectType
          };

          var doAbort = _this17.dataSource.edgeFactory(edgeType, info.connection.getData() || {}, function (data) {
            data = populate(data, source, null, true); // set `type` if not present in the data returned from the factory

            data.type = data.type || edgeType;
            params.edge = _this17.dataSource.addEdge({
              source: sourceId,
              target: targetId,
              cost: info.connection.cost,
              directed: info.connection.directed,
              data: data,
              addedByMouse: true
            }, _this17);
            _this17.connMap[params.edge.getId()] = info.connection;
            info.connection.edge = params.edge; // now update the UI with any changes wrought by the edge factory (most importantly, a change in the edge's type)

            var newConnectionParameters = _this17._prepareConnectionParams(params.edge);

            info.connection.setType([Constants["default"], newConnectionParameters.type].join(" "), newConnectionParameters.data);
            params.addedByMouse = true;
            params.connection = info.connection;

            _this17.fire(EVENT_EDGE_ADDED, params);
          }, function () {
            // on abort, delete the connection
            _this17.jsplumb.deleteConnection(info.connection);
          }, params);

          if (doAbort === false) {
            _this17.jsplumb.deleteConnection(info.connection);
          }
        }); // fired when the user moves a connection with the mouse. we advise the toolkit and it takes action.

        this.jsplumb.bind(EVENT_CONNECTION_MOVED, function (info) {
          var modelObject = _this17.getModelObjectFromEndpoint(info.newEndpoint);

          _this17._whileIgnoringToolkitEvents(function () {
            _this17.dataSource.edgeMoved(info.connection.edge, modelObject, info.index);
          });
        }); // fired only when an edge was removed via the UI.

        this.jsplumb.bind(EVENT_CONNECTION_DETACHED, function (info) {
          var edge = info.connection.edge;

          _this17._whileIgnoringToolkitEvents(function () {
            _this17.dataSource.removeEdge(edge);
          });

          var sp = info.sourceEndpoint.parameters,
              tp = info.targetEndpoint.parameters,
              sourceId = sp.nodeId + (sp.portId ? "." + sp.portId : ""),
              targetId = tp.nodeId + (tp.portId ? "." + tp.portId : "");

          _this17.fire(EVENT_EDGE_ADDED, {
            sourceNodeId: sp.vertexId,
            targetNodeId: tp.vertexId,
            sourcePortId: sp.portId,
            targetPortId: tp.portId,
            sourceId: sourceId,
            targetId: targetId,
            source: _this17.dataSource.getNode(sourceId),
            target: _this17.dataSource.getNode(targetId),
            edge: edge
          });
        });
        this.jsplumb.bind(EVENT_GROUP_MEMBER_ADDED$1, function (info) {
          var modelObject = _this17.getModelObjectFromElement(info.el);

          if (modelObject != null && (isNode(modelObject) || isGroup(modelObject))) {
            var sourceGroup = info.sourceGroup == null ? null : _this17.dataSource.getGroup(info.sourceGroup.id);

            var tkGroup = _this17.dataSource.getGroup(info.group.id);

            if (tkGroup) {
              _this17.dataSource.addToGroup(modelObject, tkGroup, sourceGroup, info.pos, _this17);
            }
          }
        });
        this.jsplumb.bind(EVENT_GROUP_MEMBER_REMOVED$1, function (info) {
          var modelObject = _this17.getModelObjectFromElement(info.el);

          if (modelObject != null && (isNode(modelObject) || isGroup(modelObject))) {
            var targetGroup = info.targetGroup == null ? null : _this17.dataSource.getGroup(info.targetGroup.id);

            _this17.dataSource.removeFromGroup(modelObject, false, targetGroup, _this17);
          }
        });
        this.jsplumb.bind(EVENT_NESTED_GROUP_REMOVED, function (info) {
          var modelObject = _this17.getModelObjectFromElement(info.child.el);

          if (modelObject != null && (isNode(modelObject) || isGroup(modelObject))) {
            //const targetGroup = info.targetGroup == null ? null : this.dataSource.getGroup(info.targetGroup.id)
            _this17.dataSource.removeFromGroup(modelObject, false, null, _this17);
          }
        });
        this.jsplumb.bind(EVENT_GROUP_COLLAPSE, function (info) {
          // update layout - either the main layout, or a group layout.
          var layoutToUse = info.group.group == null ? _this17._layout : _this17._layoutMap.get(info.group.group.id);

          var newSize = _this17.jsplumb.getSize(info.group.el);

          layoutToUse.setSize(info.group.id, newSize);

          if (_this17.magnetizeProfile.afterGroupCollapse === true) {
            if (info.group.group == null) {
              // we only support groups that are in the Surface
              _this17.gather(info.group.id);
            } else {
              // for groups that are not in the surface, we might auto size them
              var group = _this17.toolkitInstance.getGroup(info.group.id);

              if (group != null) {
                var groupDef = _this17.view.getGroupDefinition(_this17.dataSource.getNodeType(group.data));

                _this17._autoSizeAGroup(group, groupDef, null, false);
              }
            }
          }

          var tkGroup = _this17.dataSource.getGroup(info.group.id);

          if (tkGroup) {
            _this17.fire(EVENT_GROUP_COLLAPSE, {
              group: tkGroup,
              uigroup: info.group,
              renderer: _this17
            });
          }
        });
        this.jsplumb.bind(EVENT_GROUP_EXPAND, function (info) {
          // get the appropriate layout and set the group's new size.
          var layoutToUse = info.group.group == null ? _this17._layout : _this17._layoutMap.get(info.group.group.id);

          var newSize = _this17.jsplumb.getSize(info.group.el);

          layoutToUse.setSize(info.group.id, newSize);

          if (_this17.magnetizeProfile.afterGroupExpand !== false) {
            if (info.group.group == null) {
              // we only support groups that are in the Surface
              _this17.magnetize(info.group.id);
            } else {
              // for groups that are not in the surface, we might auto size them
              var group = _this17.toolkitInstance.getGroup(info.group.id);

              if (group != null) {
                var groupDef = _this17.view.getGroupDefinition(_this17.dataSource.getNodeType(group.data));

                _this17._autoSizeAGroup(group, groupDef, null, false);
              }
            }
          }

          var tkGroup = _this17.dataSource.getGroup(info.group.id);

          if (tkGroup) {
            _this17.fire(EVENT_GROUP_EXPAND, {
              group: tkGroup,
              uigroup: info.group,
              renderer: _this17
            });
          }
        });
        forEach([EVENT_CONNECTION_CLICK, EVENT_CONNECTION_DBL_CLICK, EVENT_CONNECTION_TAP, EVENT_CONNECTION_DBL_TAP, EVENT_CONNECTION_MOUSEDOWN, EVENT_CONNECTION_MOUSEUP, EVENT_CONNECTION_MOUSEOVER, EVENT_CONNECTION_MOUSEOUT, EVENT_CONNECTION_CONTEXTMENU], function (event) {
          _this17.jsplumb.bind(event, function (connection, evt) {
            if (connection.edge) {
              var edge = connection.edge;

              var _def4 = _this17.view.getEdgeDefinition(_this17.dataSource.getEdgeType(edge.data));

              var eventSuffix = event.split(":")[1];

              if (_def4 && _def4.events && _def4.events[eventSuffix]) {
                _def4.events[eventSuffix]({
                  edge: edge,
                  e: evt,
                  toolkit: _this17.dataSource,
                  renderer: _this17,
                  connection: connection
                });
              }
            }
          });
        });
        forEach([[EVENT_ELEMENT_CLICK, EVENT_CLICK], [EVENT_ELEMENT_TAP, EVENT_TAP], [EVENT_ELEMENT_DBL_TAP, EVENT_DBL_TAP], [EVENT_ELEMENT_DBL_CLICK, EVENT_DBL_CLICK], [EVENT_ELEMENT_MOUSE_OUT, EVENT_MOUSEOUT], [EVENT_ELEMENT_MOUSE_OVER, EVENT_MOUSEOVER], [EVENT_ELEMENT_MOUSE_MOVE, EVENT_MOUSEMOVE], [EVENT_ELEMENT_MOUSE_UP, EVENT_MOUSEUP], [EVENT_ELEMENT_MOUSE_DOWN, EVENT_MOUSEDOWN], [EVENT_ELEMENT_CONTEXTMENU, EVENT_CONTEXTMENU]], function (_ref) {
          var _ref2 = _slicedToArray$2(_ref, 2),
              boundEvent = _ref2[0],
              outputEvent = _ref2[1];

          _this17.jsplumb.bind(boundEvent, function (el, evt) {
            _this17._handleClickOrTap(el, evt, outputEvent);
          });
        });
        forEach([[EVENT_ENDPOINT_CLICK, EVENT_CLICK], [EVENT_ENDPOINT_DBL_CLICK, EVENT_DBL_CLICK]], function (_ref3) {
          var _ref4 = _slicedToArray$2(_ref3, 2),
              boundEvent = _ref4[0],
              outputEvent = _ref4[1];

          _this17.jsplumb.bind(boundEvent, function (ep, evt) {
            _this17._handleEndpointClick(ep, evt, outputEvent);
          });
        });
      }
      /**
       * Run the given function with toolkit event subscribers suspended.
       * @param fn Function to run. Events are suspended, then this function is run, then events are re-enabled.
       * @internal
       */

    }, {
      key: "_whileIgnoringToolkitEvents",
      value: function _whileIgnoringToolkitEvents(fn) {
        this._ignoreToolkitEvents = true;

        try {
          fn();
        } catch (e) {
          console.log("An error occurred while ignoring Toolkit events", e);
        } finally {
          this._ignoreToolkitEvents = false;
        }
      }
      /**
       * Wraps the underlying Toolkit's `batch` function with the added step of first suspending events being
       * fired from this renderer.
       * @param fn Function to run while rendering and events are both suspended.
       * @public
       */

    }, {
      key: "batch",
      value: function batch(fn) {
        this.setSuspendEvents(true);
        this.dataSource.batch(fn);
        this.setSuspendEvents(false);
      }
      /**
       * Notification that a connection's geometry was edited.
       * @param connection
       * @internal
       */

    }, {
      key: "_connectionEdited",
      value: function _connectionEdited(connection) {
        var geometry = connection.connector.exportGeometry();
        this.dataSource.setEdgeGeometry(connection.edge, geometry, this);
      }
      /**
       * Bind the given handler to the event with the given name.
       * @param evt - Name of the event to bind to.
       * @param fn - Handler for the event.
       * @public
       */

    }, {
      key: "bind",
      value: function bind(evt, fn) {
        if (localEvents.indexOf(evt) === -1) {
          this.jsplumb.bind(evt, fn);
        } else {
          _get$1(_getPrototypeOf$7(Surface.prototype), "bind", this).call(this, evt, fn);
        }

        return this;
      }
      /**
       * Rotate the given vertex by the given number of degrees.  The DOM element representing the vertex is rotated and the view is updated.
       * @param obj - Either a vertex ID, or a Node/Group
       * @param amountInDegrees - Amount - in degrees - to rotate.
       * @public
       */

    }, {
      key: "rotate",
      value: function rotate(obj, amountInDegrees) {
        var _this18 = this;

        var info = this.getObjectInfo(obj);

        if (info.el) {
          info.obj.data.rotation = amountInDegrees;
          var redrawResult = this.jsplumb.rotate(info.el, amountInDegrees);
          redrawResult.c.forEach(function (conn) {
            var edge = conn.edge,
                connector = conn.connector;

            if (connector.geometry && connector.exportGeometry) {
              _this18.toolkitInstance.setEdgeGeometry(edge, connector.exportGeometry(), _this18);
            }
          });
          this.fire(EVENT_ROTATE, {
            obj: info.obj,
            rotation: amountInDegrees
          });
        }
      }
      /**
       * Do not use this method as a user of the library. It is for internal use only.
       * @param params
       * @internal
       */

    }, {
      key: "_setPosition",
      value: function _setPosition(params) {
        var out = {};
        var info = params.info || this.getObjectInfo(params.vertex);

        if (info && info.obj) {
          var _modelObject2 = info.obj;

          if (isPort(info.obj)) {
            _modelObject2 = info.obj.getParent();
          }

          var modelObjectId = _modelObject2.id;

          if (params.doNotUpdateLayout !== true) {
            var objectIsInsideAGroup = isNodeInsideAGroup(_modelObject2) || isNestedGroup(_modelObject2);

            var _l = objectIsInsideAGroup ? this._layoutMap.get(_modelObject2.group.id) : this._layout;

            if (params.magnetize) {
              extend(out, this._setMagnetizedPosition(modelObjectId, params.x, params.y, true, _l));
            } else {
              extend(out, _l.setPosition(modelObjectId, params.x, params.y));
            }

            if (objectIsInsideAGroup) {
              var groupDef = this.view.getGroupDefinition(this.dataSource.getNodeType(_modelObject2.group.data));

              var resizeInfo = this._autoSizeAGroup(_modelObject2.group, groupDef, null, false);

              if (resizeInfo != null) {
                extend(out, resizeInfo);
              }
            }
          }

          var w = params.size ? params.size.w : null;
          var h = params.size ? params.size.h : null; // if there is an element representing this vertex, position it. In some async painting scenarios an element may not currently exist.

          if (info.el != null) {
            // TODO it should not be necessary to call getId on the jsplumb instance here - the ID should be the ID of the vertex.
            this.viewport.updateElement(this.jsplumb.getId(info.el), params.x, params.y, w, h, null);

            if (params.doNotUpdateElement !== true && !params.magnetize) {
              setAbsolutePosition(info.el, params.x, params.y);
            }

            if (params.doRevalidate === true) {
              this.jsplumb.revalidate(info.el);
            }
          }

          if (params.storeInModel && this._storePositionsInModel) {
            this.storePositionInModel(modelObjectId);
          }
        }

        return out;
      }
      /**
       * Sets the position of the given node/group and runs the magnetizer. This operation is wrapped in a transaction
       * on the Toolkit so if undo is called then every element affected by the magnetize is relocated.
       * @param vertex
       * @param x
       * @param y
       * @param doNotUpdateElement
       * @public
       */

    }, {
      key: "setMagnetizedPosition",
      value: function setMagnetizedPosition(vertex, x, y, doNotUpdateElement) {
        this.toolkitInstance.openTransaction(APPEND_TO_CURRENT);

        var result = this._setPosition({
          info: null,
          vertex: vertex,
          x: x,
          y: y,
          doNotUpdateElement: doNotUpdateElement,
          magnetize: true,
          doRevalidate: true
        });

        this.toolkitInstance.commitTransaction();
        return result;
      }
      /**
       * Writes the current position for the given vertex into the data model.
       * @param params - Parameters
       * @param params.obj - Object to store vertex positions for.
       * @param params.leftAttribute - Name of the attribute to use for the left position. Default is 'left'
       * @param params.topAttribute - Name of the attribute to use for the top position. Default is 'top'
       * @public
       */

    }, {
      key: "storePositionInModel",
      value: function storePositionInModel(params) {
        var id = typeof params === "string" ? params : params.id;
        var np;
        var la = typeof params === "string" ? DEFAULT_LEFT_ATTRIBUTE : params.leftAttribute || DEFAULT_LEFT_ATTRIBUTE,
            ta = typeof params === "string" ? DEFAULT_TOP_ATTRIBUTE : params.topAttribute || DEFAULT_TOP_ATTRIBUTE,
            obj = params.obj || this.dataSource.getVertex(id);

        if (obj && (this._storePositionsInModel || params.force)) {
          var layout = isNodeInsideAGroup(obj) || isNestedGroup(obj) ? this._layoutMap.get(obj.group.id) : this._layout;
          np = layout.getPosition(id);
          data(obj.data, la, np.x);
          data(obj.data, ta, np.y);
        }

        return np;
      }
      /**
       * Writes the current position for each node into the data model. A common use case is to run an auto layout the first time
       * some dataset is seen, and then to save the locations of all the vertices once a human being has moved things around.
       * @param params - Parameters
       * @param params.leftAttribute - Name of the attribute to use for the left position. Default is 'left'
       * @param params.topAttribute - Name of the attribute to use for the top position. Default is 'top'
       * @public
       */

    }, {
      key: "storePositionsInModel",
      value: function storePositionsInModel(params) {
        var _this19 = this;

        params = params || {};
        var la = params.leftAttribute || Constants.left,
            ta = params.topAttribute || Constants.top;

        var p = this._layout.getPositions();

        p.forEach(function (pos, id) {
          var obj = _this19.toolkitInstance.getNode(id) || _this19.toolkitInstance.getGroup(id);

          if (obj) {
            data(obj.data, la, pos.x);
            data(obj.data, ta, pos.y);
          }
        });
        this.toolkitInstance.eachGroup(function (i, g) {
          var n = g.getMembers(),
              np = _this19._layoutMap.get(g.id).getPositions();

          for (i = 0; i < n.length; i++) {
            data(n[i].data, la, np.get(n[i].id).x);
            data(n[i].data, ta, np.get(n[i].id).y);
          }
        });
      }
      /**
       * Magnetize the elements in the display. If `focus` is provided it will be used as the origin for magnetization, and not moved. If no `focus` is
       * provided, the computed center of all the elements will be used as the origin.
       * @param focus
       * @public
       */

    }, {
      key: "magnetize",
      value: function magnetize(focus) {
        this._doMagnetize(focus, null, null, false);
      }
      /**
       * Magnetize the elements in the display, using the given point as the origin.
       * @param origin
       * @public
       */

    }, {
      key: "magnetizeAtPoint",
      value: function magnetizeAtPoint(origin) {
        this._doMagnetize(null, origin, null, false);
      }
      /**
       * Magnetize the elements in the display, using the location of the given event as the origin.
       * @param event
       * @public
       */

    }, {
      key: "magnetizeAtEvent",
      value: function magnetizeAtEvent(event) {
        this._doMagnetize(null, null, event, false);
      }
      /**
       * Gather the elements in the display. If `focus` is provided the elements will be gathered around it. Otherwise, the elements will be
       * gathered around the computed center of all the elements.
       * @param focus - Optional ID of a Vertex, or the Vertex itself, around which to gather elements.
       * @public
       */

    }, {
      key: "gather",
      value: function gather(focus) {
        this._doMagnetize(focus, null, null, true);
      }
      /**
       * @internal
       * @param focus
       * @param origin
       * @param event
       * @param gather
       */

    }, {
      key: "_doMagnetize",
      value: function _doMagnetize(focus, origin, event, gather) {
        if (this._layout != null) {
          var params = {
            options: {}
          };

          if (origin) {
            params.origin = origin;
          }

          if (gather) {
            params.options.gather = gather;
          }

          if (event) {
            params.origin = this.panZoom.mapEventLocation(event);
          }

          if (focus) {
            var info = this.getObjectInfo(focus);

            if (info.obj) {
              params.focus = info.obj.id;
            }
          }

          if (this.gridProfile.grid) {
            params.options.grid = this.gridProfile.grid;
          }

          var magnetizeResult = this._layout.magnetize(params, false);

          this._updateMovedElements(magnetizeResult);

          this.jsplumb.repaintEverything();
        }
      }
    }, {
      key: "_toggleNode",
      value: function _toggleNode(node, el, state, doNotCascade) {
        if (el) {
          el.style.display = state ? "block" : "none";
          el._jtkVisible = state;
          this.fire(EVENT_NODE_VISIBILITY, {
            node: node,
            el: el,
            state: state
          });

          if (!doNotCascade) {
            var edges = this.dataSource.getAllEdgesFor(node);

            for (var i = 0; i < edges.length; i++) {
              if (!state) {
                this._toggleEdge(edges[i], state, doNotCascade);
              } else {
                // if setting to visible, we must check the state of the other element connected to the edge.
                // only if it is visible do we actually show the edge.
                var edgeSourceNode = resolveNode(edges[i].source),
                    edgeTargetNode = resolveNode(edges[i].target),
                    otherNode = edgeSourceNode === node ? edgeTargetNode : edgeSourceNode,
                    otherState = this.isVisible(otherNode);

                if (otherState) {
                  this._toggleEdge(edges[i], state, doNotCascade);
                }
              }
            }
          }
        }
      }
    }, {
      key: "_togglePort",
      value: function _togglePort(port, state) {
        var id = port.getFullId(),
            ep = this.jsplumb.getEndpoint(id);
        ep.setVisible(state);
      }
    }, {
      key: "isVisible",
      value: function isVisible(obj) {
        var _this20 = this;

        return this._applyFunctionToObject(obj, function (info) {
          switch (info.type) {
            case Edge.objectType:
              var c = _this20.getConnectionForEdge(info.obj);

              return c ? c.isVisible() : false;

            case Node.objectType:
            case Group.objectType:
              return info.el._jtkVisible !== false;
          }
        });
      }
      /**
       * Sets the visible state of some model object or group of model objects. If the object is a vertex, the visible state
       * will be applied to all edges connected to the given vertex.
       *
       * By default this method will, for groups and nodes, cascade down to any nested vertices.
       * @param obj - Edge, Group, Node or Port, and array of these, or a `FilterableDataset`, such as a `Selection`.
       * @param state - True if edges should be visible, false otherwise.
       * @param doNotCascade - Defaults to false. If true, don't cascade down to any nested vertices.
       * @public
       */

    }, {
      key: "setVisible",
      value: function setVisible(obj, state, doNotCascade) {
        var _this21 = this;

        if (obj == null) return;

        var _toggleFn = function _toggleFn(info) {
          switch (info.type) {
            case Edge.objectType:
              _this21._toggleEdge(info.obj, state, doNotCascade);

              break;

            case Node.objectType:
            case Group.objectType:
              _this21._toggleNode(info.obj, info.el, state, doNotCascade);

              break;

            case Port.objectType:
              _this21._togglePort(info.obj, state);

              break;
          }
        };

        this._applyFunctionToObject(obj, _toggleFn);
      }
      /**
       *
       * @internal
       */

    }, {
      key: "_applyFunctionToObject",
      value: function _applyFunctionToObject(obj, fn) {
        var _this22 = this;

        var out; // if a Selection or Path (or a Toolkit instance), iterate.

        if (isFilterableDataset(obj)) {
          out = {
            nodes: [],
            edges: []
          };
          obj.eachVertex(function (i, n) {
            out.nodes.push(fn(_this22.getObjectInfo(n)));
          });
          obj.eachEdge(function (i, e) {
            out.edges.push(fn(_this22.getObjectInfo(e)));
          });
        } else if (isArrayLike(obj)) {
          out = [];

          for (var i = 0; i < obj.length; i++) {
            out.push(fn(this.getObjectInfo(obj[i])));
          }
        } else {
          // otherwise its just a single object.
          out = fn(this.getObjectInfo(obj));
        }

        return out;
      }
      /**
       * Sets the visible state of the overlays specified by `obj`
       * @param obj - An edge, array of edges, Selection or Path.
       * @param state - True to make the object(s) visible, false to make them invisible.
       * @param ids - Optional list of overlay ids to operate on. Without this, all overlays on each edge in `obj` are targeted.
       * @public
       */

    }, {
      key: "setOverlaysVisible",
      value: function setOverlaysVisible(obj, state) {
        var _this23 = this;

        for (var _len4 = arguments.length, ids = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {
          ids[_key4 - 2] = arguments[_key4];
        }

        if (obj == null) {
          return;
        }

        var out = [];

        if (isFilterableDataset(obj)) {
          obj.eachEdge(function (i, e) {
            out.push(_this23.getRenderedConnection(e.id));
          });
        } else if (isArrayLike(obj)) {
          for (var i = 0; i < obj.length; i++) {
            if (isEdge(obj[i])) {
              out.push(this.getRenderedConnection(obj[i].id));
            }
          }
        } else if (isEdge(obj)) {
          // otherwise its just a single object.
          out.push(this.getRenderedConnection(obj.id));
        }

        forEach(out, function (c) {
          if (state) {
            c.showOverlays.apply(c, ids);
          } else {
            c.hideOverlays.apply(c, ids);
          }
        });
      }
      /**
       * Decodes the given input into a data structure containing a model object, its type, its ID, and the DOM element used
       * to represent it. Always returns a value even if no model object could be resolved for the given input, but the fields
       * of the return value may be null.
       * @param obj - Object to decode. Can be in many different forms - an existing model object, a vertex id, a DOM element,
       * a Connection, some backing data.
       * @public
       */

    }, {
      key: "getObjectInfo",
      value: function getObjectInfo(obj) {
        if (obj == null) {
          return {
            id: null,
            obj: null,
            el: null,
            type: null
          };
        } else if (obj instanceof Connection) {
          var edge = obj.edge;
          return {
            obj: edge,
            id: edge.id,
            type: Edge.objectType,
            el: obj.connector.canvas
          };
        } else {
          if (isDOMElement(obj)) {
            var _modelObject3 = this.getModelObjectFromElement(obj, true);

            if (_modelObject3 != null) {
              return {
                el: this.getRenderedElement(_modelObject3.getFullId()),
                id: _modelObject3.getFullId(),
                type: _modelObject3.objectType,
                obj: _modelObject3
              };
            } else {
              return {
                id: null,
                obj: null,
                el: null,
                type: null
              };
            }
          } else {
            var toolkitInfo = this.toolkitInstance.getObjectInfo(obj);

            if (toolkitInfo.obj != null) {
              if (toolkitInfo.type === Edge.objectType) {
                return extend({
                  el: this.getRenderedConnection(toolkitInfo.id).connector.canvas
                }, toolkitInfo);
              } else {
                return extend({
                  el: this.getRenderedElement(toolkitInfo.obj)
                }, toolkitInfo);
              }
            } else {
              return extend({
                el: null
              }, toolkitInfo);
            }
          }
        }
      }
      /**
       * Refresh the layout and update all connections.
       * @param _internal For internal use. It is not recommended you set this flag if you call this method: it is a means for
       * the Toolkit to override the suspension of rendering, if it needs to.
       * @public
       */

    }, {
      key: "refresh",
      value: function refresh(_internal) {
        var _this24 = this;

        if (!this._suspendRendering && (!_internal || this._refreshAutomatically)) {
          if (this._layout) {
            this._layout.layout(function (result) {
              _this24.updateVertexPositions(result.positions, result.sizes);

              _this24.fire(EVENT_AFTER_LAYOUT_REFRESH, {
                bounds: _this24.getBoundsInfo(),
                positions: result.positions,
                sizes: _this24._layout.getSizes()
              }); // can this be abstracted?


              if (typeof window !== "undefined") {
                window.setTimeout(function () {
                  _this24.jsplumb.repaintEverything();
                }, 0);
              } else {
                _this24.jsplumb.repaintEverything();
              }
            }, this.magnetizeProfile.afterLayout);
          } else {
            this.jsplumb.repaintEverything();
          }
        }
      }
      /**
       * @internal
       * @param positions
       * @param sizes
       */

    }, {
      key: "updateVertexPositions",
      value: function updateVertexPositions(positions, sizes) {
        var _this25 = this;

        positions.forEach(function (pos, id) {
          _this25._setPosition({
            vertex: id,
            x: pos.x,
            y: pos.y,
            doNotUpdateElement: false,
            doNotUpdateLayout: true,
            doRevalidate: false,
            size: sizes.get(id)
          });
        });
      }
      /**
       * Clears and re-runs the layout, optionally with a new set of parameters.
       * @param newParameters
       * @public
       */

    }, {
      key: "relayout",
      value: function relayout(newParameters) {
        var _this26 = this;

        if (!this._suspendRendering) {
          if (this._layout) {
            this._layout.relayout(newParameters, function (result) {
              for (var i = 0; i < _this26.decorators.length; i++) {
                _this26.decorators[i].decorate({
                  surface: _this26,
                  adapter: _this26._layout.adapter,
                  layout: _this26._layout,
                  append: function append(el, id, pos) {
                    _this26._append(el, id, pos, true);
                  },
                  setAbsolutePosition: function setAbsolutePosition(el, xy) {
                    return _this26.setAbsolutePosition(el, xy);
                  },
                  toolkit: _this26.toolkitInstance,
                  bounds: result.bounds,
                  positions: result.positions
                });
              }

              _this26.updateVertexPositions(result.positions, result.sizes);

              _this26._relayoutGroups();

              _this26.jsplumb.repaintEverything();

              _this26.fire(EVENT_RELAYOUT, {
                bounds: _this26.getBoundsInfo(),
                positions: result.positions,
                sizes: _this26._layout.getSizes()
              });
            }, this.magnetizeProfile.afterLayout);
          } else {
            this.jsplumb.repaintEverything();
          }
        }
      }
      /**
       * Relayout all of the groups in the Surface.
       * @internal
       */

    }, {
      key: "_relayoutGroups",
      value: function _relayoutGroups() {
        var _this27 = this;

        this.dataSource.eachGroup(function (i, g) {
          if (_this27.objectFilter(g)) {
            _this27._relayoutGroup(g);
          }
        });
      }
      /**
       * Relayout the given group.
       * @param group
       * @internal
       */

    }, {
      key: "_relayoutGroup",
      value: function _relayoutGroup(group) {
        var _this28 = this;

        var groupLayout = this._layoutMap.get(group.id);

        if (groupLayout == null) {
          return;
        }

        groupLayout.relayout(null, function (result) {
          result.positions.forEach(function (pos, id) {
            _this28.setAbsolutePosition(_this28.jsplumb.getManagedElement(id), pos);
          });
        }, false);
        this.sizeGroupToFit(group);
        var el = this.jsplumb.getManagedElement(group.id);
        this.jsplumb.revalidate(el);
        this.fire(EVENT_GROUP_RELAYOUT, {
          group: group,
          layout: groupLayout,
          el: el
        });
      } // -------------------------------------- EVENTS ----------------------------

      /**
       * For a given endpoint, retrieve the model object it represents.
       * @param ep
       */

    }, {
      key: "getModelObjectFromEndpoint",
      value: function getModelObjectFromEndpoint(ep) {
        var context = ep.parameters,
            vertex = this.toolkitInstance.getNode(context.vertexId),
            modelObject = context.portId ? vertex.addPort({
          id: context.portId,
          type: context.portType
        }) : vertex;
        return modelObject;
      }
      /**
       * For a given element, retrieve the model object it represents.
       * @param el
       * @param searchAncestors Defaults to false. If true, ancestors of the given element are searched, up to the underlying container element.
       * @returns a Port, Node, Edge, Group, or null.
       */

    }, {
      key: "getModelObjectFromElement",
      value: function getModelObjectFromElement(el, searchAncestors) {
        var _this29 = this;

        var _one = function _one(_el) {
          var out; // if el's data-jtk-managed value matches a vertex, return that

          var vertexId = _el.getAttribute(ATTRIBUTE_MANAGED);

          if (vertexId != null) {
            var vertex = _this29.toolkitInstance.getVertex(vertexId);

            if (vertex != null) {
              out = vertex;
            }
          }

          if (out == null) {
            var portId = _el.getAttribute(ATTRIBUTE_JTK_PORT) || _el.getAttribute(ATTRIBUTE_JTK_SOURCE_PORT) || _el.getAttribute(ATTRIBUTE_JTK_TARGET_PORT);

            if (portId != null) {
              var vertexParentEl = findParent(_el, att(ATTRIBUTE_MANAGED), _this29.jsplumb.getContainer(), false);

              if (vertexParentEl != null) {
                var vertexParentId = vertexParentEl.getAttribute(ATTRIBUTE_MANAGED);

                var vertexParent = _this29.toolkitInstance.getNode(vertexParentId) || _this29.toolkitInstance.getGroup(vertexParentId);

                if (vertexParent) {
                  var type = _el.getAttribute(ATTRIBUTE_JTK_PORT_TYPE) || _el.getAttribute(ATTRIBUTE_JTK_SOURCE_PORT_TYPE) || _el.getAttribute(ATTRIBUTE_JTK_TARGET_PORT_TYPE) || DEFAULT$1;
                  return vertexParent.addPort({
                    id: portId,
                    type: type
                  });
                }
              }
            }
          }

          if (out == null && searchAncestors === true) {
            var parent = _el.parentElement;

            if (parent != null && parent !== _this29.jsplumb.getContainer()) {
              return _one(parent);
            } else {
              return null;
            }
          } else {
            return out;
          }
        };

        return _one(el);
      } // ------------------------------- LAYOUTS -------------------------------------

    }, {
      key: "_createLayout",
      value: function _createLayout(params) {
        var _this30 = this;

        var lp = {
          container: this.containerElement,
          options: params.options || {},
          toolkit: this.toolkitInstance,
          adapter: new CanvasLayoutAdapter(this)
        }; // potentially insert locationFunction, if there isn't one.

        if (!lp.options.locationFunction) {
          lp.options.locationFunction = function (node) {
            return {
              x: data(node.data, _this30._modelLeftAttribute),
              y: data(node.data, _this30._modelTopAttribute)
            };
          };
        }

        return Layouts.get(params.type, lp);
      }
    }, {
      key: "_createGroupLayout",
      value: function _createGroupLayout(params, group) {
        var _this31 = this;

        var containerElement = this._getGroupDragArea(group);

        if (containerElement == null) {
          containerElement = this.jsplumb.getManagedElement(group.id);
        }

        var lp = {
          container: containerElement,
          negativeValuesAllowed: false,
          options: params.options || {},
          toolkit: this.toolkitInstance,
          adapter: new GroupLayoutAdapter(group, this)
        }; // potentially insert locationFunction, if there isn't one.

        if (!lp.options.locationFunction) {
          lp.options.locationFunction = function (node) {
            return {
              x: data(node.data, _this31._modelLeftAttribute),
              y: data(node.data, _this31._modelTopAttribute)
            };
          };
        }

        return Layouts.get(params.type, lp);
      }
      /**
       * Apply the given layout to the viewport, by default refreshing the viewport afterwards.
       * @param layoutParams
       * @param doNotRefresh
       */

    }, {
      key: "setLayout",
      value: function setLayout(layoutParams, doNotRefresh) {
        if (layoutParams) {
          this._layout = this._createLayout(layoutParams);

          if (!doNotRefresh) {
            this.refresh();
          }
        }
      }
      /**
       * Run an adhoc layout on the viewport. The layout will be applied one time, and then the previous layout
       * will be restored (but not run, of course, otherwise the results of this adhoc layout would be overwritten!)
       * @param layoutParams
       */

    }, {
      key: "adHocLayout",
      value: function adHocLayout(layoutParams) {
        if (layoutParams) {
          var _originalLayout = this._layout;
          this.setLayout(layoutParams);
          this._layout = _originalLayout; // (but dont refresh)
        }
      }
      /**
       * For the given vertex, retrieve its position in the viewport, including any current rotation.
       * @param obj
       * @internal
       */

    }, {
      key: "_getViewportPosition",
      value: function _getViewportPosition(obj) {
        return this._getViewportPositionById(obj.id);
      }
      /**
       * For the given vertex id, retrieve its position in the viewport, including any current rotation.
       * @param id
       * @internal
       */

    }, {
      key: "_getViewportPositionById",
      value: function _getViewportPositionById(id) {
        return this.viewport.getPosition(id);
      }
      /**
       * Gets the name of the attributes used to determine location from an object's backing data.
       */

    }, {
      key: "getModelPositionAttributes",
      value: function getModelPositionAttributes() {
        return [this._modelLeftAttribute, this._modelTopAttribute];
      }
      /**
       * Gets the name of the attribute that is used to determine the label for the given edge.
       * @param edge
       */

    }, {
      key: "getLabelLocationAttribute",
      value: function getLabelLocationAttribute(edge) {
        var def = this.view.getEdgeDefinition(this.dataSource.getEdgeType(edge.data || {}));
        return def.labelLocationAttribute || DEFAULT_LABEL_LOCATION_ATTRIBUTE;
      }
      /**
       * Sets whether the given vertex is enabled for connection drag/drop.
       * @param v The vertex to set enabled state for. In the UI this could resolve to an element, or to an Endpoint.
       * @param state
       * @public
       */

    }, {
      key: "setEnabled",
      value: function setEnabled(v, state) {
        var id = v.getFullId();
        var el = this.getRenderedEndpoint(id) || this.getRenderedElement(id) || this.getRenderedPort(id);

        if (el != null) {
          if (isDOMElement(el)) {
            if (state) {
              el.removeAttribute(ATTRIBUTE_JTK_ENABLED);
            } else {
              el.setAttribute(ATTRIBUTE_JTK_ENABLED, FALSE$1);
            }
          } else {
            el.enabled = state;
          }
        }

        return state;
      } // ----------------------------------- rendering -----------------------------------------

      /**
       * For the given object or object ID, retrieve the element that represents it in the UI. This method may return null,
       * specifically in the case that you pass in a Port or Port ID, and that Port is represented as an Endpoint.
       * @param obj
       * @returns HTMLElement that represents the given node, group or port.
       * @public
       */

    }, {
      key: "getRenderedElement",
      value: function getRenderedElement(obj) {
        if (obj == null) {
          return null;
        }

        var id = isString(obj) ? obj : obj.getFullId();
        var parts = id.split(this.toolkitInstance.portSeparator),
            vertex = this.jsplumb.getManagedElement(parts[0]);

        if (vertex && parts.length > 1) {
          var portEl = vertex.querySelector(attWithValue(ATTRIBUTE_JTK_PORT, parts[1])) || vertex.querySelector(attWithValue(ATTRIBUTE_JTK_SOURCE_PORT, parts[1])) || vertex.querySelector(attWithValue(ATTRIBUTE_JTK_TARGET_PORT, parts[1]));

          if (portEl == null) {
            if (this.logicalPorts === true || vertex.getAttribute(ATTRIBUTE_JTK_PORT) === parts[1] || vertex.getAttribute(ATTRIBUTE_JTK_SOURCE_PORT) === parts[1] || vertex.getAttribute(ATTRIBUTE_JTK_TARGET_PORT) === parts[1] || vertex.getAttribute(ATTRIBUTE_JTK_PORT_ID) === parts[1] || vertex.getAttribute(ATTRIBUTE_JTK_SOURCE_PORT_ID) === parts[1] || vertex.getAttribute(ATTRIBUTE_JTK_TARGET_PORT_ID) === parts[1]) {
              return vertex;
            }
          } else {
            return portEl;
          }
        } else {
          return vertex;
        }
      }
      /**
       * Gets the DOM node that was rendered for the Node/Group with the given id.
       * @param vertexId Id for node/group for which to retrieve the rendered element.
       * @returns DOM element for the given vertex id, null if not found.
       * @public
       */

    }, {
      key: "getRenderedVertex",
      value: function getRenderedVertex(vertexId) {
        return this.jsplumb.getManagedElement(vertexId);
      }
      /**
       * Gets the DOM node that was rendered for the Port with the given id (does not retrieve `jtk-endpoint` elements)
       * @param portId Port id for which to retrieve the rendered element. Note that you must supply the "full" id here, that is in dotted
       * notation with the id of the Node on which the port resides.
       * @returns DOM element for the given Port id, null if not found.
       * @public
       */

    }, {
      key: "getRenderedPort",
      value: function getRenderedPort(portId) {
        var parts = portId.split(".");
        var vertexElement = this.getRenderedElement(parts[0]);
        var foundElement = vertexElement ? vertexElement.querySelector(attWithValue(ATTRIBUTE_JTK_PORT, parts[1])) || vertexElement.querySelector(attWithValue(ATTRIBUTE_JTK_TARGET_PORT, parts[1])) || vertexElement.querySelector(attWithValue(ATTRIBUTE_JTK_SOURCE_PORT, parts[1])) || vertexElement : null;
        return foundElement == null ? null : foundElement.tagName.toLowerCase() === ELEMENT_JTK_ENDPOINT ? null : foundElement;
      }
      /**
       * Gets the underlying jsPlumb connection that was rendered for the Edge with the given id.
       * @param edgeId ID of the Edge to retrieve the Connection for.
       * @returns A jsPlumb Connection, null if not found.
       * @public
       */

    }, {
      key: "getRenderedConnection",
      value: function getRenderedConnection(edgeId) {
        return this.connMap[edgeId];
      }
      /**
       * Gets the underlying jsPlumb Endpoint that was rendered for the given Port or Vertex.
       * @param vertexId The Port/Node/Group, or the ID of the Port/Node/Group, to retrieve the Endpoint for.
       * @returns A jsPlumb Endpoint, null if not found.
       * @public
       */

    }, {
      key: "getRenderedEndpoint",
      value: function getRenderedEndpoint(vertexId) {
        return this.jsplumb.getEndpoint(vertexId);
      }
      /**
       * Sets whether rendering is suspended or not.
       * @param val
       * @param thenRefresh If true, the surface will refresh after the change in state.
       * @public
       */

    }, {
      key: "setSuspendRendering",
      value: function setSuspendRendering(val, thenRefresh) {
        this.panZoom.setSuspendRendering(val);
        this._suspendRendering = val;
        this.jsplumb.setSuspendDrawing(val);

        if (thenRefresh) {
          this.refresh();
        }
      }
      /**
       * Associates the given Endpoint with the given Port. Used when ingesting a Community instance.
       * @param port
       * @param endpoint
       * @internal
       */

    }, {
      key: "_ingestEndpoint",
      value: function _ingestEndpoint(port, endpoint) {
        this.jsplumb.setEndpointUuid(endpoint, port.getFullId());
        endpoint.graph = {
          vertex: port.getParent(),
          vertexType: port.getParent().objectType,
          port: port
        };
      }
      /**
       * Repaint the given vertex.
       * @param obj ID of the vertex, or the Vertex object, or the DOM element representing it.
       * @param alsoResetToLayoutPosition Defaults to false. If true, the DOM element representing the Vertex is first repositioned to where the layout thinks it should be.
       * This parameter is mostly intended for internal use.
       * @internal
       */

    }, {
      key: "repaint",
      value: function repaint(obj, alsoResetToLayoutPosition) {
        var info = this.getObjectInfo(obj);

        if (info.el != null && info.obj != null) {
          if (alsoResetToLayoutPosition) {
            var pos = this._layout.getPosition(info.id);

            this.setAbsolutePosition(info.el, pos);
          }

          this.jsplumb.revalidate(info.el);
          this.fire(EVENT_OBJECT_REPAINTED, info);
        }
      }
      /**
       * Expand the given group
       * @param group Group ID, or Group, to expand
       * @public
       */

    }, {
      key: "expandGroup",
      value: function expandGroup(group) {
        this.jsplumb.expandGroup(typeof group === "string" ? group : group.id);
      }
      /**
       * Collapse the given group
       * @param group Group ID, or Group, to collapse
       * @public
       */

    }, {
      key: "collapseGroup",
      value: function collapseGroup(group) {
        this.jsplumb.collapseGroup(typeof group === "string" ? group : group.id);
      }
      /**
       * Expand/collapse the given group, depending on the current state.
       * @param group Group ID, or Group, to expand/collapse.
       * @public
       */

    }, {
      key: "toggleGroup",
      value: function toggleGroup(group) {
        this.jsplumb.toggleGroup(typeof group === "string" ? group : group.id);
      }
      /**
       * Run the group auto size routine on every group in the Surface.
       * @param force If true, this flag will override any `autoSize:false` directives on the groups in the Surface.
       * @public
       */

    }, {
      key: "autoSizeGroups",
      value: function autoSizeGroups(force) {
        var _this32 = this;

        this.jsplumb.groupManager.forEach(function (g) {
          var group = _this32.dataSource.getGroup(g.id);

          if (group) {
            var _def5 = _this32.view.getGroupDefinition(_this32.dataSource.getNodeType(group.data));

            _this32._autoSizeAGroup(group, _def5, null, force);
          }
        });
      }
      /**
       * Run the group auto size routine on a given groups.
       * @param group The group to auto size
       * @param force If true, this flag will override an `autoSize:false` directive on the Group.
       * @public
       */

    }, {
      key: "sizeGroupToFit",
      value: function sizeGroupToFit(group, force) {
        if (group) {
          var _def6 = this.view.getGroupDefinition(this.dataSource.getNodeType(group.data));

          this._autoSizeAGroup(group, _def6, null, force);
        }
      }
      /**
       * Sets the size of element representing the given vertex in the DOM, updating the layout.
       * @param id
       * @param w
       * @param h
       * @public
       */

    }, {
      key: "setSize",
      value: function setSize$1(id, w, h) {
        var info = this.getObjectInfo(id);

        if (info.obj && info.el) {
          var layoutToUse = isNodeInsideAGroup(info.obj) || isNestedGroup(info.obj) ? this._layoutMap.get(info.obj.group.id) : this._layout;
          layoutToUse.setSize(info.obj.getFullId(), {
            w: w,
            h: h
          });

          setSize(info.el, w, h);
        }
      }
      /**
       * Gets the underlying connection for the given Edge. Used internally.
       * @param edge
       */

    }, {
      key: "getConnectionForEdge",
      value: function getConnectionForEdge(edge) {
        return this.connMap[edge.getId()];
      }
      /**
       * Gets an array of Connections for the given array of Edges.
       * @param edges
       */

    }, {
      key: "getConnectionsForEdges",
      value: function getConnectionsForEdges(edges) {
        var c = [];

        for (var i = 0; i < edges.length; i++) {
          c.push(this.connMap[edges[i].getId()]);
        }

        return c;
      } // ------------------------------------- PRIVATE ----------------------------------------------------------------------

    }, {
      key: "beforeDrop",
      value: function beforeDrop(params) {
        var c = params.connection,
            s = this.getModelObjectFromEndpoint(c.endpoints[0]),
            t = this.getModelObjectFromEndpoint(params.dropEndpoint),
            e = params.connection.edge;
        if (e == null) return this.dataSource.beforeConnect(s, t, c.getData());else return this.dataSource.beforeMoveConnection(s, t, e);
      }
    }, {
      key: "beforeDrag",
      value: function beforeDrag(params) {
        var context = params.endpoint.parameters,
            vertex = this.toolkitInstance.getNode(context.vertexId),
            modelObject = context.portId ? vertex.addPort({
          id: context.portId,
          type: context.portType
        }) : vertex,
            cType = params.endpoint.edgeType,
            toolkitResponse = this.dataSource.beforeStartConnect(modelObject, cType);

        if (this._debug) {
          var edgeDefinition = this.view.getEdgeDefinition(cType) || {};
          console.log("\n------------------------\nDrag started with edge type `" + cType + "`, having definition :");
          console.log(edgeDefinition);
          console.log("Edge source is a " + modelObject.objectType + ", having type [" + modelObject.getType() + "], with definition :");
          var sourceDefinition = this.view["get" + modelObject.objectType + "Definition"](modelObject.getType()) || {};
          console.log(sourceDefinition);
          console.log("Toolkit response to drag start :");
          console.log(toolkitResponse);
          console.log("---------------------------\n");
        } // if drag not allowed and this is a temporary endpoint, delete it.


        if (toolkitResponse === false && params.endpoint.isTemporarySource && params.endpoint._deleteOnDetach) {
          this.jsplumb.deleteEndpoint(params.endpoint);
        }

        return toolkitResponse;
      }
    }, {
      key: "beforeDetach",
      value: function beforeDetach(connection, isDiscard) {
        var s = this.getModelObjectFromEndpoint(connection.endpoints[0]),
            t = this.getModelObjectFromEndpoint(connection.endpoints[1]),
            e = connection.edge;
        return this.dataSource.beforeDetach(s, t, e, isDiscard);
      }
    }, {
      key: "beforeStartDetach",
      value: function beforeStartDetach(params) {
        var modelObject = this.getModelObjectFromEndpoint(params.endpoint),
            e = params.connection.edge;
        return this.dataSource.beforeStartDetach(modelObject, e);
      }
    }, {
      key: "_fireEdgeRemoved",
      value: function _fireEdgeRemoved(edge) {
        this.fire(EVENT_EDGE_REMOVED, {
          sourceNodeId: resolveNodeId(edge.source),
          targetNodeId: resolveNodeId(edge.target),
          sourcePortId: resolvePortId(edge.source),
          targetPortId: resolvePortId(edge.target),
          sourceId: edge.source.getFullId(),
          targetId: edge.target.getFullId(),
          source: edge.source,
          target: edge.target,
          edge: edge
        });
      }
    }, {
      key: "_loadStartFn",
      value: function _loadStartFn() {
        this.setSuspendRendering(true);
      }
    }, {
      key: "_appendStartFn",
      value: function _appendStartFn() {
        this.setSuspendRendering(true);
      }
    }, {
      key: "_loadEndFn",
      value: function _loadEndFn(noDataWasLoaded) {
        this.setSuspendRendering(false, !noDataWasLoaded);

        if (!noDataWasLoaded) {
          this._assignPendingDragGroups();

          this.relayout();
          this.jsplumb.repaintEverything();
        }

        if (this._layout) {
          this.fire(EVENT_DATA_LOAD_END);
        }

        if (this.zoomToFitOnLoad && !noDataWasLoaded) {
          this.zoomToFit();
        }
      }
    }, {
      key: "_appendEndFn",
      value: function _appendEndFn() {
        this.setSuspendRendering(false); // assign all dragGroup that were not assigned due to rendering suspended.

        this._assignPendingDragGroups();

        this.refresh();
        this.jsplumb.setSuspendDrawing(false, true);

        if (this._layout) {
          this.fire(EVENT_DATA_APPEND_END);
        }
      }
      /**
       * Appends the element for the given node to the element for the given group. For internal use.
       * @param nodeEl
       * @param n
       * @param group
       * @internal
       */

    }, {
      key: "_appendNodeToGroup",
      value: function _appendNodeToGroup(nodeEl, n, group) {
        var groupEl = this.jsplumb.getManagedElement(group.id);

        if (groupEl) {
          var target = groupEl.querySelector(att(ATTRIBUTE_GROUP_CONTENT)) || groupEl;
          target.appendChild(nodeEl);
          this.jsplumb.addToGroup(group.id, nodeEl);

          this._layoutMap.get(group.id).vertexAdded({
            el: nodeEl,
            vertex: n
          });

          this.panZoom.suspend(nodeEl);
        }
      }
      /**
       * Extract endpoint definitions from the given element. For internal use.
       * @param el
       * @internal
       */

    }, {
      key: "_extractEndpointsFromVertex",
      value: function _extractEndpointsFromVertex(el) {
        var out = []; // Find `data-jtk-endpoint` elements that are children of this vertex

        var endpointElements = el.querySelectorAll([att(ATTRIBUTE_JTK_ENDPOINT), ELEMENT_JTK_ENDPOINT].join(","));
        forEach(endpointElements, function (endpointElement) {
          var def = _extractEndpointDefinitionFromValueSource(new AttributeExtractor(endpointElement));

          var isElement = endpointElement.tagName.toUpperCase() === ELEMENT_JTK_ENDPOINT.toUpperCase();

          if (!isElement || def.portId != null) {
            out.push([def, endpointElement]);
          } else if (isElement) {
            log("jsPlumb: jtk-endpoint element missing `data-jtk-port` attribute; not processed");
          }
        });

        if (el.getAttribute(ATTRIBUTE_JTK_ENDPOINT) != null) {
          var _def7 = _extractEndpointDefinitionFromValueSource(new AttributeExtractor(el));

          out.push([_def7, el]);
        }

        return out;
      }
      /**
       * Extract endpoint definitions from the given element. For internal use.
       * @param el
       * @internal
       */

    }, {
      key: "_extractEndpointFromElementAndDefinition",
      value: function _extractEndpointFromElementAndDefinition(el, obj) {
        var _this33 = this;

        // first get a list extracted from the DOM
        var specs = this._extractEndpointsFromVertex(el); // will always return at least an empty list.


        forEach(specs, function (_ref5) {
          var _ref6 = _slicedToArray$2(_ref5, 2),
              def = _ref6[0],
              element = _ref6[1];

          var port;
          var spec = extend({}, def);

          if (def.portId != null) {
            port = obj.addPort({
              id: def.portId,
              type: def.portType
            });
            spec.uuid = port.getFullId();
            spec.data = port.data;
          }

          if (spec.uuid == null) {
            if (def.portId) {
              spec.uuid = obj.id + "." + def.portId;
            } else if (element === el) {
              spec.uuid = obj.id;
            }
          }

          var portDefinition = _this33.view.getPortDefinition(def.portType || DEFAULT$1);

          if (portDefinition != null) {
            extend(spec, portDefinition);
          } //spec.element = element


          spec.element = el;

          var endpoint = _this33.jsplumb._internal_newEndpoint(spec);

          endpoint.mergeParameters(filterNull({
            vertexId: obj.id,
            portId: def.portId,
            portType: def.portType,
            edgeType: def.edgeType
          }));
        });
      }
      /**
       * Renders the given node. For internal use.
       * @param n
       * @param eventInfo
       * @internal
       */

    }, {
      key: "_doRenderNode",
      value: function _doRenderNode(n, eventInfo) {
        // does an element for this node already exist?
        var nodeEl = this.jsplumb.getManagedElement(n.id);

        if (nodeEl == null) {
          // check node definition to see if we should ignore it.
          var nd = this.getNodeDefinition(n);

          if (nd.ignore !== true) {
            this.nodeRenderer(n, n.data, n, nd, eventInfo);
          }
        }
      }
      /**
       * Renders the given group. For internal use.
       * @param g
       * @param eventInfo
       * @internal
       */

    }, {
      key: "_doRenderGroup",
      value: function _doRenderGroup(g, eventInfo) {
        // does a DOM element for this Group already exist?
        var groupEl = this.jsplumb.getManagedElement(g.id);

        if (groupEl == null) {
          // check definition to see if we should ignore it.
          var gd = this.getGroupDefinition(g);

          if (gd.ignore !== true) {
            if (gd.ghost === true) {
              gd.ghostProxyParent = this.containerElement;
            }

            this.groupRenderer(g, g.data, g, gd, eventInfo);
          }
        }
      }
      /**
       * Checks the list of edges that are currently unrendered to see if there are any for which the vertices have now
       * been rendered, and therefore the edge can be rendered.  For internal use.
       * @internal
       */

    }, {
      key: "_flushUnrenderedEdges",
      value: function _flushUnrenderedEdges() {
        var stillUnrendered = [];

        for (var i = 0; i < this.unrenderedEdges.length; i++) {
          var c = this._maybeRenderEdge(this.unrenderedEdges[i]);

          if (c == null) {
            stillUnrendered.push(this.unrenderedEdges[i]);
          }
        }

        this.unrenderedEdges = stillUnrendered;
      }
    }, {
      key: "_prepareConnectionParams",
      value: function _prepareConnectionParams(edge) {
        var _this34 = this;

        var type = this.dataSource.getEdgeType(edge.data),
            p = {
          type: type,
          edgeType: type,
          // pass the 'data' object in; it is used if the edge type is parameterised at all.
          data: edge.data,
          cost: edge.getCost(),
          directed: edge.isDirected(),
          geometry: edge.geometry,
          ports: []
        },
            td = this.view.getEdgeDefinition(type); // extra properties not supported by jsPlumb's type system: connector and endpoints/endpoint:

        (function (props) {
          if (td) {
            for (var k = 0; k < props.length; k++) {
              if (td[props[k]]) p[props[k]] = td[props[k]];
            }
          }
        })(["connector", "endpoints", "endpoint", "endpointStyles", "endpointStyle", "cssClass", "hoverClass"]); // expand 'anchor' out to 'anchors', if present (allows easier override below)


        if (p.anchor && !p.anchors) {
          p.anchors = [p.anchor, p.anchor];
          delete p.anchor;
        } // expand 'endpoint' out to 'endpoints', if present (allows easier override below)


        if (p.endpoint && !p.endpoints) {
          p.endpoints = [p.endpoint, p.endpoint];
          delete p.endpoint;
        }

        var _substituteParameter = function _substituteParameter(toObj, plural, singular, fromObj, idx) {
          if (fromObj && fromObj[singular]) {
            var prop = toObj[plural] || [fromObj[singular], fromObj[singular]];
            prop[idx] = fromObj[singular];
            toObj[plural] = prop;
          }
        };

        var _one = function _one(v, name, idx) {
          if (isPort(v)) {
            var n = v.getParent(),
                portIdentifier = v.getFullId(),
                ep = _this34.jsplumb.getEndpoint(portIdentifier) || _this34.getRenderedPort(portIdentifier); // use the endpoint or port, and if those are null, the vertex element.


            p[name] = ep || _this34.jsplumb.getManagedElement(_this34.dataSource.getNodeId(n.data)); // get the port definition for the type of this port and (maybe) copy in anchor/endpoint specs to the connection parameters

            var portDef = _this34.view.getPortDefinition(v.getType()); // TODO this looks a bit like what core does in connection params.


            _substituteParameter(p, "anchors", "anchor", portDef, idx);

            _substituteParameter(p, "endpoints", "endpoint", portDef, idx);

            p.ports[idx] = v.id;
          } else {
            // the source/target is a Vertex. We want to see if an endpoint exists for it whose uuid is the ID of this vertex
            // the only way this could have happened is with a `data-jtk-endpoint="true"` attribute on the root element of some
            // vertex. If an endpoint doesnt exist we use the element. The `parameterExtractor` defined in the Surface constructor can
            // pull out related port information if we nwant it to.
            var vertexId = edge[name].id;

            var _ep = _this34.jsplumb.getEndpoint(vertexId);

            p[name] = _ep || _this34.jsplumb.getManagedElement(vertexId);
          }
        };

        _one(edge.source, "source", 0);

        _one(edge.target, "target", 1);

        p.doNotFireConnectionEvent = true;
        return p;
      }
    }, {
      key: "__bindToToolkit",
      value: function __bindToToolkit(evt, fn) {
        this._boundToolkitEvents.push({
          event: evt,
          fn: fn
        });

        this.dataSource.bind(evt, fn, true);
      }
    }, {
      key: "_bindToolkitEvents",
      value: function _bindToolkitEvents() {
        var _this35 = this;

        this.__bindToToolkit(EVENT_NODE_ADDED, function (params) {
          var n = params.node;

          if (_this35.objectFilter(n)) {
            _this35._doRenderNode(n, params.eventInfo);
          }
        }); //
        // Notification a Node was removed - this function removes all UI components, and then calls refresh on the layout if there is
        // one.
        //


        this.__bindToToolkit(EVENT_NODE_REMOVED, function (params) {
          var groupId = params.parentGroup ? params.parentGroup.id : isNodeInsideAGroup(params.node) || isNestedGroup(params.node) ? params.node.group.id : null;
          var layout = groupId != null ? _this35._layoutMap.get(groupId) : _this35._layout; // we want to store this position in the event that the node removal is undone, and the node is added back to the dataset.
          // so we pass it out in the ndoe removed event, and the undo manager
          // stashes it

          var currentPosition = layout.getPosition(params.node.id); // update the layout

          layout.vertexRemoved(params.node);

          var el = _this35.jsplumb.getManagedElement(params.nodeId);

          if (params.parentGroup) {
            _this35.jsplumb.removeFromGroup(params.parentGroup.id, el, true);
          }

          _this35.fire(EVENT_NODE_REMOVED, {
            vertex: params.node,
            el: el,
            pos: currentPosition
          });

          _this35.jsplumb.unmanage(el);

          _this35.templateRenderer.cleanupVertex(params.nodeId, el);

          removeWithFunction(_this35.vertexList, function (n) {
            return n.id === params.node.id;
          });
          delete el["jtk"];

          _this35.refresh(true);
        });

        this.__bindToToolkit(EVENT_GROUP_MEMBER_ADDED$1, function (p) {
          var nodeEl = _this35.jsplumb.getManagedElement(p.vertex.id);

          if (nodeEl) {
            _this35.panZoom.suspend(nodeEl); // if a new position was given and this node has positioning info in its data,
            // set those values to the new position.


            if (p.pos) {
              if (p.vertex.data[_this35._modelLeftAttribute] != null) {
                p.vertex.data[_this35._modelLeftAttribute] = p.pos.x;
              }

              if (p.vertex.data[_this35._modelTopAttribute] != null) {
                p.vertex.data[_this35._modelTopAttribute] = p.pos.y;
              }
            }

            _this35.fire(EVENT_GROUP_MEMBER_ADDED$1, {
              vertex: p.vertex,
              group: p.group,
              uigroup: _this35.jsplumb.getGroup(p.group.id),
              sourceGroup: p.sourceGroup,
              pos: p.pos,
              el: nodeEl,
              groupEl: _this35.jsplumb.getManagedElement(p.group.id)
            });

            if (p.source !== _this35) {
              _this35.jsplumb.addToGroup(p.group.id, nodeEl);
            }

            _this35._layout.vertexRemoved(p.vertex);

            if (p.sourceGroup) {
              _this35._layoutMap.get(p.sourceGroup.id).vertexRemoved(p.vertex);
            }

            _this35._layoutMap.get(p.group.id).vertexAdded({
              el: nodeEl,
              pos: p.pos,
              vertex: p.vertex
            }); // run the layout.


            if (!_this35._suspendRendering) {
              _this35._relayoutGroup(p.group);
            }
          }
        });

        this.__bindToToolkit(EVENT_GROUP_MEMBER_REMOVED$1, function (p) {
          var nodeEl = _this35.jsplumb.getManagedElement(p.vertex.id);

          if (nodeEl) {
            var newLayout = null; // dont inform community edition if this component was the source of this event (because this component itself was told by
            // the community edition in the first place)

            if (p.source !== _this35) {
              _this35.jsplumb.removeFromGroup(p.group.id, nodeEl);
            }

            _this35._layoutMap.get(p.group.id).vertexRemoved(p.vertex);

            if (p.targetGroup) {
              newLayout = _this35._layoutMap.get(p.targetGroup.id);
              newLayout.vertexAdded({
                el: nodeEl,
                vertex: p.vertex
              });
            } else {
              newLayout = _this35._layout;
              newLayout.vertexAdded({
                el: nodeEl,
                vertex: p.vertex
              }); // notify the layout of the new position.

              var newOffset = _this35.jsplumb.getOffset(nodeEl);

              _this35._layout.setPosition(p.vertex.id, newOffset.x, newOffset.y);

              if (_this35._storePositionsInModel) {
                _this35.storePositionInModel(p.vertex.id);
              }
            }

            _this35.panZoom.restore(nodeEl);

            _this35.fire(EVENT_GROUP_MEMBER_REMOVED$1, extend(p, {
              el: nodeEl,
              groupEl: _this35.jsplumb.getManagedElement(p.group.id),
              pos: newLayout.getPosition(p.vertex.id)
            }));

            if (!_this35._suspendRendering) {
              _this35._relayoutGroup(p.group);
            }
          }
        });

        this.__bindToToolkit(EVENT_GROUP_ADDED$1, function (params) {
          var g = params.group;

          if (_this35.objectFilter(g)) {
            _this35._doRenderGroup(g, params.eventInfo);
          }
        });

        this.__bindToToolkit(EVENT_GROUP_REMOVED$1, function (params) {
          var g = params.group;
          var groupId = params.parentGroup ? params.parentGroup.id : null; //isNodeInsideAGroup(params.group) || isNestedGroup(params.group) ? params.group.group.id : null

          var layout = groupId != null ? _this35._layoutMap.get(groupId) : _this35._layout;
          var currentPosition = layout.getPosition(params.group.id); // update the layout

          layout.vertexRemoved(g);

          var el = _this35.jsplumb.getManagedElement(g.id);

          var newDOMPositions = _this35.jsplumb.removeGroup(g.id, params.removeChildren, true, true),
              // last arg used to be false
          newNodePositions = null;

          if (newDOMPositions != null) {
            newNodePositions = {};

            for (var domNodeId in newDOMPositions) {
              var vertex = _this35.toolkitInstance.getVertex(domNodeId);

              if (vertex != null) {
                if (vertex.group == null) {
                  _this35.panZoom.restore(vertex.id);
                }

                _this35._setPosition({
                  vertex: vertex,
                  x: newDOMPositions[domNodeId].x,
                  y: newDOMPositions[domNodeId].y,
                  doNotUpdateElement: true
                });

                newNodePositions[vertex.id] = {
                  x: newDOMPositions[domNodeId].x,
                  y: newDOMPositions[domNodeId].y
                };
              } else {
                log("Could not reposition element removed from group - no DOM node found.");
              }
            }
          }

          _this35.fire(EVENT_GROUP_REMOVED$1, {
            el: el,
            vertex: g,
            children: params.children,
            childrenRemoved: params.removeChildren,
            childPositions: newNodePositions,
            pos: currentPosition
          });

          _this35.templateRenderer.cleanupVertex(g.id, el);

          removeWithFunction(_this35.vertexList, function (g) {
            return g.id === params.group.id;
          });
          delete el["jtk"];
        });

        this.__bindToToolkit(EVENT_EDGE_ADDED, function (data) {
          if (!_this35._ignoreToolkitEvents) {
            // if this event didnt come from mouse activity in this surface, render it
            if (data.source !== _this35) {
              var edge = data.edge;

              if (_this35.objectFilter(edge.source) && _this35.objectFilter(edge.target)) {
                var _def8 = _this35.view.getEdgeDefinition(_this35.dataSource.getEdgeType(edge.data || {}));

                if (_def8 && _def8.ignore === true) return;

                _this35._enqueueEdge(edge, true);
              }
            } // else {
            //     // if this event did come from mouse activity we have already got a rendered connection but we might
            //     // want to refresh the layout.
            //     if (this.refreshLayoutOnEdgeConnect) {
            //         this.refresh(true)
            //     }
            // }

          }
        }); //
        // Notification that an edge was removed. We want to remove the corresponding connection from our jsPlumb instance.
        //


        this.__bindToToolkit(EVENT_EDGE_REMOVED, function (data) {
          if (!_this35._ignoreToolkitEvents && data.source !== _this35) {
            var edge = data.edge;

            var connection = _this35.connMap[edge.getId()];

            if (connection) {
              if (_this35.dataSource.debugEnabled) console.log("Renderer", "removing edge", edge);

              _this35._fireEdgeRemoved(edge);

              delete _this35.connMap[edge.getId()];

              _this35.jsplumb.deleteConnection(connection, {
                fireEvent: false
              });
            }
          }
        });

        this.__bindToToolkit(EVENT_EDGE_TYPE_CHANGED, function (data) {
          if (!_this35._ignoreToolkitEvents && data.source !== _this35) {
            var edge = data.obj;

            var connection = _this35.connMap[edge.getId()];

            if (connection) {
              var _def9 = _this35.view.getEdgeDefinition(data.newType);

              if (_def9 && _def9.ignore === true) return;

              if (_def9.endpoint || _def9.endpoints) {
                connection.replaceEndpoint(0, _def9.endpoints ? _def9.endpoints[0] : _def9.endpoint);
                connection.replaceEndpoint(1, _def9.endpoints ? _def9.endpoints[1] : _def9.endpoint);
              }

              if (_def9.connector) {
                connection.setConnector(_def9.connector);
              }

              connection.setType(data.newType, edge.data);
            }
          }
        }); // Notification that the target of an edge was changed


        this.__bindToToolkit(EVENT_EDGE_TARGET_CHANGED, function (data) {
          if (!_this35._ignoreToolkitEvents) {
            var edge = data.edge;

            var connection = _this35.connMap[edge.getId()];

            var fullId = edge.target.getFullId();

            var n = _this35.jsplumb.getManagedElement(fullId) || _this35.jsplumb.getEndpoint(fullId) || _this35.getRenderedElement(fullId);

            if (connection) {
              _this35.jsplumb.silently(function () {
                if (n != null) {
                  if (_this35.dataSource.debugEnabled) console.log("target change", connection);

                  _this35.jsplumb.setTarget(connection, n);
                } else {
                  delete _this35.connMap[edge.getId()];

                  _this35.jsplumb.deleteConnection(connection, {
                    force: true,
                    fireEvent: false
                  });
                }
              });
            } else {
              if (n != null) {
                if (_this35.dataSource.debugEnabled) {
                  console.log("Target for Edge " + edge.getId() + " changed to Node " + n.id + "; we have no valid connection.");
                }
              }
            }
          }
        }); // Notification that the source of an edge was changed


        this.__bindToToolkit(EVENT_EDGE_SOURCE_CHANGED, function (data) {
          if (!_this35._ignoreToolkitEvents) {
            var edge = data.edge;

            var connection = _this35.connMap[edge.getId()];

            var fullId = edge.source.getFullId();

            var n = _this35.jsplumb.getManagedElement(fullId) || _this35.jsplumb.getEndpoint(fullId) || _this35.getRenderedElement(fullId);

            if (connection) {
              _this35.jsplumb.silently(function () {
                if (n != null) {
                  _this35.jsplumb.setSource(connection, n);
                } else {
                  delete _this35.connMap[edge.getId()];

                  _this35.jsplumb.deleteConnection(connection, {
                    force: true,
                    fireEvent: false
                  });
                }
              });
            } else {
              if (n != null) {
                if (_this35.dataSource.debugEnabled) {
                  console.log("Source for Edge " + edge.getId() + " changed to Node " + edge.source.getFullId() + "; we have no valid connection.");
                }
              }
            }
          }
        });

        this.__bindToToolkit(EVENT_EDGE_PATH_RESTORED, function (params) {
          if (params.renderer.id === _this35.id) {
            var connection = _this35.getRenderedConnection(params.edge.getId());

            if (params.geometry != null) {
              connection.connector.importGeometry(params.geometry);

              _this35.jsplumb.revalidate(connection.source);
            } else {
              connection.connector.resetGeometry();
            }
          }
        }); //
        // Notification that the graph was cleared. We remove everything from our jsPlumb instance (but do not
        // unbind any event listeners).
        //


        this.__bindToToolkit(EVENT_GRAPH_CLEAR_START, function () {
          _this35.jsplumb.reset(); // clear decoration


          for (var i = 0; i < _this35.decorators.length; i++) {
            _this35.decorators[i].reset({
              remove: function remove(el) {
                return el.parentNode && el.parentNode.removeChild(el);
              }
            });
          }

          _this35.panZoom.reset();

          forEach(_this35.plugins, function (p) {
            return p.reset();
          });
          forEach(_this35.vertexList, function (n) {
            var nodeEl = _this35.jsplumb.getManagedElement(n.id);

            if (nodeEl != null) {
              _this35.templateRenderer.cleanupVertex(n.id, nodeEl);
            }
          });
          _this35._layout && _this35._layout._reset();
          _this35.vertexList.length = 0;
          _this35.connMap = {};

          _this35._layoutMap.clear();

          _this35.jsplumb.setZoom(_this35.getZoom());
        }); //
        // Notification that a new port was added to some node.  We want to find the corresponding element for the
        // given node, then render the portData using the current rendering mechanism, and finally hand off the node's
        // element and the renderer port element to a helper function (supplied as 'portAdded' to the constructor), for
        // the application to insert the port's UI component at the appropriate location. If no 'portAdded' callback
        // was supplied, we just append the port to the node.
        //
        // For an example of this, consider the database visualizer demo app.  when the user adds a new column it is
        // added as a 'port' to the table node.  We are given the portData and we render it using the column
        // template, but then where does this column get added?  We hand off to the app, and the app knows that it
        // should add the element to the UL that contains the table's columns.
        //


        this.__bindToToolkit(EVENT_PORT_ADDED, function (params) {
          var nodeEl = _this35.jsplumb.getManagedElement(params.vertex.id); // get the port element rendered, and then hand it off to the helper, which is responsible for
          // appending it to the appropriate place in the UI.


          var def = _this35.view.getPortDefinition(_this35.dataSource.getPortType(params.data));

          if (def.isEndpoint) {
            var portElement = _this35.getRenderedPort(params.port.getFullId());

            var endpointOptions = extend({
              parameters: {
                vertexId: params.vertex.id,
                portId: params.port.id,
                portType: params.port.getType()
              },
              uuid: params.port.getFullId(),
              data: params.port.data
            }, def);

            var definitionFromData = _extractEndpointDefinitionFromValueSource(new ObjectValueExtractor(params.data, "data-jtk-"));

            extend(endpointOptions, definitionFromData);
            endpointOptions.element = portElement || nodeEl;

            _this35.jsplumb._internal_newEndpoint(endpointOptions);
          } else {
            var existingElement = _this35.getRenderedPort(params.port.getFullId());

            if (!existingElement) {
              _this35.portRenderer(params.port, params.data, params.vertex, def, null);
            }
          }

          _this35.jsplumb.revalidate(nodeEl);

          _this35.refresh(true);
        }); //
        // Notification that a port was removed from some node.  We want to retrieve the associated node and
        // port elements, then hand off to a helper function (supplied as 'portRemoved' to the constructor) for
        // the application to remove the port's UI component.  If no 'portRemoved' callback was supplied we just
        // attempt to remove the port's element from its parent (which, for many applications, is probably
        // sufficient).
        //


        this.__bindToToolkit(EVENT_PORT_REMOVED, function (params) {
          var vertexEl = _this35.jsplumb.getManagedElement(params.vertex.id),
              pId = params.port.getFullId(),
              portEl = _this35.getRenderedPort(pId),
              ep = _this35.jsplumb.getEndpoint(pId);

          if (ep != null) {
            _this35.jsplumb.deleteEndpoint(ep);

            _this35.refresh(true);
          } else if (portEl != null) {
            // in some cases a port can be represented by the same element as its parent, in which case we do not want to
            // unmanage the element
            if (vertexEl !== portEl) {
              // remove the port element (suspend events while doing so)
              _this35.jsplumb.setSuspendEvents(true);

              _this35.jsplumb.unmanage(portEl);

              _this35.templateRenderer.cleanupPort(pId, portEl);

              _this35.jsplumb.setSuspendEvents(false);
            }

            _this35.fire(EVENT_PORT_REMOVED, {
              //node: params.vertex,
              vertex: params.vertex,
              port: params.port,
              portEl: portEl,
              //nodeEl: vertexEl,
              vertexEl: vertexEl
            }); // TODO another example of why we want type members: here, `nodeEl` should be of whatever type the jsplumb instance will render,
            // which is done as a clumsy generic parameter currently, and which cannot be referenced to use as a type here.


            _this35.jsplumb.revalidate(vertexEl);

            _this35.refresh(true);
          }
        }); //
        // Notification that an edge was updated.
        //


        this.__bindToToolkit(EVENT_EDGE_UPDATED, function (p) {
          var conn = _this35.connMap[p.edge.getId()];

          if (conn) {
            var newConnectionParameters = _this35._prepareConnectionParams(p.edge);

            conn.setType([Constants["default"], newConnectionParameters.type].join(" "), newConnectionParameters.data);
          }
        }); //
        // Notification that a port was updated
        //


        this.__bindToToolkit(EVENT_PORT_UPDATED, function (p) {
          var portEl = _this35.getRenderedPort(p.originalId);

          if (portEl) {
            if (_this35.templateRenderer.reactive === false) {
              _this35.templateRenderer.update(portEl, p.port.data, _this35);
            } // repaint the port's node element, not just the port's element.


            _this35.repaint(_this35.jsplumb.getManagedElement(p.vertex.id));
          }
        }); //
        // Notification that a node was updated.
        //


        this.__bindToToolkit(EVENT_NODE_UPDATED, function (p) {
          _this35._vertexUpdated(p.vertex);
        }); //
        // Notification that a group was updated.
        //


        this.__bindToToolkit(EVENT_GROUP_UPDATED, function (p) {
          _this35._vertexUpdated(p.vertex);
        });

        this.__bindToToolkit(Constants.select, function (d) {
          if (isNode(d.obj) || isGroup(d.obj)) {
            var el = _this35.getRenderedElement(d.obj.id);

            if (el) {
              addClass(el, CLASS_SURFACE_SELECTED_ELEMENT);

              _this35.jsplumb.addToDragSelection(el);
            }
          } else if (isEdge(d.obj)) {
            var conn = _this35.getConnectionForEdge(d.obj);

            if (conn) {
              conn.addClass(CLASS_SURFACE_SELECTED_CONNECTION);
            }
          }
        });

        this.__bindToToolkit(EVENT_SELECTION_CLEARED, function () {
          _this35.jsplumb.clearDragSelection();

          forEach(_this35.jsplumb.getSelector(_this35.jsplumb.getContainer(), "." + CLASS_SURFACE_SELECTED_CONNECTION), function (el) {
            return removeClass(el, CLASS_SURFACE_SELECTED_CONNECTION);
          });
          forEach(_this35.jsplumb.getSelector(_this35.jsplumb.getContainer(), "." + CLASS_SURFACE_SELECTED_ELEMENT), function (el) {
            return removeClass(el, CLASS_SURFACE_SELECTED_ELEMENT);
          });
        });

        this.__bindToToolkit(EVENT_DESELECT, function (d) {
          if (isNode(d.obj) || isGroup(d.obj)) {
            var el = _this35.getRenderedElement(d.obj.id);

            if (el) {
              removeClass(el, CLASS_SURFACE_SELECTED_ELEMENT);

              _this35.jsplumb.removeFromDragSelection(el);
            }
          } else if (isEdge(d.obj)) {
            var conn = _this35.getConnectionForEdge(d.obj);

            if (conn) {
              conn.removeClass(CLASS_SURFACE_SELECTED_CONNECTION);
            }
          }
        });

        this.__bindToToolkit(EVENT_DATA_LOAD_START, this._loadStartFn.bind(this));

        this.__bindToToolkit(EVENT_DATA_APPEND_START, this._appendStartFn.bind(this));

        this.__bindToToolkit(EVENT_DATA_LOAD_END, this._loadEndFn.bind(this));

        this.__bindToToolkit(EVENT_DATA_APPEND_END, this._appendEndFn.bind(this));
      }
    }, {
      key: "_vertexUpdated",
      value: function _vertexUpdated(v) {
        if (v != null) {
          var el = this.jsplumb.getManagedElement(v.getFullId());

          if (el) {
            if (this.templateRenderer.reactive === false) {
              this.templateRenderer.update(el, v.data, this);
            }

            this._doAssignDragGroup(el, v);

            this.repaint(el);
          }
        }
      }
      /**
       * Resize a group so that its content area shows all the child nodes.
       * @param group
       * @param def
       * @internal
       */

    }, {
      key: "_autoSizeAGroup",
      value: function _autoSizeAGroup(group, def, movedElements, force) {
        var doResize = force || def.autoShrink || def.autoGrow || def.autoSize;
        var shrink = def.autoShrink === true || def.autoSize === true && def.autoShrink !== false;
        var grow = def.autoGrow === true || def.autoSize === true && def.autoGrow !== false;

        if (!doResize) {
          return null;
        }

        movedElements = movedElements || {};

        var uiGroup = this.jsplumb.getGroup(group.id),
            groupEl = this.jsplumb.getGroupContentArea(uiGroup),
            extents = this._layoutMap.get(group.id)._getExtents(),
            maximums = def.maxSize || [extents.xmax, extents.ymax],
            w = Math.min(maximums[0], extents.xmax),
            h = Math.min(maximums[1], extents.ymax),
            currentSize = this.jsplumb.getSize(groupEl),
            currentGroupParentSize = this.jsplumb.getSize(uiGroup.el),
            currentWidth = Math.max(currentSize.w, currentGroupParentSize.w),
            currentHeight = Math.max(currentSize.h, currentGroupParentSize.h); // if a grid is set, we want to try to get the group to be some multiple of the grid. where the computed size lies
        // between two grid lines, we take furthest grid line as the size to use.


        if (this.gridProfile.grid && this.gridProfile.fitGroupsToGrid !== false) {
          var _w = w / this.gridProfile.grid.w;

          w = this.gridProfile.grid.w * Math.ceil(_w);

          var _h = h / this.gridProfile.grid.h;

          h = this.gridProfile.grid.h * Math.ceil(_h);
        } // apply the extents to the group's drawing area


        groupEl.style.width = w + "px";
        groupEl.style.height = h + "px"; // then, get back from the dom what the _actual_ size is, as CSS may come into play
        // set this actual size on the page layout

        var actualGroupSize = this.jsplumb.getSize(uiGroup.el);
        var dx = actualGroupSize.w - currentWidth;
        var dy = actualGroupSize.h - currentHeight; // if autoShrink is not true (it is false by default), then test each axis to see if the
        // element has shrunk, and if so, restore it to its previous size.

        if (!force && shrink === false) {
          var d = false;

          if (dx < 0) {
            groupEl.style.width = currentWidth + "px";
            dx = 0;
            d = true;
          }

          if (dy < 0) {
            groupEl.style.height = currentHeight + "px";
            dy = 0;
            d = true;
          }

          if (d) {
            // if either axis was adjusted, go back to the DOM to get the actual size
            actualGroupSize = this.jsplumb.getSize(uiGroup.el);
          }
        }

        if (!force && grow === false) {
          var _d = false;

          if (dx > 0) {
            groupEl.style.width = currentWidth + "px";
            dx = 0;
            _d = true;
          }

          if (dy > 0) {
            groupEl.style.height = currentHeight + "px";
            dy = 0;
            _d = true;
          }

          if (_d) {
            // if either axis was adjusted, go back to the DOM to get the actual size
            actualGroupSize = this.jsplumb.getSize(uiGroup.el);
          }
        } // if the group is nested, advise the layout for the group's parent of the change in size,
        // and maybe also auto size the parent, if necessary.


        if (group.group) {
          // we need to set the size on the parent group's layout
          this._layoutMap.get(group.group.id).setSize(group.id, actualGroupSize); // and then maybe run its auto size routine.


          var parentGroupDef = this.getGroupDefinition(group.group);

          if (parentGroupDef) {
            this._autoSizeAGroup(group.group, parentGroupDef, movedElements, false);
          }
        } else {
          // if the group is not nested, update the main layout with the new size of the group
          this._layout.setSize(group.id, actualGroupSize); // and if necessary, run the magnetizer
          //if (this.magnetizeProfile.afterGroupChange !== false) {
          // if either dimension has shrunk, run a gather


          if (this.magnetizeProfile.afterGroupShrink && (dx < 0 || dy < 0)) {
            this.gather(group);
          } else if (this.magnetizeProfile.afterGroupGrow && (dx > 0 || dy > 0)) {
            // otherwise, run the magnetizer
            // TODO ideally we would run this (see also EVENT_GROUP_EXPAND code):
            //this.magnetize(group)
            // but with the Spring layout nodes are locked and it fails. this other way, though, doesnt fail.
            var currentPosition = this._layout.getPosition(group.id);

            if (currentPosition != null) {
              extend(movedElements, this._setMagnetizedPosition(group.id, currentPosition.x, currentPosition.y, !this.magnetizeProfile.repositionDraggedElement, this._layout));
            }
          } //}

        }

        if (dx !== 0 || dy !== 0) {
          this.fire(EVENT_GROUP_RESIZE, {
            group: group,
            el: groupEl,
            w: w,
            h: h
          });
        }

        return movedElements;
      }
    }, {
      key: "_connect",
      value: function _connect(params, edge, edgeDef) {
        var _this36 = this;

        if (this.dataSource.debugEnabled) {
          console.log("Renderer", "adding connection with params", params);
        }

        var injectDefaults = function injectDefaults(opts, index) {
          opts.endpoint = opts.endpoint || _this36.jsplumb.defaults.endpoints[index] || _this36.jsplumb.defaults.endpoint;
          opts.paintStyle = opts.paintStyle || _this36.jsplumb.defaults.endpointStyles[index] || _this36.jsplumb.defaults.endpointStyle;
          opts.hoverPaintStyle = opts.hoverPaintStyle || _this36.jsplumb.defaults.endpointHoverStyles[index] || _this36.jsplumb.defaults.endpointHoverStyle;
          opts.anchor = opts.anchor != null ? opts.anchor : _this36.jsplumb.defaults.anchors != null ? _this36.jsplumb.defaults.anchors[index] : _this36.jsplumb.defaults.anchor;
          opts.deleteOnEmpty = opts.deleteOnEmpty === false ? opts.deleteOnEmpty : true;
        };

        var injectEdgeValues = function injectEdgeValues(opts, index) {
          if (edgeDef != null) {
            opts.endpoint = opts.endpoint || edgeDef.endpoint || (edgeDef.endpoints ? edgeDef.endpoints[index] : null);
            opts.anchor = opts.anchor || edgeDef.anchor || (edgeDef.anchors ? edgeDef.anchors[index] : null);
            opts.paintStyle = opts.paintStyle || edgeDef.endpointStyle || (edgeDef.endpointStyles ? edgeDef.endpointStyles[index] : null);
            opts.hoverPaintStyle = opts.hoverPaintStyle || edgeDef.endpointHoverStyle || (edgeDef.endpointHoverStyles ? edgeDef.endpointHoverStyles[index] : null);
          }
        };

        var p = extend({}, params);

        if (params.type != null) {
          edgeDef = edgeDef || this.view.getEdgeDefinition(params.type);

          if (edgeDef != null) {
            // it's possible to parameterise port/edge/node definitions. this is switched on by default.
            if (this.enhancedView) {
              extend(p, populate(edgeDef, edge.data, null, true));
            } else {
              extend(p, edgeDef);
            }
          }
        }

        if (isDOMElement(params.source)) {
          var sourceEndpointOptions = {
            element: params.source
          };
          var portType = params.source.getAttribute(ATTRIBUTE_JTK_PORT_TYPE) || params.source.getAttribute(ATTRIBUTE_JTK_SOURCE_PORT_TYPE);

          if (portType != null) {
            var portDef = this.view.getPortDefinition(portType);

            if (portDef != null) {
              if (this.enhancedView) {
                extend(sourceEndpointOptions, populate(portDef, edge.source.data, null, true));
              } else {
                extend(sourceEndpointOptions, portDef);
              }
            }
          }

          injectEdgeValues(sourceEndpointOptions, 0);
          injectDefaults(sourceEndpointOptions, 0);
          p.sourceEndpoint = this.jsplumb._internal_newEndpoint(sourceEndpointOptions);
        }

        if (isDOMElement(params.target)) {
          var targetEndpointOptions = {
            element: params.target
          };
          var tPortType = params.target.getAttribute(ATTRIBUTE_JTK_PORT_TYPE) || params.target.getAttribute(ATTRIBUTE_JTK_TARGET_PORT_TYPE);

          if (tPortType != null) {
            var _portDef = this.view.getPortDefinition(tPortType);

            if (_portDef != null) {
              if (this.enhancedView) {
                extend(targetEndpointOptions, populate(_portDef, edge.target.data, null, true));
              } else {
                extend(targetEndpointOptions, _portDef);
              }
            }
          }

          injectEdgeValues(targetEndpointOptions, 1);
          injectDefaults(targetEndpointOptions, 1);
          p.targetEndpoint = this.jsplumb._internal_newEndpoint(targetEndpointOptions);
        }

        return this.jsplumb.connect(p);
      }
    }, {
      key: "_enqueueEdge",
      value: function _enqueueEdge(edge, flushNow) {
        this.unrenderedEdges.push(edge);

        if (flushNow) {
          this._flushUnrenderedEdges();
        }
      }
    }, {
      key: "_maybeRenderEdge",
      value: function _maybeRenderEdge(edge) {
        var targetEl = this.getRenderedEndpoint(edge.target.getFullId()) || this.getRenderedElement(edge.target),
            sourceEl = this.getRenderedEndpoint(edge.source.getFullId()) || this.getRenderedElement(edge.source);

        if (targetEl == null || sourceEl == null) {
          return null;
        } else {
          return this._doRenderEdge(edge);
        }
      }
    }, {
      key: "_doRenderEdge",
      value: function _doRenderEdge(edge) {
        var edgeDefinition = this.view.getEdgeDefinition(this.dataSource.getEdgeType(edge.data || {}));

        var connectionParams = this._prepareConnectionParams(edge);

        var conn = this._connect(connectionParams, edge, edgeDefinition);

        if (conn != null) {
          // TODO this is duplicated in the load existing data code.
          // set geometry, if provided and supported. ensure the edge is repainted by providing a new timestamp.
          var connector = conn.connector;

          if (connectionParams.geometry && connector.importGeometry) {
            connector.importGeometry(connectionParams.geometry, conn);
            this.jsplumb.revalidate(conn.source);
            this.jsplumb.revalidate(conn.target);
          }

          conn.edge = edge;
          this.connMap[edge.getId()] = conn; // TODO end of this is duplicated in the load existing data code.

          this.fire(EVENT_EDGE_ADDED, {
            source: edge.source,
            target: edge.target,
            connection: conn,
            edge: edge,
            geometry: edge.geometry
          }); // in version 1.5.3 we're tentatively removing this, putting it on a flag that defaults to false.

          if (this.refreshLayoutOnEdgeConnect) {
            this.refresh(true);
          }

          var sourceNode = isPort(edge.source) ? edge.source.getParent() : edge.source,
              sourceNodeEl = this.jsplumb.getManagedElement(sourceNode.id),
              targetNode = isPort(edge.target) ? edge.target.getParent() : edge.target,
              targetNodeEl = this.jsplumb.getManagedElement(targetNode.id);

          if (targetNodeEl._jtkVisible === false || sourceNodeEl._jtkVisible === false) {
            this._toggleEdge(edge, false);
          }
        } else {
          console.log("jsPlumb: WARN : An edge could not be rendered " + edge + " and is being removed from the dataset.");
          this.dataSource.removeEdge(edge);
        }

        return conn;
      }
    }, {
      key: "_toggleEdge",
      value: function _toggleEdge(edge, state, doNotCascade) {
        var c = this.getConnectionForEdge(edge);

        if (c) {
          var doContinue = !state || bothEndpointsVisible(c);

          if (doContinue) {
            c.setVisible(state);

            if (!doNotCascade) {
              maybeToggleEndpoint(c, c.endpoints[0], state);
              maybeToggleEndpoint(c, c.endpoints[1], state);
            }
          }
        }
      }
      /**
       * Callback for renderers to tell us when a vertex has been rendered. For internal use (unless you're writing your own renderer)
       * @param v The vertex that was rendered
       * @param el The DOM element representing the Vertex.
       * @param def The vertex definition derived for the type of the Vertex.
       * @internal
       */

    }, {
      key: "vertexRendered",
      value: function vertexRendered(v, el, def, eventInfo) {
        if (!el) {
          throw new Error("Cannot render vertex");
        }

        var jel = el;
        el.setAttribute("data-jtk-vertex", v.getFullId());
        var isANode = isNode(v),
            isAGroup = isGroup(v);
        var jtkClass = isANode ? CLASS_NODE : isAGroup ? CLASS_GROUP : isPort(v) ? CLASS_PORT : "";
        this.jsplumb.addClass(el, jtkClass); // write the data to the element.

        jel.jtk = jel.jtk || {};
        jel.jtk[v.objectType.toLowerCase()] = v;
        jel.jtk.vertex = v;
        this.jsplumb.manage(el, v.id); // pass node ID in as the internal id

        if (isNode(v) || isGroup(v)) {
          this._extractEndpointFromElementAndDefinition(el, v);

          this.vertexList.push(v);
        }

        if (isANode) {
          el.jtk = {
            node: v
          };
        }

        if (isAGroup) {
          el.jtk = {
            group: v
          };
        }

        if (isAGroup || isNode(v) && v.group == null) {
          this._append(el, v.id, eventInfo ? eventInfo.position : null);
        } else if (isNode(v)) {
          this._appendNodeToGroup(el, v, v.group);
        } // this is necessary because when we call `manage` above, the node is still a child of the fragment it was generated in,
        // and so its styles, which determine width/height, are not applied.  This isn't great, this setup, and ideally wouldnt
        // happen. But i think the appendNodeToGroup call is the problem: it will call `manage` on the element if its not already
        // managed, and it doesnt get told the `jtk-id` to us. we could write `jtk-id` ourselves but that seems hokey.
        // maybe a better idea is for the viewport to mark the element 'dirty', if it can, and then handle the size stuff inside the
        // viewport.


        this.viewport.refreshElement(v.id);

        if (v.data.rotation != null) {
          this.jsplumb.rotate(el, v.data.rotation);
        }

        if (isNode(v)) {
          this._doAssignDragGroup(el, v);

          var np = {
            el: el,
            id: v.id,
            vertex: v
          };

          if (v.group == null) {
            np.pos = this._layout.vertexAdded(np, eventInfo);
          }

          this.fireNodeAdded(np);
        } else if (isGroup(v)) {
          this._doAssignDragGroup(el, v);

          var _np = {
            el: el,
            vertex: v,
            id: v.id
          }; // add the group to the jsplumb instance

          var opts = {
            el: el,
            id: v.id
          };
          this.jsplumb.addGroup(extend(opts, def));

          if (v.group != null) {
            // this group is nested.
            this.jsplumb.addToGroup(v.group.id, el);
          } // apply layout


          var layoutSpec = def.layout || {
            type: AbsoluteLayout.type
          };

          this._layoutMap.set(v.id, this._createGroupLayout(layoutSpec, v));

          _np.pos = this._layout.vertexAdded({
            el: el,
            id: v.id,
            vertex: v
          }, eventInfo);
          this.fire(EVENT_GROUP_ADDED$1, _np);
        }

        this._flushUnrenderedEdges();

        this.refresh(true);
      }
    }]);

    return Surface;
  }(OptimisticEventGenerator);

  _defineProperty$b(Surface, "type", "Surface");

  var rendererMap = {};
  var SurfacePlugins = {
    get: function get(name) {
      var sp = rendererMap[name];

      if (!sp) {
        throw {
          message: "jsPlumbToolkit: unknown surface plugin '" + name + "'"
        };
      } else {
        return new sp();
      }
    },
    register: function register(name, sp) {
      rendererMap[name] = sp;
    }
  };

  function _classCallCheck$b(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$b(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$b(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$b(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$b(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty$a(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _inherits$6(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf$6(subClass, superClass);
  }

  function _getPrototypeOf$6(o) {
    _getPrototypeOf$6 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$6(o);
  }

  function _setPrototypeOf$6(o, p) {
    _setPrototypeOf$6 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$6(o, p);
  }

  function _isNativeReflectConstruct$6() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _assertThisInitialized$6(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn$6(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }

    return _assertThisInitialized$6(self);
  }

  function _createSuper$6(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$6();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf$6(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$6(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn$6(this, result);
    };
  }

  function _slicedToArray$1(arr, i) {
    return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i) || _unsupportedIterableToArray$1(arr, i) || _nonIterableRest$1();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray$1(arr);
  }

  function _arrayWithHoles$1(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }

  function _iterableToArrayLimit$1(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;

    var _s, _e;

    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray$1(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray$1(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);
  }

  function _arrayLikeToArray$1(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _nonIterableRest$1() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function extendWithCallback(o1, o2, cb) {
    for (var o in o2) {
      o1[o] = o2[o];
      if (cb) cb(o, o1[o]);
    }

    return o1;
  }
  function filterEmpty(l) {
    return l.filter(function (e) {
      return e != null && fastTrim(e).length > 0;
    });
  }
  function eachNotEmpty(strings, fn) {
    for (var i = 0; i < strings.length; i++) {
      var t = strings[i];

      if (t == null || t.length === 0) {
        continue;
      } else {
        fn(i, t);
      }
    }
  }

  function parseAttributes(d, attributesRe) {
    if (d == null) {
      return d;
    } else {
      var parts = d.replace("/>", ">").split(/^<|>$/)[1].split(attributesRe);
      return filterEmpty(parts);
    }
  }
  function peek(a) {
    return a.length > 0 ? a[a.length - 1] : null;
  }
  function isLoopPresent(stack) {
    if (stack == null || stack.length === 0) {
      return false;
    } else {
      for (var i = stack.length - 1; i > -1; i--) {
        if (stack[i].type === "each") return true;
      }
    }

    return false;
  }
  function _addBinding(bindingId, match, entry, predicate, instance) {
    var u = uuid(),
        b = {
      w: match,
      e: [],
      u: u
    };
    instance.bindings[u] = b;

    var fnBody = function fnBody() {
      return predicate != null ? "try {  if(" + predicate + ") { out = out.replace(this.e[k][0], eval(this.e[k][1])); } else out=''; } catch(__) { out='';}" : "try { out = out.replace(this.e[k][0], eval(this.e[k][1])); } catch(__) { out=out.replace(this.e[k][0], '');}";
    };

    var prefix = function prefix() {
      return predicate != null ? "var out='';try { with($data) { if (" + predicate + ") out = this.w; else return null; }}catch(_){return null;}" : "var out = this.w;";
    };

    b.reapply = new Function("$data", prefix() + "for (var k = 0; k < this.e.length; k++) { with($data) { " + fnBody() + " }} return out;");
    entry.bindings[bindingId] = b;
    match.replace(/\$\{([^\}]*)\}/g, function (term, content, _loc, _whole) {
      b.e.push([term, content]);
      return "";
    });
    return u;
  }
  function _bindOneAtt(id, value, output, predicate, instance) {
    output.atts[id] = value;

    _addBinding(id, value, output, predicate, instance);
  }
  function parseAtts(el, instance) {
    var p = parseAttributes(el, instance.attributesRe),
        o = {
      el: fastTrim(p[0]),
      atts: {},
      bindings: {}
    };

    var _maybeBindAttribute = function _maybeBindAttribute(_p, predicate) {
      // if not an inline if, parse a normal attribute.
      var m = _p.match(/([^=]+)=['"](.*)['"]/);

      if (m == null && predicate == null) {
        o.atts[_p] = "";
      } else if (m == null) {
        _bindOneAtt(_p, "", o, predicate, instance);
      } else {
        _bindOneAtt(m[1], m[2], o, predicate, instance);
      }

      return m;
    };

    for (var i = 1; i < p.length; i++) {
      var _p = fastTrim(p[i]);

      if (_p != null && _p.length > 0) {
        // test if this is an inline IF statement. if so, its content should be run back through the attribute
        // parser to get its constituent parts.
        var isInlineIf = _p.match(instance.inlineIfRe);

        if (isInlineIf) {
          var parts = isInlineIf[2].split(instance.attributesRe); // add each part one by one using the code below but with the predicate attached.

          for (var j = 0; j < parts.length; j++) {
            var __p = fastTrim(parts[j]);

            if (__p != null && __p.length > 0) {
              _maybeBindAttribute(__p, isInlineIf[1]); // bind the attribute with the given predicate.

            }
          }
        } else {
          _maybeBindAttribute(_p);
        }
      }
    }

    return o;
  }
  var AbstractEntry = function AbstractEntry(instance) {
    _classCallCheck$b(this, AbstractEntry);

    this.instance = instance;

    _defineProperty$a(this, "type", void 0);

    _defineProperty$a(this, "tag", void 0);

    _defineProperty$a(this, "remove", void 0);

    _defineProperty$a(this, "uuid", void 0);

    _defineProperty$a(this, "children", []);

    _defineProperty$a(this, "elements", []);

    _defineProperty$a(this, "bindings", void 0);

    _defineProperty$a(this, "context", void 0);

    _defineProperty$a(this, "functionBody", void 0);

    _defineProperty$a(this, "precompile", void 0);

    _defineProperty$a(this, "postcompile", void 0);

    this.uuid = uuid();
    instance.entries[this.uuid] = this;
  };

  /**
   * @internal
   */
  var TextEntry = /*#__PURE__*/function (_AbstractEntry) {
    _inherits$6(TextEntry, _AbstractEntry);

    var _super = _createSuper$6(TextEntry);

    function TextEntry(options, instance) {
      var _this;

      _classCallCheck$b(this, TextEntry);

      _this = _super.call(this, instance);

      _defineProperty$a(_assertThisInitialized$6(_this), "type", "text");

      _defineProperty$a(_assertThisInitialized$6(_this), "value", void 0);

      _this.value = options.value;
      _this.bindings = {};
      return _this;
    }

    _createClass$b(TextEntry, [{
      key: "_getBoundValue",
      value: function _getBoundValue() {
        return "_rotors.bind(__knockleData[0], '" + this.bindings["__element"].u + "', typeof $key !== 'undefined' ? $key : null, typeof $value !== 'undefined' ? $value : null)";
      }
    }, {
      key: "compile",
      value: function compile() {
        return this.instance.getExecutionContent(this._getBoundValue(), this.uuid, true) + ";_rotors.pet(_eid, '" + this.uuid + "');";
      }
    }, {
      key: "updateFrom",
      value: function updateFrom(entry, newEntry, parent) {
        entry.el.nodeValue = newEntry.el.nodeValue;
        return {
          added: [],
          removed: [],
          elements: []
        };
      }
    }]);

    return TextEntry;
  }(AbstractEntry);

  function emptyUpdateResult() {
    return {
      added: [],
      removed: [],
      elements: []
    };
  }
  function _findChild(valuesToFind, newEntry) {
    for (var i = 0; i < newEntry.children.length; i++) {
      var allMatch = true;

      for (var k in valuesToFind) {
        if (valuesToFind[k] !== newEntry.children[i][k]) {
          allMatch = false;
          break;
        }
      }

      if (allMatch) return newEntry.children[i];
    }
  }

  function _updateParent(instance, entry, newEntry, fieldIds, parent) {
    var visitedChildren = {},
        missingChildren = [],
        newChild,
        child,
        newChildren = [],
        r = {
      added: [],
      removed: [],
      elements: []
    },
        _r;

    var cacheKey = function cacheKey(child) {
      var k = "";

      for (var i = 0; i < fieldIds.length; i++) {
        k += child[fieldIds[i]];
      }

      return k;
    };

    if (newEntry.children.length > 0) {
      for (var i = 0; i < entry.children.length; i++) {
        child = entry.children[i];
        var match = {};

        for (var k = 0; k < fieldIds.length; k++) {
          match[fieldIds[k]] = child[fieldIds[k]];
        }

        newChild = _findChild(match, newEntry);

        if (newChild == null) {
          missingChildren.push(child);
        } else {
          visitedChildren[cacheKey(child)] = true;
          _r = instance.updateFrom(child, newChild, null);
          Array.prototype.push.apply(r.added, _r.added);
          Array.prototype.push.apply(r.removed, _r.removed);
        }
      }
    } else {
      Array.prototype.push.apply(missingChildren, entry.children);
    } // remove the missing children


    var _missingMap = {};

    for (var _i = 0; _i < missingChildren.length; _i++) {
      missingChildren[_i].el.parentNode && missingChildren[_i].el.parentNode.removeChild(missingChildren[_i].el);
      _missingMap[missingChildren[_i].index] = true;
    } // update the list of children for the entry, to remove the ones that were missing from the latest run.


    var filtered = entry.children.filter(function (c) {
      return _missingMap[c.index] !== true;
    });
    entry.children = filtered; // get, if possible, the last child element rendered.

    var lastRendered = entry.children.length > 0 ? entry.children[entry.children.length - 1].el : null;

    for (var _i2 = 0; _i2 < newEntry.children.length; _i2++) {
      child = newEntry.children[_i2];

      if (!visitedChildren[cacheKey(child)]) {
        // a new child. needs to be inserted into the DOM somewhere, either as a sibling of the last element rendered,
        // or if none rendered, then a sibling of the parents last child, or if none of those, a child of the parent
        entry.children.push(child);
        newChildren.push(child);
      }
    }

    if (newChildren.length > 0) {
      for (var _i3 = 0; _i3 < newChildren.length; _i3++) {
        if (lastRendered != null) {
          lastRendered.parentNode.insertBefore(newChildren[_i3].el, lastRendered.nextSibling);
        } else if (parent != null) {
          parent.el.appendChild(newChildren[_i3].el);
        } else {
          console.log("Knockle: couldnt insert child, nothing to insert after");
        }

        lastRendered = newChildren[_i3].el;
      }
    }

    Array.prototype.push.apply(r.added, newChildren);
    Array.prototype.push.apply(r.removed, missingChildren);
    return r;
  }

  var CommentEntry = /*#__PURE__*/function (_AbstractEntry) {
    _inherits$6(CommentEntry, _AbstractEntry);

    var _super = _createSuper$6(CommentEntry);

    function CommentEntry(comment, instance) {
      var _this;

      _classCallCheck$b(this, CommentEntry);

      _this = _super.call(this, instance);

      _defineProperty$a(_assertThisInitialized$6(_this), "type", "comment");

      _defineProperty$a(_assertThisInitialized$6(_this), "comment", void 0);

      _this.comment = comment;
      return _this;
    }

    _createClass$b(CommentEntry, [{
      key: "compile",
      value: function compile() {
        return "";
      }
    }, {
      key: "updateFrom",
      value: function updateFrom(entry, newEntry, parent) {
        return emptyUpdateResult();
      }
    }]);

    return CommentEntry;
  }(AbstractEntry);

  var ElementEntry = /*#__PURE__*/function (_AbstractEntry) {
    _inherits$6(ElementEntry, _AbstractEntry);

    var _super = _createSuper$6(ElementEntry);

    function ElementEntry(ta, instance, templateResolver, stack, parseIdStack) {
      var _this;

      _classCallCheck$b(this, ElementEntry);

      _this = _super.call(this, instance); //const ta =

      _this.templateResolver = templateResolver;
      _this.stack = stack;
      _this.parseIdStack = parseIdStack;

      _defineProperty$a(_assertThisInitialized$6(_this), "type", "element");

      _defineProperty$a(_assertThisInitialized$6(_this), "namespace", void 0);

      _defineProperty$a(_assertThisInitialized$6(_this), "atts", void 0);

      _defineProperty$a(_assertThisInitialized$6(_this), "custom", void 0);

      var p = ta.el.split(":");
      _this.tag = ta.el;

      if (p.length === 2) {
        _this.namespace = p[0];
      }

      _this.atts = ta.atts;
      _this.bindings = ta.bindings;
      _this.remove = false;
      return _this;
    }

    _createClass$b(ElementEntry, [{
      key: "compile",
      value: function compile(isCustomScope) {
        var customTag = this.instance.getCustomTag(this.tag);

        if (customTag) {
          var fb = customTag.getFunctionBody(this.instance, this); //var renderCb = _rotors.customTags[this.tag] ? "_rotors.customTags['" + this.tag + "'].rendered(_le, _rotors, __knockleData[0]);" : "_rotors.globalTags['" + this.tag + "'].rendered(_le, _rotors, data[0]);"

          var renderCb = "_rotors.customTagRendered('" + this.tag + "', _le, __knockleData[0]);";

          for (var c = 0; c < this.children.length; c++) {
            if (this.children[c].precompile) {
              fb += this.children[c].precompile(this.instance);
            }

            fb += this.children[c].compile();

            if (this.children[c].postcompile) {
              fb += this.children[c].postcompile(this.instance);
            }
          }

          fb += "_le=_els.pop();" + renderCb + "_rotors.pet(_eid,'" + this.uuid + "');";
          return fb;
        }

        var fp = "/* element entry " + this.uuid + " */;"; // custom elements may set `remove` to true, meaning they behave as an element but their element should not appear in the output.

        if (this.remove !== true) {
          fp += this.instance.getExecutionContent(this.tag, this.uuid, false, this.namespace);
          var bracketAtt, bracketExpression;

          for (var a in this.atts) {
            if (this.atts.hasOwnProperty(a)) {
              var attExpr = void 0;

              if (this.bindings[a] != null) {
                attExpr = "_rotors.bind(__knockleData[0], '" + this.bindings[a].u + "');";
                bracketAtt = a.match(/\(([^)]+)\)/);

                if (bracketAtt) {
                  var commandName = bracketAtt[1];
                  var command = this.atts[a];
                  bracketExpression = ";if(__a!=null){_rotors.addCommand(_eid,e,\"" + commandName + "\",\"" + command + "\");}";
                }
              } else {
                // a static attribute value.
                attExpr = "'" + this.atts[a] + "'";
              }

              var suffix = bracketAtt ? bracketExpression : ";if(__a!=null) {_rotors.setAttribute(e,'" + a + "',__a || '');}";
              fp += "__a=" + attExpr + suffix;
            }
          }
        }

        for (var i = 0; i < this.children.length; i++) {
          if (this.children[i].precompile) {
            fp += this.children[i].precompile();
          }

          var fn = this.children[i].compile();
          fp += fn;
          this.children[i].functionBody = fn;

          if (this.children[i].postcompile) {
            fp += this.children[i].postcompile();
          }
        }

        if (this.remove !== true && !isCustomScope) {
          fp += "_le=_els.pop();";
          fp += "_rotors.pet(_eid, '" + this.uuid + "');";
        }

        return fp;
      }
    }, {
      key: "_applyStyles",
      value: function _applyStyles(el, styles) {
        styles.split(";").forEach(function (s) {
          var ss = s.indexOf(":"),
              prop = s.substring(0, ss);
          el.style[prop] = s.substring(ss + 1);
        });
      }
    }, {
      key: "updateFrom",
      value: function updateFrom(entry, newEntry, parent) {
        var a,
            v,
            r = emptyUpdateResult(),
            _r; // update the attributes/class/style of the element.


        for (a in this.atts) {
          if (this.atts.hasOwnProperty(a) && a !== "class") {
            v = newEntry.el.getAttribute(a);

            if (v) {
              if (a === "style" && entry.el.style != null) {
                this._applyStyles(entry.el, v);
              } else {
                entry.el.setAttribute(a, v);
              }
            } else {
              entry.el.removeAttribute(a);
            }
          }
        }

        if (this.originalCustomTag) {
          var customTag = this.instance.getCustomTag(this.originalCustomTag);

          if (customTag) {
            r.elements.push([entry.el, customTag]);
          }
        }

        for (var i = 0; i < entry.children.length; i++) {
          _r = this.instance.updateFrom(entry.children[i], newEntry.children[i], entry);
          Array.prototype.push.apply(r.removed, _r.removed);
          Array.prototype.push.apply(r.added, _r.added);
          Array.prototype.push.apply(r.elements, _r.elements);
        }

        if (entry.el._RotorsUpdate) {
          var updaters = this.instance.updaters[entry.el._RotorsUpdate];

          for (var u = 0; u < updaters.length; u++) {
            updaters[u](entry.el);
          }
        }

        return r;
      }
    }]);

    return ElementEntry;
  }(AbstractEntry);

  var elementMap = {};
  var Elements = {
    construct: function construct(tag, ta, instance, templateResolver, stack, parseIdStack) {
      var c = elementMap[tag];

      if (!c) {
        throw {
          message: "Knockle: unknown element '" + tag + "'"
        };
      } else {
        return new c(ta, instance, templateResolver, stack, parseIdStack);
      }
    },
    register: function register(name, conn) {
      elementMap[name] = conn;
    },
    exists: function exists(tag) {
      return elementMap[tag] != null;
    }
  };

  var CustomTag = function CustomTag(instance, tagName, options) {
    var _this = this;

    _classCallCheck$b(this, CustomTag);

    this.instance = instance;
    this.tagName = tagName;
    this.options = options;

    _defineProperty$a(this, "template", void 0);

    _defineProperty$a(this, "getFunctionBody", void 0);

    _defineProperty$a(this, "getFunctionEnd", void 0);

    _defineProperty$a(this, "rendered", void 0);

    _defineProperty$a(this, "updated", void 0);

    var combineAttributes = function combineAttributes(ast, fromParseTree) {
      var out = [];

      var _loop = function _loop(i) {
        var newAstEntry = extend({}, ast[i]);
        newAstEntry.compile = ast[i].compile;
        out.push(newAstEntry);
        extendWithCallback(newAstEntry.atts, fromParseTree.atts, function (k, v) {
          _bindOneAtt(k, v, newAstEntry, null, _this.instance);
        });
      };

      for (var i = 0; i < ast.length; i++) {
        _loop(i);
      }

      return out;
    };

    this.template = options.template;

    this.getFunctionBody = function (knockle, parseTree) {
      var ast = knockle.parse(_this.template, null, {
        originalCustomTag: parseTree.tag,
        context: parseTree.context,
        customParent: parseTree
      });
      var atts = combineAttributes(ast, parseTree);
      return knockle.compile(atts, false, true, true);
    };

    this.getFunctionEnd = function () {
      return ";_els.pop();";
    };

    this.rendered = options.rendered || function (el, data, instance) {};

    this.updated = options.updated || function (el, data, instance) {};
  };

  var globalTags = {};
  var registerGlobalTag = function registerGlobalTag(tagName, tag) {
    if (globalTags[tagName] == null) {
      globalTags[tagName] = tag;
    } else {
      throw new Error("Tag '" + tagName + "' already registered");
    }
  };
  var getCustomTag = function getCustomTag(tagName) {
    return globalTags[tagName];
  };
  var Knockle = /*#__PURE__*/function () {
    function Knockle(options, registerGlobalTag, getGlobalTag) {
      _classCallCheck$b(this, Knockle);

      this.registerGlobalTag = registerGlobalTag;
      this.getGlobalTag = getGlobalTag;

      _defineProperty$a(this, "templateResolver", void 0);

      _defineProperty$a(this, "defaultTemplate", void 0);

      _defineProperty$a(this, "entries", void 0);

      _defineProperty$a(this, "bindings", void 0);

      _defineProperty$a(this, "customTags", {});

      _defineProperty$a(this, "cache", new Map());

      _defineProperty$a(this, "templateCache", new Map());

      _defineProperty$a(this, "openRe", new RegExp("<([^\/>]*?)>$|<([^\/].*[^\/])>$"));

      _defineProperty$a(this, "closeRe", new RegExp("^<\/([^>]+)>"));

      _defineProperty$a(this, "openCloseRe", new RegExp("<(.*)(\/>$)"));

      _defineProperty$a(this, "tokenizerRe", /(<[^\^>]+\/>)|(<!--[\s\S]*?-->)|(<[\/a-zA-Z0-9\-:]+(?:\s*[\(a-zA-Z\-\)]+=\"[^\"]*\"|\s*[a-zA-Z\-]+='[^']+'|\s*[\(a-zA-Z\-\)]|\s*\{\{.*\}\})*>)/);

      _defineProperty$a(this, "commentRe", /<!--[\s\S]*?-->/);

      _defineProperty$a(this, "attributesRe", /([\(a-zA-Z0-9\-_:\)]+="[^"]*")|\s+([\(a-zA-Z0-9\-_:\)]+(?=\s.|$))|(\{\{if [^(?:\}\})]+\}\}.*\{\{\/if\}\})/);

      _defineProperty$a(this, "inlineIfRe", /\{\{if ([^\}]+)\}\}(.*)\{\{\/if\}\}/);

      _defineProperty$a(this, "singleExpressionRe", /^[\s]*\$\{([^\}]*)\}[\s]*$/);

      _defineProperty$a(this, "_fnPreamble", "__knockleData=[__knockleData||{}];var frag=_rotors.cf(),_els=[],e,_le,__a,$value,$key,_eid = _rotors.nec();_els.push(frag);");

      _defineProperty$a(this, "_fnSuffix", ";_rotors.pushCommands(_eid,frag);return frag;");

      _defineProperty$a(this, "isBrowser", true);

      _defineProperty$a(this, "executions", void 0);

      _defineProperty$a(this, "updaters", {});

      _defineProperty$a(this, "_templates", void 0);

      _defineProperty$a(this, "namespaceHandlers", {});

      _defineProperty$a(this, "namespaces", {});

      options = options || {};

      this.getGlobalTag = getGlobalTag || function (tag) {
        return globalTags[tag];
      };

      this._templates = options.templates || {};
      this.entries = {};
      this.bindings = {};
      this.executions = {};
      this.defaultTemplate = options.defaultTemplate;
      this.templateResolver = options.templateResolver || this._getDefaultTemplateResolver();
    }

    _createClass$b(Knockle, [{
      key: "resolveTemplate",
      value: function resolveTemplate(id) {
        if (this._templates[id] != null) {
          return this._templates[id];
        } else {
          return this.templateResolver(id);
        }
      }
    }, {
      key: "bind",
      value: function bind(fromObj, id) {
        var b = this.bindings[id];

        if (b == null) {
          return "";
        } else {
          return b.reapply(fromObj);
        }
      }
      /**
       * Add a command - this is called during execution of a template. See pushCommands below.
       * @param executionId
       * @param el
       * @param command
       * @param action
       */

    }, {
      key: "addCommand",
      value: function addCommand(executionId, el, command, action) {
        this.executions[executionId].commands = this.executions[executionId].commands || {};
        this.executions[executionId].commands[command] = this.executions[executionId].commands[command] || [];
        this.executions[executionId].commands[command].push({
          element: el,
          command: command,
          action: action
        });
      }
      /**
       * At the end of an execution this is called - any commands found during the execution are transferred to the fragment
       * that was created.
       * @param executionId
       * @param el
       */

    }, {
      key: "pushCommands",
      value: function pushCommands(executionId, el) {
        el.commands = this.executions[executionId].commands;
      }
    }, {
      key: "setAttribute",
      value: function setAttribute(el, a, v) {
        var p = a.split(":");

        if (p.length === 1 || this.namespaces[p[0]] == null) {
          el.setAttribute(p[0], v);
        } else {
          el.setAttributeNS(this.namespaces[p[0]], p[1], v);
        }
      }
    }, {
      key: "clearCache",
      value: function clearCache() {
        this.cache.clear();
        this.templateCache.clear();
      }
    }, {
      key: "nec",
      value: function nec() {
        var _eid = uuid();

        this.executions[_eid] = {
          "current": [{
            children: []
          }]
        };
        return _eid;
      } //traceExecution

    }, {
      key: "te",
      value: function te(el, eid, entryId, loopIndex) {
        var __ec = {
          el: el,
          children: [],
          id: entryId,
          index: loopIndex
        };
        this.executions[eid].current[0].children.push(__ec);
        var key = entryId + (loopIndex != null ? "-" + loopIndex : "");
        this.executions[eid][key] = __ec;
        this.executions[eid].current.unshift(__ec);
      } //popExecutionTrace

    }, {
      key: "pet",
      value: function pet(eid) {
        this.executions[eid].current = this.executions[eid].current.splice(1);
      }
    }, {
      key: "parseAttributes",
      value: function parseAttributes$1(el) {
        return parseAttributes(el, this.attributesRe);
      }
    }, {
      key: "getExecutionContent",
      value: function getExecutionContent(content, uuid, isTextNode, namespace) {
        var p = namespace != null ? this.namespaceHandlers[namespace](content) : isTextNode ? "e=_rotors.ctn(" + content + ");" : "e=_rotors.ce('" + content + "');";
        return p + "_rotors.peek(_els).appendChild(e);" + (isTextNode ? "" : "_els.push(e);") + // if a text node, dont push onto the stack, it can have no children
        "e._rotors=_rotors.entries['" + uuid + "'];" + // _rotors.entries[uuid] is the Rotors Element (from the AST) that is creating the DOM element
        // here. it may be executing inside a loop, in which case this is NOT a reference to the r-each, it is a reference to the child content in the
        // loop. So there may be multiple dom elements that reference this rotors Element. We distinguish between these via the inclusion of the
        // `_rotorsLoopId`, if it is set. That is the ID of the r-each.
        //"if (typeof _rotorsLoopId != 'undefined'){_rotors.entries[_rotorsLoopId].elements.push(e);}else{_rotors.entries['" + uuid + "'].elements.push(e);}"
        "e._rotorsEid=_eid;" + "if(typeof _rotorsLoopId !== 'undefined') {e._rotorsLoopId=_rotorsLoopId;e._rotorsLoopContext=_rotorsLoopContext;e._rotorsKey=$key;}" + "_rotors.te(e, _eid, '" + uuid + "', typeof $key != 'undefined' ? $key  : null);";
      }
    }, {
      key: "_wrapCache",
      value: function _wrapCache(resolver, forceReload) {
        var _this = this;

        return function (id) {
          var t = forceReload ? null : _this.cache.get(id);

          if (t == null) {
            t = resolver(id);
          }

          if (t == null) {
            t = _this.defaultTemplate;
          }

          if (t != null) {
            _this.cache.set(id, t);
          }

          return t;
        };
      }
    }, {
      key: "constructElement",
      value: function constructElement(tag, ta, templateResolver, stack, parseIdStack) {
        return Elements.construct(tag, ta, this, templateResolver, stack, parseIdStack);
      }
    }, {
      key: "isCustomElement",
      value: function isCustomElement(tag) {
        return Elements.exists(tag);
      }
    }, {
      key: "parse",
      value: function parse(str, templateResolver, extraProperties, parseIdStack) {
        var _this2 = this;

        parseIdStack = parseIdStack || []; //templateResolver = this._wrapCache(templateResolver || this.templateResolver, null)

        templateResolver = this._wrapCache(templateResolver || function (id) {
          return _this2.resolveTemplate(id);
        }, null);

        var stack = [],
            results = [],
            _test = function _test(token, re) {
          var m = token.match(re);
          return m == null ? null : m;
        },
            _peek = function _peek() {
          return stack.length > 0 ? stack[stack.length - 1] : null;
        },
            _isBalanced = function _isBalanced(endTag) {
          var p = _peek();

          return p != null && p.tag === endTag;
        },
            _push = function _push(el, doNotSetCurrent) {
          if (stack.length > 0) _peek().children.push(el);
          if (!doNotSetCurrent) stack.push(el); // push to stack, unless told not to
          else if (stack.length === 0) results.push(el); // if not pushing to stack and the stack is empty, must push to results or we'll lose this one.
        },
            _pushChild = function _pushChild(el) {
          _push(el, true);
        },
            _pop = function _pop() {
          var r = stack.pop();

          if (stack.length === 0 && !r.remove) {
            results.push(r);
          } else {
            if (r.remove) {
              // remove the entry (and therefore all its children) from the children of its parent.
              var parent = _peek();

              if (parent) parent.children.pop();
            }
          }

          return r;
        },
            _openElementHandler = function _openElementHandler(t, m, templateResolver, parseStack) {
          var ta = parseAtts(t, _this2);

          if (_this2.isCustomElement(ta.el)) {
            return _this2.constructElement(ta.el, ta, templateResolver, stack, parseIdStack);
          } else {
            return new ElementEntry(ta, _this2, templateResolver, stack, parseIdStack);
          }
        },
            tagHandlers = [{
          re: this.commentRe,
          handler: function handler(t, m, templateResolver, instance, parseStack) {
            //_rotors.debug("comment", t, m)
            _push(new CommentEntry(t, instance), true);
          }
        }, {
          re: this.openRe,
          handler: function handler(t, m, templateResolver, instance, parseStack) {
            var ee = _openElementHandler(t, m, templateResolver);

            _push(ee, ee.remove);
          }
        }, {
          re: this.closeRe,
          handler: function handler(t, m, templateResolver, instance, parseStack) {
            if (m[1] === "r-tmpl") {
              return;
            }

            if (!_isBalanced(m[1])) {
              throw new TypeError("Unbalanced closing tag '" + m[1] + "'; opening tag was '" + _pop().tag + "'");
            } else _pop();
          }
        }, {
          re: this.openCloseRe,
          handler: function handler(t, m, templateResolver, instance, parseStack) {
            //_rotors.debug("open and close element", t, m)
            var ee = _openElementHandler(t, m, templateResolver);

            _push(ee, true);
          }
        }, {
          re: /.*/,
          handler: function handler(t, m, templateResolver, instance, parseStack) {
            //_rotors.debug("text node", t)
            var te = new TextEntry({
              value: t
            }, _this2);

            _pushChild(te);

            _addBinding("__element", t, te, null, _this2);
          }
        }];

        eachNotEmpty(fastTrim(str).split(this.tokenizerRe), function (index, item) {
          var trimmed = fastTrim(item);

          for (var j = 0; j < tagHandlers.length; j++) {
            //item = _trim(item)
            var m = _test(trimmed, tagHandlers[j].re);

            if (m) {
              tagHandlers[j].handler(item, m, templateResolver, _this2, parseIdStack);
              break;
            }
          }
        }); //if (results.length == 0)
        //  what to do? malformed, seemingly.

        if (results.length > 0 && extraProperties) {
          for (var prop in extraProperties) {
            results[0][prop] = extraProperties[prop];
          }
        }

        return results;
      }
    }, {
      key: "compile",
      value: function compile(ast, precompileOnly, functionBodyOnly, isCustomScope) {
        // create data stack, fragment (which in browser is a DocumentFragment and on the server a Fakement, a stack
        // for the current parent element, and a execution id, which is a globally unique id that will be in scope for
        // every function executed in this template, and can subsequently be used to retrieve all of the elements associated
        // with a particular execution of this template function,
        var items = [],
            fn;

        for (var i = 0; i < ast.length; i++) {
          var content = "";

          if (ast[i].precompile) {
            content += ast[i].precompile(this);
          }

          fn = ast[i].compile(isCustomScope);
          content += fn;
          ast[i].functionBody = fn;

          if (ast[i].postcompile) {
            content += ast[i].postcompile(this);
          }

          items.push(content);
        }

        var fb = items.join("");
        if (functionBodyOnly) return fb;

        var f = this._compileSingle(fb),
            _r = this;

        if (!precompileOnly) {
          var _cf = function _cf(data) {
            return f.apply(this, [data, _r]);
          };

          _cf.functionBody = fb;
          return _cf;
        } else {
          return f;
        }
      }
    }, {
      key: "_compileSingle",
      value: function _compileSingle(fb) {
        return new Function("__knockleData,_rotors", this._fnPreamble + fb + this._fnSuffix);
      } // compiles then executes a single function body using the given data

    }, {
      key: "_executeSingle",
      value: function _executeSingle(fb, data) {
        return this._compileSingle(fb)(data, this);
      }
    }, {
      key: "updateFrom",
      value: function updateFrom(entry, newEntry, parent) {
        var handler = this.entries[entry.id];
        return handler.updateFrom(entry, newEntry, parent);
      }
    }, {
      key: "getTemplate",
      value: function getTemplate(id) {
        return this.templateCache.get(id);
      }
    }, {
      key: "addTemplate",
      value: function addTemplate(id, content) {
        this._templates[id] = content;
      }
    }, {
      key: "template",
      value: function template(id, data, templateResolver, forceReload) {
        var _this3 = this;

        var cachedTemplate = !forceReload ? this.templateCache.get(id) : null;

        if (cachedTemplate != null) {
          return cachedTemplate(data);
        } else {
          templateResolver = this._wrapCache(templateResolver || function (id) {
            return _this3.resolveTemplate(id);
          }, forceReload);
          var content = templateResolver(id);

          if (content != null) {
            var p = this.parse(content, templateResolver, null, [id]),
                c = this.compile(p);
            this.templateCache.set(id, c);
            return c(data);
          } else {
            return this.cf();
          }
        }
      }
    }, {
      key: "peek",
      value: function peek$1(stack) {
        return peek(stack);
      }
      /**
       * Get, or set, a value from/to an object.
       * @param inObj Object to operate on
       * @param path Path to the value to get/set
       * @param value If null, this method gets a value. Otherwise, this method sets a value.
       */

    }, {
      key: "data",
      value: function data$1(inObj, path, value) {
        return data(inObj, path, value);
      }
    }, {
      key: "each",
      value: function each(l, fn, loopUuid, ctx, key) {
        var i;

        if (Array.isArray(l)) {
          for (i = 0; i < l.length; i++) {
            fn(l[i], loopUuid, i, ctx, key);
          }
        } else {
          for (i in l) {
            if (l.hasOwnProperty(i)) {
              fn({
                "$key": i,
                "$value": l[i]
              }, loopUuid, i, ctx, key);
            }
          }
        }
      }
    }, {
      key: "update",
      value: function update(el, data) {
        var _this4 = this;

        var eid = el._rotorsEid,
            executionContext,
            rootEntry,
            _rotors,
            rootRotorsEntry;

        if (eid == null || el._rotors == null) return; // otherwise, retrieve the context and get the entry for this specific element.
        else {
          _rotors = el._rotors.instance;
          executionContext = _rotors.executions[eid];
          var idx = el._rotorsKey,
              key = el._rotors.uuid + (idx != null ? "-" + idx : "");
          rootEntry = executionContext[key];
          rootRotorsEntry = _rotors.entries[rootEntry.id];
        }

        var newFrag = _rotors._executeSingle(rootRotorsEntry.customParent ? rootRotorsEntry.customParent.functionBody : rootRotorsEntry.functionBody, data),
            newRoot = newFrag.childNodes[0],
            newEid = newRoot._rotorsEid,
            newExecutionContext = _rotors.executions[newEid],
            newRootEntry = newExecutionContext[newRoot._rotors.uuid]; // recurse down from the root entry and merge in the new version of each entry.
        // r-each might result in elements being added or removed, as might r-if


        var result = this.updateFrom(rootEntry, newRootEntry, null);
        result.elements.forEach(function (_ref) {
          var _ref2 = _slicedToArray$1(_ref, 2),
              el = _ref2[0],
              tag = _ref2[1];

          tag.updated(el, data, _this4);
        });
        return result;
      }
    }, {
      key: "onUpdate",
      value: function onUpdate(el, fn) {
        if (el._rotors == null) return;
        var _rotors = el._rotors.instance;
        el._RotorsUpdate = el._RotorsUpdate || uuid();
        _rotors.updaters[el._RotorsUpdate] = _rotors.updaters[el._RotorsUpdate] || [];

        _rotors.updaters[el._RotorsUpdate].push(fn);
      }
    }, {
      key: "copyChildNodes",
      value: function copyChildNodes(from, to) {
        var j = from.childNodes.length;

        for (var i = 0; i < j; i++) {
          to.appendChild(from.childNodes[0]);
        }
      }
      /**
       * Removes the given element from this Knockle instance, and optionally removes it from the DOM too.
       * @param el Element to remove.
       * @param removeFromDOM Whether or not to also remove from the DOM.
       */

    }, {
      key: "remove",
      value: function remove(el, removeFromDOM) {
        if (el._RotorsUpdate && this.updaters[el._RotorsUpdate]) {
          delete this.updaters[el._RotorsUpdate];
        }

        if (el._rotorsEid && this.executions[el._rotorsEid]) {
          delete this.executions[el._rotorsEid];
        }

        if (removeFromDOM) {
          el.parentNode && el.parentNode.removeChild(el);
        }
      }
    }, {
      key: "registerTag",
      value: function registerTag(tagName, handlers, isGlobal) {
        var tag = new CustomTag(this, tagName, handlers);

        if (isGlobal) {
          this.registerGlobalTag(tagName, tag);
        } else {
          this.customTags[tagName] = tag;
        }
      }
    }, {
      key: "getCustomTag",
      value: function getCustomTag(tagName) {
        return this.customTags[tagName] || this.getGlobalTag(tagName);
      }
    }, {
      key: "customTagRendered",
      value: function customTagRendered(tagName, el, data) {
        var t = this.getCustomTag(tagName);

        if (t) {
          t.rendered(el, data, this);
        }
      }
    }]);

    return Knockle;
  }();

  /**
   * An `r-each` tag.
   * @internal
   */

  var EachEntry = /*#__PURE__*/function (_ElementEntry) {
    _inherits$6(EachEntry, _ElementEntry);

    var _super = _createSuper$6(EachEntry);

    function EachEntry(data, instance, templateResolver, stack, parseIdStack) {
      var _this;

      _classCallCheck$b(this, EachEntry);

      _this = _super.call(this, data, instance, templateResolver, stack, parseIdStack);

      _defineProperty$a(_assertThisInitialized$6(_this), "key", void 0);

      _defineProperty$a(_assertThisInitialized$6(_this), "type", "each");

      _this.context = data.atts["in"];
      _this.key = data.atts["key"];
      _this.tag = "r-each";
      return _this;
    }

    _createClass$b(EachEntry, [{
      key: "compile",
      value: function compile() {
        var _this2 = this;

        var _getChildContent = function _getChildContent() {
          var out = "function(item, _rotorsLoopId, _rotorsLoopIndex, _rotorsLoopContext, _key) { ";
          out += "__knockleData.unshift(item);$value=item;";
          out += "$key=_key ? _rotors.data($value, _key) : _rotorsLoopIndex;";

          for (var i = 0; i < _this2.children.length; i++) {
            var cfb = _this2.children[i].compile();

            _this2.children[i].functionBody = cfb;
            out += cfb;
          }

          out += "__knockleData.splice(0,1);";
          out += "}";
          return out;
        };

        var l1 = ";_rotors.te(null, _eid, '" + this.uuid + "');";
        var l2 = this.context ? ";__knockleData.unshift(_rotors.data(__knockleData[0], \"" + this.context + "\"));" : "";
        var l3 = "_rotors.each(__knockleData[0], " + _getChildContent() + ",'" + this.uuid + "', '" + this.context.replace(/'/g, "\\'") + "'," + (typeof this.key == 'undefined' ? "null);" : "'" + this.key + "');");
        var l4 = this.context ? ";__knockleData.splice(0, 1);" : "";
        var l5 = ";_rotors.pet(_eid, '" + this.uuid + "');";
        return l1 + l2 + l3 + l4 + l5;
      }
    }, {
      key: "updateFrom",
      value: function updateFrom(entry, newEntry, parent) {
        var updates = _updateParent(this.instance, entry, newEntry, ["id", "index"], parent);

        var childEntry,
            domEl = null; // newEntry.children has the order we want. ensure they are in the correct order.

        for (var i = 0; i < newEntry.children.length; i++) {
          childEntry = _findChild({
            index: newEntry.children[i].index,
            id: newEntry.children[i].id
          }, entry);

          if (childEntry && childEntry.el) {
            if (domEl != null) {
              domEl.parentNode.insertBefore(childEntry.el, domEl.nextSibling);
            }

            domEl = childEntry.el;
          }
        }

        return updates;
      }
    }]);

    return EachEntry;
  }(ElementEntry);
  Elements.register("r-each", EachEntry);

  var IfEntry = /*#__PURE__*/function (_ElementEntry) {
    _inherits$6(IfEntry, _ElementEntry);

    var _super = _createSuper$6(IfEntry);

    function IfEntry(data, instance, templateResolver, stack, parseIdStack) {
      var _this;

      _classCallCheck$b(this, IfEntry);

      _this = _super.call(this, data, instance, templateResolver, stack, parseIdStack);

      _defineProperty$a(_assertThisInitialized$6(_this), "type", "if");

      _defineProperty$a(_assertThisInitialized$6(_this), "test", void 0);

      _defineProperty$a(_assertThisInitialized$6(_this), "happyFlowChildren", void 0);

      _this.test = data.atts["test"];
      _this.tag = "r-if";
      return _this;
    }

    _createClass$b(IfEntry, [{
      key: "compile",
      value: function compile() {
        var c = "",
            _else = "",
            i;
        var happyFlow = this.happyFlowChildren || this.children;

        for (i = 0; i < happyFlow.length; i++) {
          c += happyFlow[i].compile() + ";";
        }

        if (this.happyFlowChildren != null) {
          // if happy flow was set, then `children` is unhappy flow.
          _else = "else {";

          for (i = 0; i < this.children.length; i++) {
            _else += this.children[i].compile() + ";";
          }

          _else += "}";
        }

        var l1 = ";_rotors.te(null, _eid, '" + this.uuid + "');";
        return l1 + "with (__knockleData[0]) { if(" + this.test + ") { " + c + " }" + _else + "}_rotors.pet(_eid);";
      }
    }, {
      key: "updateFrom",
      value: function updateFrom(entry, newEntry, parent) {
        return _updateParent(this.instance, entry, this.flatMap(newEntry), ["id"], parent);
      } //
      // flattens the given Execution to extract the child elements from any nested tags like r-each or r-if. only
      // one level of nesting is supported.
      //

    }, {
      key: "flatMap",
      value: function flatMap(entry) {
        var mappedChildren = [];
        entry.children.forEach(function (c) {
          if (c.el == null) {
            mappedChildren.push.apply(mappedChildren, _toConsumableArray(c.children));
          } else {
            mappedChildren.push(c);
          }
        });
        return {
          el: entry.el,
          index: entry.index,
          id: entry.id,
          children: mappedChildren
        };
      }
    }]);

    return IfEntry;
  }(ElementEntry);
  Elements.register("r-if", IfEntry);

  var ElseEntry = /*#__PURE__*/function (_ElementEntry) {
    _inherits$6(ElseEntry, _ElementEntry);

    var _super = _createSuper$6(ElseEntry);

    function ElseEntry(ta, instance, templateResolver, stack, parseIdStack) {
      var _this;

      _classCallCheck$b(this, ElseEntry);

      _this = _super.call(this, ta, instance, templateResolver, stack, parseIdStack);
      var ifStatement = peek(stack);

      if (ifStatement != null) {
        if (ifStatement instanceof IfEntry) {
          ifStatement.happyFlowChildren = ifStatement.children;
          ifStatement.children = [];
        }
      }

      _this.remove = true;
      _this.tag = "r-else";
      return _this;
    }

    _createClass$b(ElseEntry, [{
      key: "compile",
      value: function compile() {
        return "";
      }
    }, {
      key: "updateFrom",
      value: function updateFrom(entry, newEntry, parent) {
        return emptyUpdateResult();
      }
    }]);

    return ElseEntry;
  }(ElementEntry);
  Elements.register("r-else", ElseEntry);

  var TmplEntry = /*#__PURE__*/function (_ElementEntry) {
    _inherits$6(TmplEntry, _ElementEntry);

    var _super = _createSuper$6(TmplEntry);

    function TmplEntry(ta, instance, templateResolver, stack, parseIdStack) {
      var _this;

      _classCallCheck$b(this, TmplEntry);

      _this = _super.call(this, ta, instance, templateResolver, stack, parseIdStack);

      _defineProperty$a(_assertThisInitialized$6(_this), "templateId", void 0);

      _defineProperty$a(_assertThisInitialized$6(_this), "lookup", void 0);

      _defineProperty$a(_assertThisInitialized$6(_this), "default", void 0);

      _this.context = ta.atts["context"];
      _this.type = "template";
      _this.remove = true;

      if (!ta.atts["lookup"]) {
        _this.templateId = ta.atts["id"];
        var insideLoop = isLoopPresent(stack);

        if (parseIdStack.indexOf(_this.templateId) !== -1) {
          if (!insideLoop) {
            throw new TypeError("recursive template call [" + _this.templateId + "]");
          } else {
            _this.compile = function () {
              return ";eval(_rotors.getTemplate('" + _this.templateId + "').functionBody);";
            };
          }
        } else {
          // insert the nested ast. this means resolving the template, creating an ast, and inserting all
          // the entries. also, push the template id on the parse stack, to avoid recursing on the same
          // template
          var _nested = templateResolver(_this.templateId);

          parseIdStack.push(_this.templateId);

          var nestedAst = _this.instance.parse(_nested, templateResolver, null, parseIdStack); // if not in the template cache, compile it and add it.


          if (_this.instance.templateCache.get(_this.templateId) == null) {
            _this.instance.templateCache.set(_this.templateId, _this.instance.compile(nestedAst));
          } // write context in to nested ast roots


          for (var i = 0; i < nestedAst.length; i++) {
            nestedAst[i].context = _this.context;
          } //_rotors.debug("nested ast", nestedAst)


          _this.children = nestedAst;
          parseIdStack.pop();
        }
      } else {
        _this.lookup = ta.atts["lookup"];
        _this["default"] = ta.atts["default"] || "";

        _this.compile = function () {
          return ";with(__knockleData[0]){var tlid=eval(\"" + _this.lookup.replace(/[\$\{\}]/g, "") + "\");}" + "if (_rotors.templateCache[tlid] == null){var ___t = _rotors.resolveTemplate(tlid) || _rotors.resolveTemplate(\"" + _this["default"] + "\");_rotors.templateCache[tlid]=_rotors.compile(_rotors.parse(___t));} eval(_rotors.templateCache[tlid].functionBody);";
        };
      }

      _this.precompile = function () {
        return _this.context ? ";__knockleData.unshift(_rotors.data(__knockleData[0], \"" + _this.context + "\"));" : "";
      };

      _this.postcompile = function () {
        return _this.context ? ";__knockleData.splice(0, 1);" : "";
      };

      return _this;
    }

    _createClass$b(TmplEntry, [{
      key: "updateFrom",
      value: function updateFrom(entry, newEntry, parent) {
        return {
          added: [],
          removed: [],
          elements: []
        };
      }
    }]);

    return TmplEntry;
  }(ElementEntry);
  Elements.register("r-tmpl", TmplEntry);

  var HtmlEntry = /*#__PURE__*/function (_ElementEntry) {
    _inherits$6(HtmlEntry, _ElementEntry);

    var _super = _createSuper$6(HtmlEntry);

    function HtmlEntry(ta, instance, templateResolver, stack, parseIdStack) {
      _classCallCheck$b(this, HtmlEntry);

      return _super.call(this, ta, instance, templateResolver, stack, parseIdStack);
    }

    _createClass$b(HtmlEntry, [{
      key: "compile",
      value: function compile() {
        // r-html is expected to have a text node of the form ${key}, where `key` is the key in the data to retrieve and
        // render as html. if there is no such text node, or it is not of the correct form, the error is logged and
        // the html insertion stops.
        try {
          var key = this.children[0].bindings.__element.e[0][1];
          return ";var __hp=_rotors.parse(__knockleData[0]." + key + "),__hc=_rotors.compile(__hp,true);var __f=__hc(__knockleData[0], _rotors);_rotors.copyChildNodes(__f, _rotors.peek(_els));";
        } catch (e) {
          //_rotors.maybeDebug("Could not find key to bind for r-html element. Should be in the form <r-html>${key}</r-html> ('key' can be anything)")
          return "";
        }
      }
    }, {
      key: "updateFrom",
      value: function updateFrom(entry, newEntry, parent) {
        return emptyUpdateResult();
      }
    }]);

    return HtmlEntry;
  }(ElementEntry);
  Elements.register("r-html", HtmlEntry);

  function _classCallCheck$a(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$a(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$a(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$a(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$a(Constructor, staticProps);
    return Constructor;
  }

  function _inherits$5(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf$5(subClass, superClass);
  }

  function _getPrototypeOf$5(o) {
    _getPrototypeOf$5 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$5(o);
  }

  function _setPrototypeOf$5(o, p) {
    _setPrototypeOf$5 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$5(o, p);
  }

  function _isNativeReflectConstruct$5() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _assertThisInitialized$5(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn$5(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }

    return _assertThisInitialized$5(self);
  }

  function _createSuper$5(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$5();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf$5(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$5(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn$5(this, result);
    };
  }

  var SVG_NAMESPACE = "svg";
  var XLINK_NAMESPACE = "xlink";
  /**
   * Default implementation of TemplateResolver for use in browsers.
   * @param tid
   * @internal
   */

  function InBrowserTemplateResolver(tid) {
    var d = document.getElementById(tid);
    return d != null ? d.innerHTML : null;
  }
  /**
   * Implementation of Knockle for use with the browser-ui package.
   * @internal
   */

  var BrowserUiKnockle = /*#__PURE__*/function (_Knockle) {
    _inherits$5(BrowserUiKnockle, _Knockle);

    var _super = _createSuper$5(BrowserUiKnockle);

    function BrowserUiKnockle(options, registerGlobalTag, getGlobalTag) {
      var _this;

      _classCallCheck$a(this, BrowserUiKnockle);

      _this = _super.call(this, options, registerGlobalTag, getGlobalTag);

      _this.namespaceHandlers[SVG_NAMESPACE] = function (tag) {
        return "e = document.createElementNS('http://www.w3.org/2000/svg', '" + tag.split(":")[1] + "');" + "e.setAttribute('version', '1.1');" + "e.setAttribute('xmlns', 'http://www.w3.org/1999/xhtml');";
      };

      _this.namespaces[XLINK_NAMESPACE] = "http://www.w3.org/1999/xlink";
      return _this;
    }
    /**
     * create an element with the given tag name
     * @internal
     * @param tag
     */


    _createClass$a(BrowserUiKnockle, [{
      key: "ce",
      value: function ce(tag) {
        return document.createElement(tag);
      }
      /**
       * create a fragment
       * @internal
       */

    }, {
      key: "cf",
      value: function cf() {
        return document.createDocumentFragment();
      }
      /**
       * create a text node
       * @internal
       * @param value
       */

    }, {
      key: "ctn",
      value: function ctn(value) {
        return document.createTextNode(value);
      }
      /**
       * @internal
       * @private
       */

    }, {
      key: "_getDefaultTemplateResolver",
      value: function _getDefaultTemplateResolver() {
        return InBrowserTemplateResolver;
      }
    }]);

    return BrowserUiKnockle;
  }(Knockle);
  /**
   * @internal
   * @param options
   */

  function newKnockleInstance(options) {
    return new BrowserUiKnockle(options || {}, registerGlobalTag, getCustomTag);
  }

  function _classCallCheck$9(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$9(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$9(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$9(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$9(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty$9(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _inherits$4(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf$4(subClass, superClass);
  }

  function _getPrototypeOf$4(o) {
    _getPrototypeOf$4 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$4(o);
  }

  function _setPrototypeOf$4(o, p) {
    _setPrototypeOf$4 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$4(o, p);
  }

  function _isNativeReflectConstruct$4() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _assertThisInitialized$4(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn$4(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }

    return _assertThisInitialized$4(self);
  }

  function _createSuper$4(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$4();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf$4(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$4(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn$4(this, result);
    };
  }

  var _defaultTemplate = "<div data-jtk-node-id=\"${id}\" class=\"" + CLASS_NODE + "\"></div>";
  /**
   * Template renderer that uses the Toolkit's template engine.
   */


  var KnockleTemplateRenderer = /*#__PURE__*/function () {
    function KnockleTemplateRenderer(params) {
      _classCallCheck$9(this, KnockleTemplateRenderer);

      _defineProperty$9(this, "knockle", void 0);

      _defineProperty$9(this, "reactive", false);

      _defineProperty$9(this, "surface", null);

      _defineProperty$9(this, "currentVertex", null);

      params = params || {};
      this.knockle = newKnockleInstance({
        defaultTemplate: _defaultTemplate,
        templateResolver: params.templateResolver,
        templates: params.templates
      });

      if (params.tags) {
        for (var t in params.tags) {
          this.registerTag(t, params.tags[t]);
        }
      }
    }

    _createClass$9(KnockleTemplateRenderer, [{
      key: "render",
      value: function render(templateId, data, dataSource, objectType, renderer, def, obj, node) {
        this.surface = renderer;
        this.currentVertex = obj;
        var el = this.knockle.template(templateId, data).childNodes[0];
        renderer.vertexRendered(obj, el, def, null);
      }
    }, {
      key: "_cleanup",
      value: function _cleanup(el) {
        this.knockle.remove(el, true);
      }
    }, {
      key: "cleanupVertex",
      value: function cleanupVertex(objId, el) {
        this._cleanup(el);
      }
    }, {
      key: "cleanupPort",
      value: function cleanupPort(objId, el) {
        this._cleanup(el);
      }
    }, {
      key: "addTemplate",
      value: function addTemplate(id, content) {
        this.knockle.addTemplate(id, content);
      }
    }, {
      key: "registerTag",
      value: function registerTag(tagName, options, isGlobal) {
        var _this = this;

        this.knockle.registerTag(tagName, {
          template: options.template,
          rendered: function rendered(el, data, knockle) {
            options.rendered(el, data, knockle, _this.surface, _this.currentVertex);
          },
          updated: function updated(el, data, knockle) {
            options.updated(el, data, knockle, _this.surface, _this.currentVertex);
          }
        }, isGlobal);
      }
    }, {
      key: "update",
      value: function update(el, data, renderer) {
        if (el._rotors && el._rotors.instance === this.knockle) {
          this.currentVertex = renderer.getModelObjectFromElement(el);
          this.surface = renderer;
          var changes = this.knockle.update(el, data); // it is possible that something representing a port has been removed.

          for (var r = 0; r < changes.removed.length; r++) {
            // filter out elements such as text/comment
            if (changes.removed[r].el.nodeType !== 3 && changes.removed[r].el.nodeType !== 8) {
              renderer.jsplumb.unmanage(changes.removed[r].el, true);
            }
          }
        }
      }
    }]);

    return KnockleTemplateRenderer;
  }();

  var BrowserUI = /*#__PURE__*/function (_BrowserUIBase) {
    _inherits$4(BrowserUI, _BrowserUIBase);

    var _super = _createSuper$4(BrowserUI);

    function BrowserUI() {
      _classCallCheck$9(this, BrowserUI);

      return _super.apply(this, arguments);
    }

    _createClass$9(BrowserUI, [{
      key: "render",
      value:
      /**
       * Configures the given element as a Surface, registering it so that it reflects any changes to the underlying data. If
       * there is any data in the Toolkit at the time of this call it is rendered; any data subsequently loaded is automatically
       * rendered. You can supply layout arguments to this method (layout type + layout specific parameters), as well as jsPlumb rules for
       * endpoints, paint styles etc.
       * @param container The Element to render into
       * @param options Render options
       */
      function render$1(container, options, templateRenderer) {
        var tr = templateRenderer || new KnockleTemplateRenderer(options);
        return render(this, container, tr, options);
      }
    }]);

    return BrowserUI;
  }(BrowserUIBase);
  function newInstance(options) {
    options = options || {};
    return new BrowserUI(options);
  } //export const TAG_ENDPOINT = "jtk-endpoint"
  var IngestedSurface = /*#__PURE__*/function (_Surface) {
    _inherits$4(IngestedSurface, _Surface);

    var _super = _createSuper$4(IngestedSurface);

    function IngestedSurface(params, templateRenderer) {
      var _this2;

      _classCallCheck$9(this, IngestedSurface);

      _this2 = _super.call(this, params, templateRenderer);

      _defineProperty$9(_assertThisInitialized$4(_this2), "ingester", void 0);

      _this2.ingester = params.ingester;
      return _this2;
    } // ingestEndpoint (port:Port, endpoint:Endpoint):void {
    //     //this.portEndpointMap[port.getFullId()] = endpoint;
    //     endpoint.uuid = port.getFullId();
    //     (endpoint as any).graph = {
    //         vertex: port.getParent(),
    //         vertexType:port.getParent().objectType,
    //         port: port
    //     }
    // }


    _createClass$9(IngestedSurface, [{
      key: "importNode",
      value: function importNode(el, id) {
        this.jsplumb.getId(el);
        addClass(el, CLASS_NODE);
        this.jsplumb.manage(el); // TODO resolve this casting to `any`. community edition should probably set the `jtk` member, even if empty.

        var np = {
          el: el,
          id: el.jtk.node.id,
          vertex: el.jtk.node
        };

        if (el.jtk.node.group == null) {
          this._layout.vertexAdded(np);
        }

        this.fireNodeAdded(np);
      }
    }, {
      key: "ingest",
      value: function ingest(el, data) {
        this.jsplumb.getContainer().appendChild(el);

        var epMappings = this.ingester._addNode(el, data);

        this.importNode(el, this.ingester.idFunction(el));

        for (var i = 0; i < epMappings.length; i++) {
          this._ingestEndpoint(epMappings[i][0], epMappings[i][1]);
        }
      }
      /**
       * Override loadExistingData method to load from the jsPlumb instance
       * @param params
       * @internal
       */

    }, {
      key: "_loadExistingData",
      value: function _loadExistingData(params) {
        var _this3 = this;

        var n; // otherwise we have to go through all the nodes and edges in the instance and register them as if they had run through
        // our normal rendering process.

        var c = params.jsPlumbInstance.select();
        c.each(function (conn) {
          _this3.connMap[conn.edge.getId()] = conn;
        });
        n = params.jsPlumbInstance.getManagedElements();
        var somethingLoaded = !isEmpty(n);

        for (var id in n) {
          var el = n[id].el;
          this.vertexList.push(el.jtk.node);
          var np = {
            vertex: el.jtk.node,
            el: el,
            id: el.jtk.node.id
          };

          if (n.group == null) {
            np.pos = this._layout.vertexAdded(np);
          } // TODO does this add existing groups?


          this.fireNodeAdded(np);
        }

        return somethingLoaded;
      }
    }]);

    return IngestedSurface;
  }(Surface);

  _defineProperty$9(IngestedSurface, "ingestedSurfaceType", "IngestedSurface");

  function ready(f) {
    if (!_ready) {
      readyFuncs.push(f);
    } else {
      f();
    }
  }
  var readyFuncs = [];
  var _ready = false;

  var _toolkitReady = function _toolkitReady() {
    _ready = true;

    for (var i = 0; i < readyFuncs.length; i++) {
      readyFuncs[i]();
    }
  };

  var Queue = /*#__PURE__*/function () {
    function Queue(templateHolder) {
      _classCallCheck$9(this, Queue);

      this.templateHolder = templateHolder;

      _defineProperty$9(this, "c", 0);
    }

    _createClass$9(Queue, [{
      key: "_dec",
      value: function _dec() {
        this.c--;

        if (this.c <= 0) {
          _toolkitReady();
        }
      }
    }, {
      key: "add",
      value: function add(src) {
        var _this = this;

        this.c++;
        ajax({
          url: src,
          success: function success(html) {
            var ih = _this.templateHolder.innerHTML;
            ih += html;
            _this.templateHolder.innerHTML = ih;

            _this._dec();
          },
          error: function error(http) {
            _this._dec();
          }
        });
      }
    }, {
      key: "ensureNotEmpty",
      value: function ensureNotEmpty() {
        if (this.c <= 0) _toolkitReady();
      }
    }]);

    return Queue;
  }();

  var checkReady = function checkReady() {
    var _do = function _do() {
      if (/complete|loaded|interactive/.test(document.readyState) && typeof document.body !== "undefined" && document.body != null) {
        var _templateHolder = document.getElementById("jsPlumbToolkitTemplates");

        if (!_templateHolder) {
          _templateHolder = document.createElement("div");
          _templateHolder.style.display = "none";
          _templateHolder.id = "jsPlumbToolkitTemplates";
          document.body.appendChild(_templateHolder);
          var queue = new Queue(_templateHolder);
          var tags = document.getElementsByTagName("script");

          for (var i = 0; i < tags.length; i++) {
            var type = tags[i].getAttribute("type"),
                src = tags[i].getAttribute("src");

            if (type == "text/x-jtk-templates") {
              queue.add(src);
            }
          }

          queue.ensureNotEmpty();
        } else {
          _toolkitReady();
        }
      } else {
        setTimeout(_do, 9);
      }
    };

    _do();
  };

  checkReady();

  function _classCallCheck$8(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$8(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$8(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$8(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$8(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty$8(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _inherits$3(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf$3(subClass, superClass);
  }

  function _getPrototypeOf$3(o) {
    _getPrototypeOf$3 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$3(o);
  }

  function _setPrototypeOf$3(o, p) {
    _setPrototypeOf$3 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$3(o, p);
  }

  function _isNativeReflectConstruct$3() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _assertThisInitialized$3(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn$3(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }

    return _assertThisInitialized$3(self);
  }

  function _createSuper$3(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$3();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf$3(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$3(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn$3(this, result);
    };
  }

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf$3(object);
      if (object === null) break;
    }

    return object;
  }

  function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };
    }

    return _get(target, property, receiver || target);
  }

  /**
   * Parameters for layouts that extends AbstractHierarchicalLayout.
   */

  function _allTargetEdgesLoopback(targetEdges, o) {
    for (var i = 0; i < targetEdges.length; i++) {
      if (targetEdges[i].target !== o || targetEdges[i].source !== o) {
        return false;
      }
    }

    return true;
  }

  var AbstractHierarchicalLayout = /*#__PURE__*/function (_AbsoluteBackedLayout) {
    _inherits$3(AbstractHierarchicalLayout, _AbsoluteBackedLayout);

    var _super = _createSuper$3(AbstractHierarchicalLayout);

    function AbstractHierarchicalLayout(params) {
      var _this;

      _classCallCheck$8(this, AbstractHierarchicalLayout);

      _this = _super.call(this, params);

      _defineProperty$8(_assertThisInitialized$3(_this), "_ignoreLoops", void 0);

      _defineProperty$8(_assertThisInitialized$3(_this), "_getRootNode", void 0);

      _defineProperty$8(_assertThisInitialized$3(_this), "_multipleRoots", void 0);

      _defineProperty$8(_assertThisInitialized$3(_this), "_ignorePorts", void 0);

      _this._ignoreLoops = !params.options.ignoreLoops === false;
      _this._multipleRoots = params.options.multipleRoots === true;
      _this._ignorePorts = params.options.ignorePorts === true;

      _this._getRootNode = params.options.getRootNode || function (toolkit) {
        if (params.options.multipleRoots !== false) {
          return toolkit.filter(function (o) {
            if (isNodeVertex(o)) {
              var targetEdges = o.getTargetEdges(); // a node/group can be root if it has no target edges, or if it has only loopback edges, and it is not excluded by the filter.

              return (targetEdges.length === 0 || _allTargetEdgesLoopback(targetEdges, o)) && _this.adapter.filter(o);
            } else {
              return false;
            }
          }).getAll();
        } else {
          return _this._vertices.length > 0 ? [_this._vertices[0]] : null;
        }
      };

      return _this;
    }

    _createClass$8(AbstractHierarchicalLayout, [{
      key: "begin",
      value: function begin(toolkit, parameters) {
        var _this2 = this;

        _get(_getPrototypeOf$3(AbstractHierarchicalLayout.prototype), "begin", this).call(this, toolkit, parameters);

        parameters.ignoreLoops = this._ignoreLoops;
        parameters.getRootNode = this._getRootNode;

        parameters.getChildEdges = parameters.getChildEdges || function (vertex, toolkit) {
          return toolkit.getAllEdgesFor(vertex, function (e) {
            var target = isPort(e.target) ? e.target.getParent() : e.target;
            return (e.source === vertex || _this2._ignorePorts !== true && isPort(e.source) && e.source.getParent() === vertex) && _this2.adapter.filter(target);
          });
        };

        parameters.rootNode = parameters.getRootNode(toolkit);

        if (!parameters.rootNode) {
          this.done = true;
        }
      }
    }]);

    return AbstractHierarchicalLayout;
  }(AbsoluteBackedLayout);

  var ALIGN = {
    center: "center",
    start: "start",
    end: "end"
  };
  var DEFAULT_ALIGN = ALIGN.center;
  var DEFAULT_PADDING$1 = {
    x: 60,
    y: 60
  };
  var SPACING = {
    compress: "compress",
    auto: "auto"
  };
  var DEFAULT_SPACING = SPACING.auto;
  var WIDTH$1 = "width";
  var HEIGHT$1 = "height";
  var HORIZONTAL$1 = "horizontal";
  /**
   * Parameters for the Hierarchical Layout.
   */

  function _isNodeEdgeSource(node, edge) {
    return edge.source === node || edge.source instanceof Port && edge.source.getParent() === node;
  }

  function _getGroupParentLocation(g) {
    return g.parents.length > 0 ? g.parents[0].loc : null;
  }

  function _getGroupParentSize(g, padding) {
    if (g.parents.length === 0) {
      return null;
    } else {
      var s = g.parents[0].size;

      for (var i = 1; i < g.parents.length; i++) {
        s += padding + g.parents[i].size;
      }

      return s;
    }
  }

  function _parentOfGroupIsRoot(g) {
    // here it should suffice to test just the first one, since if it is at root level its siblings are too.
    return g.parents.length > 0 ? g.parents[0].root === true : false;
  }

  function _getParentChildGroup(g) {
    return g.parents.length > 0 ? g.parents[0].childGroup : null;
  }

  function _getParentChildGroupIndex(g) {
    // here we want the index of the last parent in the list, as we use this index to nudge other nodes along.
    return g.parents.length > 0 ? g.parents[g.parents.length - 1].childGroupIndex : null;
  }

  var HierarchicalLayout = /*#__PURE__*/function (_AbstractHierarchical) {
    _inherits$3(HierarchicalLayout, _AbstractHierarchical);

    var _super = _createSuper$3(HierarchicalLayout);

    function HierarchicalLayout(params) {
      var _defineProperty2;

      var _this;

      _classCallCheck$8(this, HierarchicalLayout);

      _this = _super.call(this, params);

      _defineProperty$8(_assertThisInitialized$3(_this), "type", HierarchicalLayout.type);

      _defineProperty$8(_assertThisInitialized$3(_this), "padding", void 0);

      _defineProperty$8(_assertThisInitialized$3(_this), "orientation", void 0);

      _defineProperty$8(_assertThisInitialized$3(_this), "_horizontal", void 0);

      _defineProperty$8(_assertThisInitialized$3(_this), "_axisIndex", void 0);

      _defineProperty$8(_assertThisInitialized$3(_this), "_axisDimension", void 0);

      _defineProperty$8(_assertThisInitialized$3(_this), "_otherAxisIndex", void 0);

      _defineProperty$8(_assertThisInitialized$3(_this), "_axisPositionProperty", void 0);

      _defineProperty$8(_assertThisInitialized$3(_this), "_otherAxisPositionProperty", void 0);

      _defineProperty$8(_assertThisInitialized$3(_this), "_axisSizeProperty", void 0);

      _defineProperty$8(_assertThisInitialized$3(_this), "_otherAxisSizeProperty", void 0);

      _defineProperty$8(_assertThisInitialized$3(_this), "_axisPadding", void 0);

      _defineProperty$8(_assertThisInitialized$3(_this), "_otherAxisPadding", void 0);

      _defineProperty$8(_assertThisInitialized$3(_this), "compress", void 0);

      _defineProperty$8(_assertThisInitialized$3(_this), "invert", void 0);

      _defineProperty$8(_assertThisInitialized$3(_this), "_alignment", void 0);

      _defineProperty$8(_assertThisInitialized$3(_this), "spacing", void 0);

      _defineProperty$8(_assertThisInitialized$3(_this), "_maxSizes", []);

      _defineProperty$8(_assertThisInitialized$3(_this), "_hierarchy", []);

      _defineProperty$8(_assertThisInitialized$3(_this), "_childGroups", []);

      _defineProperty$8(_assertThisInitialized$3(_this), "_visitedNodes", {});

      _defineProperty$8(_assertThisInitialized$3(_this), "_getChildEdges", void 0);

      _defineProperty$8(_assertThisInitialized$3(_this), "_alignmentLocationCalculators", (_defineProperty2 = {}, _defineProperty$8(_defineProperty2, ALIGN.center, function (cg) {
        return _getGroupParentLocation(cg) + _getGroupParentSize(cg, _this._axisPadding) / 2 - (cg.size - _this._axisPadding) / 2; // remove last padding from child group in size calc
      }), _defineProperty$8(_defineProperty2, ALIGN.start, function (cg) {
        return _getGroupParentLocation(cg);
      }), _defineProperty$8(_defineProperty2, ALIGN.end, function (cg) {
        return _getGroupParentLocation(cg) + _getGroupParentSize(cg, 0) - (cg.size - _this._axisPadding);
      }), _defineProperty2));

      _defineProperty$8(_assertThisInitialized$3(_this), "_parentAlignmentCalculators", {
        "center": function center(cg, min, max) {
          var c = (min + max) / 2;
          return c - _getGroupParentSize(cg) / 2;
        },
        "start": function start(cg, min, max) {
          return min;
        },
        "end": function end(cg, min, max) {
          return min;
        }
      });

      _this.invert = params.options.invert;
      _this.spacing = params.options.spacing || DEFAULT_SPACING;
      _this.compress = _this.spacing === SPACING.compress;
      _this._alignment = params.options.align || DEFAULT_ALIGN;
      _this.orientation = params.options.orientation != null ? params.options.orientation : HORIZONTAL$1;
      return _this;
    }

    _createClass$8(HierarchicalLayout, [{
      key: "getDefaultParameters",
      value: function getDefaultParameters() {
        return {
          padding: DEFAULT_PADDING$1,
          orientation: this.orientation,
          locationFunction: this._locationFunction,
          align: this._alignment
        };
      }
    }, {
      key: "begin",
      value: function begin(toolkit, parameters) {
        _get(_getPrototypeOf$3(HierarchicalLayout.prototype), "begin", this).call(this, toolkit, parameters);

        this.orientation = parameters.orientation;
        this._horizontal = this.orientation === HORIZONTAL$1;
        this._axisIndex = this._horizontal ? 0 : 1;
        this._axisDimension = this._horizontal ? WIDTH$1 : HEIGHT$1;
        this._otherAxisIndex = this._horizontal ? 1 : 0;
        this._axisPositionProperty = this._horizontal ? "x" : "y";
        this._otherAxisPositionProperty = this._horizontal ? "y" : "x";
        this._axisSizeProperty = this._horizontal ? "w" : "h";
        this._otherAxisSizeProperty = this._horizontal ? "h" : "w";
        this.padding = parameters.padding;
        this._hierarchy.length = 0;
        this._childGroups.length = 0;
        this._visitedNodes = {};
        this._getChildEdges = parameters.getChildEdges;
        this._maxSizes.length = 0;
        this._axisPadding = this._horizontal ? this.padding.x : this.padding.y;
        this._otherAxisPadding = this._horizontal ? this.padding.y : this.padding.x;
      }
    }, {
      key: "step",
      value: function step(toolkit, parameters) {
        var _this2 = this;

        var rootNodes = Array.isArray(parameters.rootNode) ? parameters.rootNode : [parameters.rootNode],
            currentRoot,
            i,
            j;

        for (var r = 0; r < rootNodes.length; r++) {
          currentRoot = rootNodes[r];

          var rs = this._getSize(currentRoot.id),
              info = this._add(currentRoot, rs, 0, null, null),
              childCount = 0;

          info.root = true; // this will recurse down and place everything.

          childCount = this._doOne(info, 0); // write positions.

          var otherAxis = 0,
              x = void 0,
              y = void 0,
              _otherAxis = function _otherAxis(n, oa) {
            return _this2.compress && n.parents && n.parents.length > 0 ? // TODO alter this so it computes the center of multiple parents.
            _this2.positions.get(_this2._id(n.parents[0].node))[_this2._otherAxisPositionProperty] + _this2._getMaximumParentSizeInAxis(n, _this2._otherAxisIndex) + _this2._otherAxisPadding : oa;
          };

          var rootPositionedAbsolute = false;

          if (childCount === 0 && this.absoluteBacked === true) {
            var absPos = this.getAbsolutePosition(currentRoot);

            if (!isNaN(absPos.x) && !isNaN(absPos.y)) {
              this.setPosition(currentRoot.id, absPos.x, absPos.y);
              rootPositionedAbsolute = true;
            }
          }

          if (!rootPositionedAbsolute) {
            for (i = 0; i < this._hierarchy.length; i++) {
              this._hierarchy[i].otherAxis = otherAxis;

              for (j = 0; j < this._hierarchy[i].entries.length; j++) {
                x = this._axisIndex === 0 ? this._hierarchy[i].entries[j].loc : _otherAxis(this._hierarchy[i].entries[j], otherAxis);
                y = this._axisIndex === 1 ? this._hierarchy[i].entries[j].loc : _otherAxis(this._hierarchy[i].entries[j], otherAxis); // check to see if we will overlap the parent node?

                this.setPosition(this._id(this._hierarchy[i].entries[j].node), x, y, true);
              }

              if (this.invert) {
                if (i < this._hierarchy.length - 1) {
                  this._hierarchy[i].otherAxisSize = this._maxSizes[i + 1] + this._otherAxisPadding;
                  otherAxis -= this._hierarchy[i].otherAxisSize;
                }
              } else {
                this._hierarchy[i].otherAxisSize = this._maxSizes[i] + this._otherAxisPadding;
                otherAxis += this._hierarchy[i].otherAxisSize;
              }
            }
          }
        }

        this.done = true;
      }
    }, {
      key: "_get",
      value: function _get(depth) {
        var h = this._hierarchy[depth];

        if (!h) {
          h = {
            entries: [],
            pointer: 0
          };
          this._hierarchy[depth] = h;
        }

        return h;
      }
    }, {
      key: "_add",
      value: function _add(node, nodeSize, depth, parent, childGroup) {
        // get the info for this level; info contains a list of nodes and a current pointer for position
        // of the next inserted node. this pointer is incremented by the size of each new node plus padding.
        // note that we have derived 'axisIndex' above to tell us whether to use width or height, depending on the
        // layout's orientation.
        var h = this._get(depth),
            // make an entry for this node.
        i = {
          node: node,
          parents: parent == null ? [] : [parent],
          childGroup: childGroup,
          loc: h.pointer,
          index: h.entries.length,
          dimensions: nodeSize,
          size: nodeSize[this._axisSizeProperty],
          children: []
        };

        var otherAxis = nodeSize[this._otherAxisSizeProperty];
        if (this._maxSizes[depth] == null) this._maxSizes[depth] = otherAxis;else this._maxSizes[depth] = Math.max(this._maxSizes[depth], otherAxis); // increment the pointer by the size of the node plus padding.

        h.pointer += nodeSize[this._axisSizeProperty] + this._axisPadding; // add the new node.

        h.entries.push(i); // add to parent's child list.

        parent && parent.children.push(i);
        return i;
      }
    }, {
      key: "_addChildGroup",
      value: function _addChildGroup(cg, depth) {
        var level = this._childGroups[depth];

        if (!level) {
          level = [];
          this._childGroups[depth] = level;
        }

        cg.index = level.length;
        level.push(cg);
      }
    }, {
      key: "_setGroupParentLocation",
      value: function _setGroupParentLocation(g, loc) {
        if (g.parents.length > 0) {
          var delta = loc - g.parents[0].loc;

          for (var i = 0; i < g.parents.length; i++) {
            g.parents[i].loc += delta;
          } // ensure that the pointer for
          // this level is suitable adjusted.


          var lastParent = g.parents[g.parents.length - 1],
              level = this._get(g.depth - 1);

          level.pointer = Math.max(level.pointer, lastParent.loc + lastParent.size + this._axisPadding);
        }
      }
    }, {
      key: "_getMaximumParentSizeInAxis",
      value: function _getMaximumParentSizeInAxis(g, axis) {
        var sizes = map(g.parents, function (p) {
          return p.dimensions[axis === 0 ? "w" : "h"];
        });
        return Math.max.apply(null, sizes);
      }
    }, {
      key: "_alignChildGroup",
      value: function _alignChildGroup(cg) {
        if (cg.size > 0) {
          var idealLoc = this._alignmentLocationCalculators[this._alignment](cg); // get the existing groups for this groups level and find the furthest pointer.


          var groups = this._childGroups[cg.depth],
              lastPointer = this._alignment === ALIGN.end ? Infinity : -Infinity,
              delta = 0;

          if (groups != null && groups.length > 0) {
            var lg = groups[groups.length - 1],
                lgn = lg.nodes[lg.nodes.length - 1];
            lastPointer = this._alignment === ALIGN.end ? lgn.loc - cg.size : lgn.loc + lgn.size + this._axisPadding;
          }

          if (this._alignment !== ALIGN.end && idealLoc >= lastPointer || this._alignment === ALIGN.end && idealLoc <= lastPointer) {
            cg.loc = idealLoc;
          } else {
            delta = lastPointer - idealLoc;
            cg.loc = lastPointer;
          } // place the nodes in the child group now.
          // we may now have to re-center the parent for this group


          var _l = cg.loc,
              startIdx = this._alignment === ALIGN.end ? cg.nodes.length - 1 : 0,
              endIdx = this._alignment === ALIGN.end ? -1 : cg.nodes.length,
              inc = this._alignment === ALIGN.end ? -1 : 1;

          for (var i = startIdx; i !== endIdx; i += inc) {
            cg.nodes[i].loc = _l;
            _l += cg.nodes[i].size;
            _l += this._axisPadding;
          }

          if (delta !== 0) {
            this._alignParents(cg);
          }

          this._addChildGroup(cg, cg.depth);
        }
      }
    }, {
      key: "_alignParent",
      value: function _alignParent(cg) {
        var min = cg.nodes[0].loc,
            max = cg.nodes[cg.nodes.length - 1].loc + cg.nodes[cg.nodes.length - 1].size,
            pl = this._parentAlignmentCalculators[this._alignment](cg, min, max),
            pDelta = pl - _getGroupParentLocation(cg);

        this._setGroupParentLocation(cg, pl);

        if (!_parentOfGroupIsRoot(cg)) {
          // now, find the child group the parent belongs to, and its index in the child group, and adjust the
          // rest of the nodes to the right of the parent in that child group.
          var parentChildGroup = _getParentChildGroup(cg),
              parentChildGroupIndex = _getParentChildGroupIndex(cg);

          for (var i = parentChildGroupIndex + 1; i < parentChildGroup.nodes.length; i++) {
            parentChildGroup.nodes[i].loc += pDelta;
          }
        }
      }
    }, {
      key: "_alignParents",
      value: function _alignParents(cg) {
        var _c = cg;

        while (_c != null) {
          this._alignParent(_c);

          _c = _getParentChildGroup(_c);
        }
      }
    }, {
      key: "_id",
      value: function _id(v) {
        return this.toolkit.getNodeId(v);
      }
    }, {
      key: "_doOne",
      value: function _doOne(info, level) {
        var _this3 = this;

        if (this._visitedNodes[info.node.id]) return;
        this._visitedNodes[info.node.id] = true;

        var edges = [],
            childGroup = {
          nodes: [],
          loc: 0,
          size: 0,
          parents: [info],
          depth: level + 1,
          children: []
        },
            childInfoList = [],
            i,
            visitedChildNodes = {},
            _hierarchyAtChildLevel = this._get(level + 1); // copy the edges in case we sort and affect something upstream


        Array.prototype.push.apply(edges, this._getChildEdges(info.node, this.toolkit));

        var _loop = function _loop() {
          // for each child node, get the node and its element object and dimensions
          var childNode = _isNodeEdgeSource(info.node, edges[i]) ? edges[i].target : edges[i].source;

          if (childNode instanceof Port) {
            childNode = childNode.getParent();
          }

          if (childNode != null && childNode !== info.node && !visitedChildNodes[childNode.id]) {
            var s = _this3._getSize(_this3._id(childNode)); // the node may not have been visited as a child of the current node (the !visitedChildNodes test above), but it
            // may already be a child of some other parent - in which case it will be in the hierarchy at this level


            var existingChildInfo = _hierarchyAtChildLevel.entries.find(function (cn) {
              return _this3._id(cn.node) === _this3._id(childNode);
            });

            if (existingChildInfo != null) {
              existingChildInfo.parents.push(info);

              var parentLoc = _getGroupParentLocation(existingChildInfo),
                  parentSize = _getGroupParentSize(existingChildInfo, _this3._axisPadding),
                  newLoc = parentLoc + parentSize / 2 - existingChildInfo.size / 2,
                  delta = newLoc - existingChildInfo.loc;

              var _childAdjust = function _childAdjust(focus) {
                for (var _i = focus.childGroupIndex; _i < focus.childGroup.nodes.length; _i++) {
                  focus.childGroup.nodes[_i].loc += delta;
                  focus.children.forEach(_childAdjust);
                  focus.childGroup.size += delta;
                }
              };

              _childAdjust(existingChildInfo);
            } else {
              // add the child node to the appropriate level in the hierarchy
              childInfo = _this3._add(childNode, s, level + 1, info, childGroup); // and add it to this node's childGroup too.

              childInfo.childGroupIndex = childGroup.nodes.length;
              childGroup.nodes.push(childInfo); // calculate how much room this child group takes

              var childSize = s[_this3._axisSizeProperty];
              childGroup.size += childSize + _this3._axisPadding;
              childInfoList.push(childInfo);
            }

            visitedChildNodes[childNode.id] = true; //
          }
        };

        for (i = 0; i < edges.length; i++) {
          var childInfo;

          _loop();
        } // now try to align this child group according to the current alignment (center, start, end), with its computed size. this will place the individual node
        // entries, and adjust parents and their siblings as necessary.


        this._alignChildGroup(childGroup);

        for (i = 0; i < childInfoList.length; i++) {
          this._doOne(childInfoList[i], level + 1);
        }

        return edges.length;
      }
      /**
       * Gets the computed hierarchy. This is returned as an array of objects, one for each level, inside which
       * there is a `nodes` array.
       */

    }, {
      key: "getHierarchy",
      value: function getHierarchy() {
        return this._hierarchy;
      }
      /**
       * Gets the orientation of the layout - "horizontal" or "vertical".
       * @returns "horizontal" or "vertical"
       */

    }, {
      key: "getOrientation",
      value: function getOrientation() {
        return this.orientation;
      }
    }, {
      key: "getPadding",
      value: function getPadding() {
        return this.padding;
      }
    }, {
      key: "vertexRemoved",
      value: function vertexRemoved(v) {
        this._hierarchy = [];

        _get(_getPrototypeOf$3(HierarchicalLayout.prototype), "vertexRemoved", this).call(this, v);
      }
    }]);

    return HierarchicalLayout;
  }(AbstractHierarchicalLayout);

  _defineProperty$8(HierarchicalLayout, "type", "Hierarchical");

  Layouts.register(HierarchicalLayout.type, HierarchicalLayout);

  /**
   * Models a cluster of elements. Used internally by a few layouts.
   * @internal
   */
  var ElementCluster = /*#__PURE__*/function () {
    function ElementCluster(focus) {
      _classCallCheck$8(this, ElementCluster);

      this.focus = focus;

      _defineProperty$8(this, "children", new Set());

      _defineProperty$8(this, "positions", new Map());

      _defineProperty$8(this, "incidentAngles", new Map());

      _defineProperty$8(this, "group", void 0);

      _defineProperty$8(this, "extents", void 0);

      _defineProperty$8(this, "offsets", void 0);

      this.group = [focus];
    }

    _createClass$8(ElementCluster, [{
      key: "setPosition",
      value: function setPosition(id, x, y) {
        this.positions.set(id, {
          x: x,
          y: y
        });
      }
    }, {
      key: "getPosition",
      value: function getPosition(id) {
        return this.positions.get(id);
      }
    }, {
      key: "getIncidentAngle",
      value: function getIncidentAngle(id) {
        return this.incidentAngles.get(id);
      }
    }, {
      key: "setIncidentAngle",
      value: function setIncidentAngle(id, theta) {
        this.incidentAngles.set(id, theta);
      }
    }, {
      key: "getPositions",
      value: function getPositions() {
        return this.positions;
      }
    }]);

    return ElementCluster;
  }();
  /**
   * Constructor parameters for a Balloon layout.
   */

  var DEFAULT_GROUP_PADDING = 100;
  var DEFAULT_PADDING = {
    x: 50,
    y: 50
  };
  var BalloonLayout = /*#__PURE__*/function (_AbstractHierarchical) {
    _inherits$3(BalloonLayout, _AbstractHierarchical);

    var _super = _createSuper$3(BalloonLayout);

    function BalloonLayout(params) {
      var _this;

      _classCallCheck$8(this, BalloonLayout);

      _this = _super.call(this, params);

      _defineProperty$8(_assertThisInitialized$3(_this), "type", BalloonLayout.type);

      _defineProperty$8(_assertThisInitialized$3(_this), "_getChildEdges", void 0);

      _defineProperty$8(_assertThisInitialized$3(_this), "_clusters", []);

      _defineProperty$8(_assertThisInitialized$3(_this), "clusterMagnetizer", void 0);

      _defineProperty$8(_assertThisInitialized$3(_this), "groupPadding", void 0);

      _defineProperty$8(_assertThisInitialized$3(_this), "padding", void 0);

      _this.groupPadding = params.options.groupPadding || DEFAULT_GROUP_PADDING;
      _this.padding = params.options.padding || DEFAULT_PADDING;
      _this.clusterMagnetizer = new Magnetizer({
        padding: {
          x: 100,
          y: 100
        },
        getPosition: function getPosition(el) {
          return {
            x: el.extents[0],
            y: el.extents[2]
          };
        },
        setPosition: function setPosition(obj, o) {
          for (var i = 0; i < obj.group.length; i++) {
            var offs = obj.offsets[obj.group[i].id];
            obj.setPosition(obj.group[i].id, o.x + offs.x, o.y + offs.y);
          }
        },
        getSize: function getSize(el) {
          return {
            w: el.extents[1] - el.extents[0],
            h: el.extents[3] - el.extents[2]
          };
        },
        getId: function getId(obj) {
          return obj.focus.id;
        },
        filter: function filter(obj) {
          return _this._clusters[0].focus.id !== obj;
        }
      });
      return _this;
    }

    _createClass$8(BalloonLayout, [{
      key: "getDefaultParameters",
      value: function getDefaultParameters() {
        var _this2 = this;

        return {
          padding: this.padding,
          locationFunction: this._locationFunction,
          groupPadding: this.groupPadding,
          getChildEdges: function getChildEdges(vertex, toolkit) {
            return toolkit.getAllEdgesFor(vertex, function (e) {
              var source = isPort(e.source) ? e.source.getParent() : e.source;
              var target = isPort(e.target) ? e.target.getParent() : e.target;
              return source === vertex && source !== target && _this2.adapter.filter(target);
            });
          }
        };
      }
    }, {
      key: "begin",
      value: function begin(toolkit, parameters) {
        _get(_getPrototypeOf$3(BalloonLayout.prototype), "begin", this).call(this, toolkit, parameters);

        this._clusters.length = 0;
        this._getChildEdges = parameters.getChildEdges;
      }
    }, {
      key: "_one",
      value: function _one(focus, parentParams, parameters) {
        var _this3 = this;

        var paddedRect = function paddedRect(x, y, w, h) {
          return {
            x: x - parameters.padding.x,
            y: y - parameters.padding.y,
            w: w + 2 * parameters.padding.x,
            h: h + 2 * parameters.padding.y
          };
        };

        var radius,
            _cluster = new ElementCluster(focus),
            pos = parentParams ? parentParams.position : {
          x: 0,
          y: 0
        },
            x = pos.x,
            y = pos.y,
            sizeCache = {},
            getSize = function getSize(id) {
          return sizeCache[id] || function () {
            sizeCache[id] = _this3._getSize(id);
            return sizeCache[id];
          }();
        },
            centerNodeSize,
            focusSize,
            centerRect;

        _cluster.setPosition(focus.id, pos.x, pos.y);

        var edges = this._getChildEdges(focus, this.toolkit);

        for (var i = 0; i < edges.length; i++) {
          var t = edges[i].target;
          var target = isPort(t) ? t.getParent() : t;

          _cluster.children.add(target);
        }

        centerNodeSize = getSize(_cluster.focus.id);
        radius = Math.max(centerNodeSize.w, centerNodeSize.h);
        centerRect = paddedRect(x - centerNodeSize.w / 2, y - centerNodeSize.h / 2, centerNodeSize.w, centerNodeSize.h);
        this.setPosition(_cluster.focus.id, -(centerNodeSize.w / 2), -(centerNodeSize.h / 2), true);

        if (_cluster.children.size > 0) {
          this._clusters.push(_cluster);

          var degreesPerNode = 2 * Math.PI / (_cluster.children.size + (parentParams ? 1 : 0));
          var curDegree = parentParams ? parentParams.incidentAngle + Math.PI + degreesPerNode : Math.PI;
          var startDegree = curDegree;
          var n1 = null;

          _cluster.children.forEach(function (n) {
            focusSize = getSize(n.id);
            var pr = paddedRect(x + Math.sin(curDegree) * focusSize.w, y + Math.cos(curDegree) * focusSize.h, focusSize.w, focusSize.h),
                adj = calculateSpacingAdjustment(centerRect, pr),
                d = Math.sqrt(Math.pow(pr.x + adj.x - x, 2) + Math.pow(pr.y + adj.y - y, 2));
            radius = Math.max(radius, d);

            _cluster.setPosition(n.id, pr.x + adj.x, pr.y + adj.y);

            curDegree += degreesPerNode;

            if (n1 != null) {
              var s1 = getSize(n1.id),
                  p1 = _cluster.getPosition(n1.id),
                  r1 = paddedRect(p1.x, p1.y, s1.w, s1.h),
                  s2 = getSize(n.id),
                  p2 = _cluster.getPosition(n.id),
                  r2 = paddedRect(p2.x, p2.y, s2.w, s2.h),
                  _adj = calculateSpacingAdjustment(r1, r2);

              var c1 = {
                x: p1.x + s1.w / 2,
                y: p1.y + s1.h / 2
              },
                  c2 = {
                x: p2.x + _adj.x + s2.w / 2,
                y: p2.y + _adj.y + +(s2.h / 2)
              },
                  _d = Math.sqrt(Math.pow(c1.x - c2.x, 2) + Math.pow(c1.y - c2.y, 2));

              radius = Math.max(radius, _d / 2 / Math.sin(degreesPerNode / 2));
            }

            n1 = n;
          });

          curDegree = startDegree;

          _cluster.children.forEach(function (n) {
            _cluster.setIncidentAngle(n.id, curDegree);

            _cluster.setPosition(n.id, x + Math.sin(curDegree) * radius, y + Math.cos(curDegree) * radius);

            curDegree += degreesPerNode;
          });

          var fpos = _cluster.getPosition(focus.id),
              minx = fpos.x,
              fsize = this._getSize(focus.id),
              maxx = minx + fsize.w,
              miny = fpos.y,
              maxy = miny + fsize.h,
              nsize; // iterate children a second time, looking for clusters


          _cluster.children.forEach(function (n) {
            var hasChildren = _this3._one(n, {
              parent: focus,
              incidentAngle: _cluster.getIncidentAngle(n.id),
              position: _cluster.getPosition(n.id)
            }, parameters);

            if (!hasChildren) {
              nsize = _this3._getSize(n.id);

              _cluster.group.push(n);

              var npos = _cluster.getPosition(n.id);

              minx = Math.min(minx, npos.x);
              maxx = Math.max(maxx, npos.x + nsize.w);
              miny = Math.min(miny, npos.y);
              maxy = Math.max(maxy, npos.y + nsize.h);
            }
          });

          _cluster.extents = [minx, maxx, miny, maxy];
          _cluster.offsets = {}; // for magnetization purposes, a cluster consists of its focus and all of its child nodes that do not
          // themselves have children.

          for (var _i = 0; _i < _cluster.group.length; _i++) {
            var entry = _cluster.group[_i];

            var _pos = _cluster.getPosition(entry.id);

            _cluster.offsets[entry.id] = {
              x: _pos.x - _cluster.extents[0],
              y: _pos.y - _cluster.extents[2]
            };
          }
        }

        return _cluster.children.size;
      }
    }, {
      key: "step",
      value: function step(toolkit, parameters) {
        var _this4 = this;

        if (parameters.rootNode && parameters.rootNode.length > 0) {
          this._one(parameters.rootNode[0], null, parameters); // MAGNETIZE THE CLUSTERS.


          if (this._clusters.length > 0) {
            var cx = (this._clusters[0].extents[0] + this._clusters[0].extents[1]) / 2,
                cy = (this._clusters[0].extents[2] + this._clusters[0].extents[3]) / 2;
            this.clusterMagnetizer.setElements(this._clusters);
            this.clusterMagnetizer.executeAtPoint({
              x: cx,
              y: cy
            });
          } // DRAW THE CLUSTERS


          for (var i = 0; i < this._clusters.length; i++) {
            var cluster = this._clusters[i];
            cluster.getPositions().forEach(function (p, k) {
              _this4.setPosition(k, p.x, p.y, true);
            });
          }
        }

        this.done = true;
      }
    }]);

    return BalloonLayout;
  }(AbstractHierarchicalLayout);

  _defineProperty$8(BalloonLayout, "type", "Balloon");

  Layouts.register(BalloonLayout.type, BalloonLayout);

  function _classCallCheck$7(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$7(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$7(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$7(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$7(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty$7(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;

    var _s, _e;

    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var NONE = "none";
  var LEFT$1 = "left";
  var TOP$1 = "top";
  var RIGHT = "right";
  var BOTTOM = "bottom";
  var PX = "px";
  var ABSOLUTE = "absolute";
  var ATTR_ANCHOR_FACE = "jtk-anchor-face";
  var CLASS_ANCHOR_PLACEHOLDER = "jtk-anchor-placeholder";
  var CLASS_ANCHOR_CANDIDATE = "jtk-anchor-candidate";
  var CLASS_EDGE_DELETE_BUTTON = "jtk-edge-delete";
  var CLASS_CONNECTION_EDIT = "jtk-connection-edit";
  var EVT_CLEAR_CONNECTION_EDITS = "clearConnectionEdits";
  var EVT_START_CONNECTION_EDIT = "startConnectionEdit";
  var EVT_STOP_CONNECTION_EDIT = "stopConnectionEdit";

  function dot(cls) {
    return "." + cls;
  }

  var ANCHOR_PLACEHOLDER_SELECTOR = dot(CLASS_ANCHOR_PLACEHOLDER);
  function _makeHandle(x, y, clazz, visible) {
    var h = document.createElement("div");
    h.className = clazz;
    h.style.position = ABSOLUTE;
    h.style.left = x + PX;
    h.style.top = y + PX;

    if (!visible) {
      h.style.display = NONE;
    }

    return h;
  }
  function _makeAndAppendHandle(x, y, _jsPlumb, clazz, visible) {
    var h = _makeHandle(x, y, clazz, visible);

    _jsPlumb._appendElement(h, _jsPlumb.getContainer());

    var s = _jsPlumb.getSize(h);

    h.style.left = x - s.w / 2 + "px";
    h.style.top = y - s.h / 2 + "px";
    return h;
  }
  function relocateContinuousAnchor(anchor, ep, pos, dragEl, constrainRect, elementSize, idx, connector, instance) {
    var supportedFaces = anchor.faces;
    var parent = dragEl.parentNode;
    var l = [[LEFT$1, pos.x], [RIGHT, constrainRect.w - pos.x], [TOP$1, pos.y], [BOTTOM, constrainRect.h - pos.y]]; //
    // DO NOT refactor this to pass the values in the constructor. IE11 will choke.

    var orientations = new Map();
    orientations.set(TOP$1, [0, -1]);
    orientations.set(BOTTOM, [0, 1]);
    orientations.set(LEFT$1, [-1, 0]);
    orientations.set(RIGHT, [1, 0]);
    l.sort(function (a, b) {
      if (a[1] < b[1]) {
        return -1;
      } else {
        return 1;
      }
    });
    var face = null;

    for (var i = 0; i < l.length; i++) {
      if (supportedFaces.indexOf(l[i][0]) != -1) {
        face = l[i][0];
        break;
      }
    }

    if (face != null) {
      parent.setAttribute(ATTR_ANCHOR_FACE, face);
      instance.router.setCurrentFace(anchor, face);
      instance.router.lock(anchor); // override lock when setting the current face.

      var o = orientations.get(face);

      var r = instance._getRotation(ep.elementId);

      if (r !== 0) {
        o = rotateAnchorOrientation(o, r);
      }

      connector.setAnchorOrientation(idx, o);
    }

    return pos;
  }

  /**
   * Find the closest point out of `locations` to the given point on the given constraining rectangle.
   * @param pos An x,y location in pixel values
   * @param constrainRect Width/height of the bounding box, in pixels
   * @param locations A list of x/y logical locations, whose values are proportional lengths (anchor format).
   */
  function findClosestPoint(pos, constrainRect, locations) {
    var distances = locations.map(function (p, idx) {
      var px = constrainRect.w * p.x,
          py = constrainRect.h * p.y,
          distance = Math.sqrt(Math.pow(pos.x - px, 2) + Math.pow(pos.y - py, 2));
      return {
        p: p,
        idx: idx,
        distance: distance
      };
    });
    distances.sort(function (a, b) {
      if (a.distance < b.distance) {
        return -1;
      } else {
        return 1;
      }
    });
    return distances[0];
  }
  /**
   * Relocate the given dynamic anchor according to the given proximity of `pos` to each of the anchor's supported locations. the face is changed
   * on the anchor itself (and the anchor is locked), and in this case we simply return the current value of `pos`, meaning the user sees the drag proxy
   * under the mouse cursor, which is probably not where the anchor is now positioned, but it makes for a better UX. on drag stop, for all anchor types,
   * the anchor proxy is relocated to the current value.
   * @param anchor
   * @param ep
   * @param pos
   * @param dragEl
   * @param constrainRect
   */

  function relocateDynamicAnchor(anchor, ep, pos, dragEl, constrainRect) {
    var closestPoint = findClosestPoint(pos, constrainRect, anchor.locations);
    anchor.currentLocation = closestPoint.idx;
    return pos;
  }

  function _makeElement(x, y, clazz) {
    var h = document.createElement("div");
    h.className = clazz ? clazz : "";
    h.style.position = ABSOLUTE;
    h.style.left = x + PX;
    h.style.top = y + PX;
    return h;
  }

  function _makeElementAt(parent, x, y, clazz) {
    var parentSize = size(parent);

    var _x = parentSize.w * x,
        _y = parentSize.h * y;

    var el = _makeElement(_x, _y, clazz);

    parent.appendChild(el);
    var s = size(el);
    el.style.left = _x - s.w / 2 + PX;
    el.style.top = _y - s.h / 2 + PX;
    return el;
  }

  /**
   * Base class for connector editors.  This isn't a class that users of the API will ordinarily need to interact directly with.
   * @internal
   */
  var EditorBase = /*#__PURE__*/function () {
    function EditorBase(surface, options) {
      var _this = this;

      _classCallCheck$7(this, EditorBase);

      this.surface = surface;

      _defineProperty$7(this, "current", void 0);

      _defineProperty$7(this, "currentConnector", void 0);

      _defineProperty$7(this, "currentEdge", void 0);

      _defineProperty$7(this, "currentSourceVertex", void 0);

      _defineProperty$7(this, "currentTargetVertex", void 0);

      _defineProperty$7(this, "currentOverlays", []);

      _defineProperty$7(this, "sourceDimensions", void 0);

      _defineProperty$7(this, "targetDimensions", void 0);

      _defineProperty$7(this, "sourceAnchorPlaceholder", void 0);

      _defineProperty$7(this, "targetAnchorPlaceholder", void 0);

      _defineProperty$7(this, "active", void 0);

      _defineProperty$7(this, "jsplumb", void 0);

      _defineProperty$7(this, "anchorPositionFinder", void 0);

      _defineProperty$7(this, "eventManager", void 0);

      _defineProperty$7(this, "update", void 0);

      _defineProperty$7(this, "cleanup", void 0);

      _defineProperty$7(this, "_dragHandlers", {});

      _defineProperty$7(this, "_anchorDragContext", {
        rotation: 0,
        center: {
          x: 0,
          y: 0
        }
      });

      this.active = false;
      this.jsplumb = this.surface.jsplumb;
      this.surface.toolkitInstance.bind(EVENT_GRAPH_CLEAR_START, function () {
        _this.deactivate();
      });
      this.surface.toolkitInstance.bind(EVENT_EDGE_REMOVED, function (p) {
        if (p.edge === _this.currentEdge) {
          _this.deactivate();
        }
      });
      this.surface.toolkitInstance.bind(EVENT_EDGE_PATH_RESTORED, function (p) {
        if (p.edge == _this.currentEdge) {
          _this.repaintConnection();
        }
      });
      this.eventManager = new EventManager(); // this is the drag handler for relocating anchors. it is common to all connector editors.

      this._addDragHandler({
        selector: ANCHOR_PLACEHOLDER_SELECTOR,
        constrainFunction: function constrainFunction(pos, dragEl, constrainRect, elementSize) {
          var a = dragEl._jsPlumbAnchor.anchor;
          var ep = dragEl._jsPlumbAnchor.endpoint;
          var idx = dragEl._jsPlumbAnchor.idx; //
          // if the parent element was rotated we need to rotate the delta in x and y by the opposite of the parent
          // element's rotation. Whilst this works, it does result in the drag element not being under the cursor,
          // and it feels somehow not quite right to be doing this here. The drag manager should know about rotation.
          //

          if (_this._anchorDragContext.rotation !== 0) {
            var start = _this.jsplumb.dragManager.drag._posAtDown;
            var delta = {
              x: pos.x - start.x,
              y: pos.y - start.y
            };
            pos = rotatePoint(delta, _this._anchorDragContext.center, -_this._anchorDragContext.rotation);
          }

          if (_this.anchorPositionFinder != null) {
            var actualElement = dragEl.parentNode;

            var _vertex;

            var domInfo = dragEl.parentNode.jtk;

            if (domInfo != null) {
              _vertex = domInfo.port || domInfo.group || domInfo.node || domInfo.vertex;
            }

            var proportionalPos = {
              x: pos.x / constrainRect.w,
              y: pos.y / constrainRect.h
            };

            var newSpec = _this.anchorPositionFinder(actualElement, proportionalPos, _vertex);

            if (newSpec != null) {
              a.currentLocation = 0;
              a.locations[0].x = newSpec[0];
              a.locations[0].y = newSpec[1];
              a.locations[0].ox = newSpec[2];
              a.locations[0].oy = newSpec[3];
              a.locations[0].iox = newSpec[2];
              a.locations[0].ioy = newSpec[3];
              a.locations[0].offx = newSpec[4] || 0;
              a.locations[0].offy = newSpec[5] || 0;
              pos = {
                x: a.locations[0].x * constrainRect.w,
                y: a.locations[0].y * constrainRect.h
              };
            }
          } else if (isContinuous(a)) {
            pos = relocateContinuousAnchor(a, ep, pos, dragEl, constrainRect, elementSize, idx, _this.current.connector, _this.jsplumb);
          } else {
            pos = relocateDynamicAnchor(a, ep, pos, dragEl, constrainRect
            /*, elementSize, idx, this.current.connector*/
            );
          }

          _this.jsplumb.revalidate(dragEl.parentNode); // constrain anchor placeholder to the parent element.


          var s = [dragEl.offsetWidth, dragEl.offsetHeight],
              b = {
            xmin: -s[0] / 2,
            xmax: constrainRect.w - s[0] / 2,
            ymin: -s[1] / 2,
            ymax: constrainRect.h - s[1] / 2
          };
          return {
            x: pos.x < b.xmin ? b.xmin : pos.x > b.xmax ? b.xmax : pos.x,
            y: pos.y < b.ymin ? b.ymin : pos.y > b.ymax ? b.ymax : pos.y
          };
        },
        start: function start(params) {
          var dragEl = params.drag.getDragElement();
          var a = dragEl._jsPlumbAnchor.anchor;
          var ep = dragEl._jsPlumbAnchor.endpoint;
          var parent = dragEl.parentNode;

          var parentId = _this.jsplumb.getId(parent);

          _this._anchorDragContext.rotation = _this.jsplumb._getRotation(parentId);

          if (_this._anchorDragContext.rotation !== 0) {
            var parentSize = _this.jsplumb.getSize(parent);

            _this._anchorDragContext.center = {
              x: parentSize.w / 2,
              y: parentSize.h / 2
            };
          } // if not using a position finder, draw candidate locations, or highlight a face for continuous


          if (_this.anchorPositionFinder == null) {
            if (isContinuous(a)) {
              // highlight current face
              dragEl.parentNode.setAttribute(ATTR_ANCHOR_FACE, a.currentFace);
            } else {
              // we handle dynamic + static here, since the difference is simply in the number of locations
              // they declare.
              var locs = a.locations.map(function (_a) {
                return [_a.x, _a.y, _a.ox, _a.oy];
              });
              locs.forEach(function (loc) {
                _makeElementAt(ep.element, loc[0], loc[1], CLASS_ANCHOR_CANDIDATE);
              });
            }
          }
        },
        stop: function stop(params) {
          var parent = params.el.parentNode;
          var dragEl = params.drag.getDragElement();
          var a = dragEl._jsPlumbAnchor.anchor;
          var ep = dragEl._jsPlumbAnchor.endpoint;

          if (isContinuous(a)) {
            // stop highlighting current face
            parent.removeAttribute(ATTR_ANCHOR_FACE);
          }

          var candidates = ep.element.querySelectorAll(dot(CLASS_ANCHOR_CANDIDATE));
          candidates.forEach(function (c) {
            return c.parentNode.removeChild(c);
          });

          _this._drawAnchorPlaceholders();

          _this._update();

          _this.fireConnectionEditEvent();
        },
        drag: function drag(params) {
          _this._update();
        }
      }, true);

      this.surface.bind(EVENT_NODE_MOVE_END, function (p) {
        // check if the moved node is connected to a connection we are editing.
        if (_this.active && _this.currentEdge && (p.vertex === _this.currentEdge.source || p.vertex === _this.currentEdge.target)) {
          _this._elementDragged(p);

          _this.fireConnectionEditEvent();
        }
      });
      this.surface.bind(EVENT_NODE_MOVE, function (p) {
        // check if the moving node is connected to a connection we are editing.
        if (_this.active && _this.currentEdge && (p.vertex === _this.currentEdge.source || p.vertex === _this.currentEdge.target)) {
          _this._elementDragging(p);
        }
      });
      this.surface.bind(EVENT_GROUP_MOVE_END, function (p) {
        // check if the moved node is connected to a connection we are editing.
        if (_this.active && _this.currentEdge && (p.vertex === _this.currentEdge.source || p.vertex === _this.currentEdge.target)) {
          _this._elementDragged(p);

          _this.fireConnectionEditEvent();
        }
      });
      this.surface.bind(EVENT_GROUP_MOVE, function (p) {
        // check if the moving node is connected to a connection we are editing.
        if (_this.active && _this.currentEdge && (p.vertex === _this.currentEdge.source || p.vertex === _this.currentEdge.target)) {
          _this._elementDragging(p);
        }
      });
      this.surface.toolkitInstance.bind(EVENT_NODE_UPDATED, function (p) {
        // check if the moved node is connected to a connection we are editing.
        if (_this.active && _this.currentEdge && (p.vertex === _this.currentEdge.source || p.vertex === _this.currentEdge.target)) {
          _this._elementDragged(p);

          _this.fireConnectionEditEvent();
        }
      });
      this.surface.toolkitInstance.bind(EVENT_GROUP_UPDATED, function (p) {
        // check if the moved node is connected to a connection we are editing.
        if (_this.active && _this.currentEdge && (p.vertex === _this.currentEdge.source || p.vertex === _this.currentEdge.target)) {
          _this._elementDragged(p);

          _this.fireConnectionEditEvent();
        }
      });
    }

    _createClass$7(EditorBase, [{
      key: "_attachOverlay",
      value: function _attachOverlay(connection, overlaySpec) {
        var os = {
          type: overlaySpec.type,
          options: extend(overlaySpec.options, {
            id: uuid()
          })
        };
        this.currentOverlays.push(connection.addOverlay(os));
        this.repaintConnection();
      }
    }, {
      key: "_attachOverlays",
      value: function _attachOverlays(connection, overlaySpecs) {
        var _this2 = this;

        this._detachOverlays();

        overlaySpecs.forEach(function (overlaySpec) {
          _this2._attachOverlay(connection, overlaySpec);
        });
      }
    }, {
      key: "_detachOverlays",
      value: function _detachOverlays() {
        var _this3 = this;

        this.currentOverlays.forEach(function (o) {
          _this3.current.removeOverlay(o.id);
        });
      }
    }, {
      key: "_attachDeleteButton",
      value: function _attachDeleteButton(params) {
        var _this4 = this;

        var cls = params.deleteButtonClass || CLASS_EDGE_DELETE_BUTTON;
        var loc = params.deleteButtonLocation || 0.1;

        var doRemove = function doRemove() {
          return _this4.surface.toolkitInstance.removeEdge(_this4.currentEdge);
        };

        var deleteHandler = function deleteHandler() {
          if (params.onMaybeDelete) {
            params.onMaybeDelete(_this4.currentEdge, _this4.current, doRemove);
          } else {
            doRemove();
          }
        };

        if (!Array.isArray(loc)) {
          loc = [loc];
        }

        loc.forEach(function (l) {
          _this4._attachOverlay(_this4.current, {
            type: LabelOverlay.type,
            options: {
              location: l,
              cssClass: cls,
              events: {
                click: deleteHandler
              }
            }
          });
        });
      }
      /**
       * Repaints the current connection, passing some arguments, optionally. These are retrieved inside `refresh`,
       * and are ultimately handed off to the subclass's `repaint` method. Subclasses should call this on things like handle
       * dragging, as the existence (and nature of ) args can subsequently be used by their `repaint` method to decide whether or not
       * to redraw all the handles (such as you would in the event of an external paint event), or just to reposition the existing
       * ones. During a drag, of course, blowing away the current handle would be bad.
       * @internal
       */

    }, {
      key: "repaintConnection",
      value: function repaintConnection(args) {
        if (this.current) {
          this.jsplumb._paintConnection(this.current, args);

          this.refresh(args);
        }
      }
      /**
       * Fires a connection edit event, passing the current connection, and the current
       * connection's exported geometry.
       * @internal
       */

    }, {
      key: "fireConnectionEditEvent",
      value: function fireConnectionEditEvent() {
        this.surface._connectionEdited(this.current);
      }
      /**
       * Redraw anchor placeholders and editor handles.
       * @param args Optional args to pass to the subclass repaint method.
       * @internal
       */

    }, {
      key: "refresh",
      value: function refresh(args) {
        if (this.current) {
          // reposition the anchor placeholders.
          this._drawAnchorPlaceholders(); // instruct the subclass to repaint (and pass it the args, if they are present)


          this._repaint && this._repaint(args);
        }
      }
      /**
       * Draws, or repositions if they exist already, the anchor placeholders for the current connection.
       * @internal
       */

    }, {
      key: "_drawAnchorPlaceholders",
      value: function _drawAnchorPlaceholders() {
        var _this5 = this;

        if (this.current) {
          var _one = function _one(idx, existingPlaceholder) {
            var ep = _this5.current.endpoints[idx];
            var a = ep._anchor;

            if (_this5.anchorPositionFinder != null || a.isDynamic || a.isContinuous) {
              var sa = extend({}, a.computedPosition);

              var d = _this5.jsplumb.getOffset(ep.element);

              var r = _this5.jsplumb._getRotation(ep.elementId);

              if (r !== 0) {
                var s = _this5.jsplumb.getSize(ep.element),
                    c = {
                  x: d.x + s.w / 2,
                  y: d.y + s.h / 2
                },
                    rax = rotatePoint({
                  x: sa.curX,
                  y: sa.curY
                }, c, -r);

                sa.curX = rax.x;
                sa.curY = rax.y;
              }

              var _ref = [sa.curX - d.x, sa.curY - d.y],
                  x = _ref[0],
                  y = _ref[1];

              var _p;

              if (existingPlaceholder != null) {
                _p = existingPlaceholder;
              } else {
                _p = _makeElement(x, y, CLASS_ANCHOR_PLACEHOLDER);
                ep.element.appendChild(_p);

                _this5._setElementPosition(_p, x, y);

                _p._jsPlumbAnchor = {
                  anchor: a,
                  endpoint: ep,
                  idx: idx
                };
              }

              var ps = _this5.jsplumb.getSize(_p);

              _p.style.left = x - ps.w / 2 + PX;
              _p.style.top = y - ps.h / 2 + PX;
              return [[d.x, d.y], _p];
            } else {
              return [[0, 0], null];
            }
          };

          var _one2 = _one(0, this.sourceAnchorPlaceholder);

          var _one3 = _slicedToArray(_one2, 2);

          this.sourceDimensions = _one3[0];
          this.sourceAnchorPlaceholder = _one3[1];

          var _one4 = _one(1, this.targetAnchorPlaceholder);

          var _one5 = _slicedToArray(_one4, 2);

          this.targetDimensions = _one5[0];
          this.targetAnchorPlaceholder = _one5[1];
        }
      }
      /**
       * Removes anchor placeholders.
       * @internal
       */

    }, {
      key: "_cleanupAnchors",
      value: function _cleanupAnchors() {
        if (this.current) {
          if (this.sourceAnchorPlaceholder) {
            this.sourceAnchorPlaceholder.parentNode.removeChild(this.sourceAnchorPlaceholder);
            delete this.sourceAnchorPlaceholder._jsPlumbAnchor;
          }

          if (this.targetAnchorPlaceholder) {
            this.targetAnchorPlaceholder.parentNode.removeChild(this.targetAnchorPlaceholder);
            delete this.targetAnchorPlaceholder._jsPlumbAnchor;
          }
        }

        this.sourceAnchorPlaceholder = null;
        this.targetAnchorPlaceholder = null;
        this.sourceDimensions = null;
        this.targetDimensions = null;
      }
      /**
       * @internal
       */

    }, {
      key: "_clearGeometry",
      value: function _clearGeometry() {
        if (this.current) {
          this.current.connector.resetGeometry();
        }
      }
      /**
       * @internal
       */

    }, {
      key: "reset",
      value: function reset() {
        this.deactivate();

        this._clearGeometry();

        this._clearHandles();

        this.jsplumb.revalidate(this.current.source);
        this.jsplumb.revalidate(this.current.target);
        this.jsplumb.fire(EVT_CLEAR_CONNECTION_EDITS, this.current);
      }
      /**
       * @internal
       */

    }, {
      key: "isActive",
      value: function isActive() {
        return this.active;
      }
      /**
       * @internal
       * @param el
       * @param x
       * @param y
       * @private
       */

    }, {
      key: "_setElementPosition",
      value: function _setElementPosition(el, x, y) {
        var s = this.jsplumb.getSize(el),
            _x = x - s.w / 2,
            _y = y - s.h / 2;

        el.style.left = _x + PX;
        el.style.top = _y + PX;
      }
      /**
       * Activate the editor, with the given Connection.
       * @param connection - Connection to activate the editor for.
       * @param params - optional params for the activation. The type of this depends on the subclass.
       * @internal
       */

    }, {
      key: "activate",
      value: function activate(edge, connection, params) {
        this.deactivate();
        this.current = connection;
        this.currentConnector = this.current.connector;
        this.currentEdge = edge;
        this.currentSourceVertex = this.currentEdge.source;
        this.currentTargetVertex = this.currentEdge.target;
        params = params || {};
        this.anchorPositionFinder = params.anchorPositionFinder; // tell the subclass to activate

        this._activate(connection, params);

        if (params.overlays) {
          this._attachOverlays(connection, params.overlays);
        }

        if (params.deleteButton === true) {
          this._attachDeleteButton(params);
        }

        var sourceEndpoint = this.current.endpoints[0];
        var sourceAnchor = sourceEndpoint._anchor;
        var targetEndpoint = this.current.endpoints[1];
        var targetAnchor = targetEndpoint._anchor;
        this.jsplumb.router.lock(sourceAnchor);
        this.jsplumb.router.lock(targetAnchor);

        this._drawAnchorPlaceholders();

        this.current.addClass(CLASS_CONNECTION_EDIT);
        this.active = true;
        this.jsplumb.fire(EVT_START_CONNECTION_EDIT, this.current);
      }
      /**
       * Deactivates the editor, removing all editor handles and anchor placeholders etc.
       * @param e
       */

    }, {
      key: "deactivate",
      value: function deactivate(e) {
        if (this.current != null) {
          this._detachOverlays();

          this.current.removeClass(CLASS_CONNECTION_EDIT);

          this._cleanupAnchors();
        }

        this._clearHandles();

        if (this.current != null) {
          this.jsplumb.fire(EVT_STOP_CONNECTION_EDIT, this.current);
        }

        this.active = false;
        this.current = null;
        this.currentEdge = null;
      } //
      // for subclasses to use. we keep a record of it so we can unsubscribe all handlers at once.

    }, {
      key: "_addDragHandler",
      value: function _addDragHandler(o, atStart) {
        this.jsplumb.dragManager.addSelector(o, atStart);
        this._dragHandlers[o.selector] = o;
      }
    }]);

    return EditorBase;
  }();

  var editors = new Map();

  function create(type, surface, p) {
    var c = editors.get(type);
    return new c(surface, p);
  }
  /**
   * Editor for edge paths. Currently support Bezier, StateMachine and Orthogonal connectors. Don't instantiate one of these
   * directly - use the `newInstance(surface:Surface)` from this module instead.
   */

  var EdgePathEditor = /*#__PURE__*/function () {
    function EdgePathEditor(surface, options) {
      var _this = this;

      _classCallCheck$7(this, EdgePathEditor);

      this.surface = surface;
      this.options = options;

      _defineProperty$7(this, "_connectorEditors", new Map());

      _defineProperty$7(this, "activeMode", void 0);

      surface.bind("destroy", function () {
        return _this.destroy();
      });
      this.options = this.options || {};
      this.activeMode = this.options.activeMode === true;
      /**
       * on new connection established in the UI, check if we are in 'active' mode. If so, we mark the edge edited, meaning its geometry
       * gets stored (the connector has to support this).
       */

      this.surface.jsplumb.bind(EVENT_INTERNAL_CONNECTION, function (params) {
        if (_this.activeMode) {
          var conn = params.connection;
          conn.connector.edited = true;
        }
      });
    }
    /**
     * Start editing the given edge or connection, optionally with the given edit parameters.
     * @param edgeOrConnection
     * @param params
     */


    _createClass$7(EdgePathEditor, [{
      key: "startEditing",
      value: function startEditing(edgeOrConnection, params) {
        var conn = this._resolveConnection(edgeOrConnection);

        if (conn != null) {
          var edge = conn.edge;
          params = extend({}, params || {});
          var connectorType = conn.connector.type;

          if (!editors.has(connectorType)) {
            throw new Error("No editor available for connector type [" + connectorType + "]");
          } else {
            // check local cache to see if we have one we re-use
            if (!this._connectorEditors.has(connectorType)) {
              var p = extend({}, this.options || {});
              var editor = create(connectorType, this.surface, p);

              this._connectorEditors.set(connectorType, editor);
            }

            this._connectorEditors.get(connectorType).activate(edge, conn, params);
          }
        }
      }
      /**
       * Stop editing any connector paths.
       */

    }, {
      key: "stopEditing",
      value: function stopEditing() {
        this._connectorEditors.forEach(function (ce) {
          return ce.deactivate();
        });
      }
      /**
       * Clear the edits for the given connection, returning its path to the automatically computed path.
       * @param edgeOrConnection
       */

    }, {
      key: "clearEdits",
      value: function clearEdits(edgeOrConnection) {
        var conn = this._resolveConnection(edgeOrConnection);

        if (conn != null) {
          var connector = conn.connector;
          connector.resetGeometry();
          return true;
        } else {
          return false;
        }
      }
      /**
       * Resolves a `Connection` from the given input, which can be an edge id, Edge, or Connection.
       * @param edgeOrConnection ID of an Edge, Edge, or Connection
       * @internal
       */

    }, {
      key: "_resolveConnection",
      value: function _resolveConnection(edgeOrConnection) {
        if (edgeOrConnection == null) {
          return null;
        } else if (typeof edgeOrConnection === "string") {
          return this.surface.getRenderedConnection(edgeOrConnection);
        } else if (edgeOrConnection instanceof Connection) {
          return edgeOrConnection;
        } else {
          return this.surface.getRenderedConnection(edgeOrConnection.getId());
        }
      }
      /**
       * Destroy the path editor - clears the internal map of editors and released held memory.
       */

    }, {
      key: "destroy",
      value: function destroy() {
        this._connectorEditors.clear();
      }
    }]);

    return EdgePathEditor;
  }();

  function _classCallCheck$6(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$6(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$6(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$6(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$6(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty$6(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  var DEFAULT_DRAG_ACTIVE_CLASS = "jtk-drag-drop-active";
  var DEFAULT_DRAG_HOVER_CLASS = "jtk-drag-drop-hover";
  var GROUP_TYPE = "Group";
  var WIDTH = "width";
  var HEIGHT = "height";
  var MOUSEMOVE = "mousemove";
  var MOUSEOUT = "mouseout";
  var TOUCHMOVE = "touchmove";
  var ATTR_IS_GROUP = "data-jtk-is-group";
  var STYLE_TRANSFORM = "transform";
  var LEFT = "left";
  var TOP = "top";
  var DropManager = /*#__PURE__*/function () {
    function DropManager(params) {
      var _this = this;

      _classCallCheck$6(this, DropManager);

      _defineProperty$6(this, "surface", void 0);

      _defineProperty$6(this, "surfaceCanvas", void 0);

      _defineProperty$6(this, "surfaceCanvasPlaceholder", void 0);

      _defineProperty$6(this, "source", void 0);

      _defineProperty$6(this, "selector", void 0);

      _defineProperty$6(this, "elements", void 0);

      _defineProperty$6(this, "dropFilter", void 0);

      _defineProperty$6(this, "canvasDropFilter", void 0);

      _defineProperty$6(this, "edgeDropFilter", void 0);

      _defineProperty$6(this, "scope", void 0);

      _defineProperty$6(this, "onEdgeDrop", void 0);

      _defineProperty$6(this, "onDrop", void 0);

      _defineProperty$6(this, "onCanvasDrop", void 0);

      _defineProperty$6(this, "dragActiveClass", void 0);

      _defineProperty$6(this, "dragHoverClass", void 0);

      _defineProperty$6(this, "dataGenerator", void 0);

      _defineProperty$6(this, "onDrag", void 0);

      _defineProperty$6(this, "canvasSelector", void 0);

      _defineProperty$6(this, "currentNodeList", void 0);

      _defineProperty$6(this, "currentEdgeList", void 0);

      _defineProperty$6(this, "candidateData", void 0);

      _defineProperty$6(this, "candidate", void 0);

      _defineProperty$6(this, "canvasMoveListener", void 0);

      _defineProperty$6(this, "canvasMouseOutListener", void 0);

      _defineProperty$6(this, "isCurrentlyOnCanvasElement", void 0);

      _defineProperty$6(this, "canDropOnCanvas", void 0);

      _defineProperty$6(this, "viewportPosition", null);

      _defineProperty$6(this, "enabled", void 0);

      _defineProperty$6(this, "_translateX", 0);

      _defineProperty$6(this, "_translateY", 0);

      _defineProperty$6(this, "ignoreGrid", void 0);

      _defineProperty$6(this, "grid", void 0);

      _defineProperty$6(this, "drag", void 0);

      _defineProperty$6(this, "dragManager", void 0);

      this.surface = params.surface;
      this.surfaceCanvas = this.surface.getContainer().parentNode;
      this.surfaceCanvasPlaceholder = this.surfaceCanvas.querySelector(".jtk-surface-canvas");
      this.grid = this.surface.getGrid();
      this.ignoreGrid = params.ignoreGrid === true;
      this.enabled = params.enabled !== false;
      this.canvasSelector = params.canvasSelector || null;
      this.source = params.source;
      this.selector = params.selector;
      this.scope = params.scope || uuid();

      this.dropFilter = params.dropFilter || function (data, target) {
        return true;
      };

      this.canvasDropFilter = params.canvasDropFilter || function (data) {
        return true;
      };

      this.edgeDropFilter = params.edgeDropFilter || function (data, target) {
        return true;
      };

      this.onDrag = params.onDrag;
      this.onDrop = params.onDrop;
      this.onEdgeDrop = params.onEdgeDrop;
      this.onCanvasDrop = params.onCanvasDrop;
      this.dragActiveClass = params.dragActiveClass || DEFAULT_DRAG_ACTIVE_CLASS;
      this.dragHoverClass = params.dragHoverClass || DEFAULT_DRAG_HOVER_CLASS;
      this.currentNodeList = [];

      this.dataGenerator = params.dataGenerator || function () {
        return {};
      };

      this.canvasMoveListener = function (e) {
        var eventSource = e.srcElement || e.target;
        _this.isCurrentlyOnCanvasElement = eventSource === _this.surfaceCanvas || eventSource === _this.surfaceCanvasPlaceholder || _this.canvasSelector != null && matchesSelector$1(eventSource, _this.canvasSelector);
      };

      this.canvasMouseOutListener = function (e) {
        _this.isCurrentlyOnCanvasElement = false;
      };

      this.dragManager = new Collicat();
      this.drag = this.dragManager.draggable(this.source, {
        scope: this.scope,
        clone: true,
        constrainFunction: function constrainFunction(desiredLoc, dragEl, constrainRect, size) {
          if (_this.ignoreGrid || _this.grid == null || !_this.surface.isInViewport(desiredLoc.x, desiredLoc.y)) {
            return desiredLoc;
          } else {
            // if a grid is in place we want the element to be constrained to it, unless the user has set ignoreGrid:true in the options
            // for this component.
            var pos = {
              x: desiredLoc.x - _this._translateX,
              y: desiredLoc.y - _this._translateY
            };

            var mappedLoc = _this.surface.fromPageLocation(pos.x, pos.y);

            var gridX = (mappedLoc.x < 0 ? Math.ceil(mappedLoc.x / _this.grid.w) : Math.floor(mappedLoc.x / _this.grid.w)) * _this.grid.w;
            var gridY = (mappedLoc.y < 0 ? Math.ceil(mappedLoc.y / _this.grid.h) : Math.floor(mappedLoc.y / _this.grid.h)) * _this.grid.h;

            var pageLoc = _this.surface.toPageLocation(gridX, gridY); // let mappedLocToGrid = this.mapSurfaceLocation(pos.x, pos.y),
            //     dx = mappedLocToGrid.x - mappedLoc.x,
            //     dy = mappedLocToGrid.y - mappedLoc.y
            //
            // const out = {
            //     x: desiredLoc.x + dx,
            //     y: desiredLoc.y + dy
            // }
            //
            // return out
            //return desiredLoc


            return {
              x: pageLoc.x + _this._translateX,
              y: pageLoc.y + _this._translateY
            };
          }
        },
        start: function start(p) {
          if (!_this.enabled) {
            return false;
          }

          var el = p.drag.getDragElement();
          el.style.pointerEvents = NONE$1; // suppress pointer events on the drag object itself. this helps us figure out
          // when its over a valid target. its a clone anyway and is thrown away the end of the drag so we're not leaving a lasting
          // impression on the UI by doing this.

          _this.candidateData = _this.dataGenerator(el);
          _this.currentNodeList.length = 0;
          _this.candidate = null;

          _this._adjustForTransformations();

          if (_this.onDrop) {
            var targets = _this.getAllNodesAndGroups();

            targets.forEach(function (e) {
              var renderedEl = _this.surface.getRenderedElement(e);

              if (renderedEl) {
                if (_this.dropFilter(_this.candidateData, e)) {
                  var viewportPosition = _this.surface._getViewportPosition(e);

                  var pageLoc = _this.surface.toPageLocation(viewportPosition.x, viewportPosition.y);

                  var w = viewportPosition.w * _this.surface.getZoom();

                  var h = viewportPosition.h * _this.surface.getZoom();

                  _this.currentNodeList.push({
                    vertex: e,
                    element: renderedEl,
                    apparentBounds: extend(pageLoc, {
                      w: w,
                      h: h
                    })
                  });

                  _this.surface.addClass(renderedEl, _this.dragActiveClass);
                } else {
                  _this.surface.removeClass(renderedEl, _this.dragActiveClass);
                }
              }
            });

            _this.currentNodeList.sort(function (a, b) {
              if (isGroup(a.vertex) && isGroup(b.vertex)) {
                var g = _this.surface.toolkitInstance.graph;

                if (g.isAncestor(a.vertex, b.vertex)) {
                  return -1;
                } else if (g.isAncestor(b.vertex, a.vertex)) {
                  return 1;
                }
              }

              return 0;
            });
          }

          _this.currentEdgeList = _this.onEdgeDrop ? _this.getAllConnectors(_this.candidateData) : [];

          if (_this.onCanvasDrop && _this.canvasDropFilter(_this.candidateData)) {
            _this.canDropOnCanvas = true;
            _this.isCurrentlyOnCanvasElement = false; // TODO this does not work for touch devices.  for those, it will be necessary to test if the
            // dragged element is over the canvas, after establishing that it is either not over an edge or node or
            // that drop on edge/node is not supported.

            _this.surface.on(_this.surfaceCanvas, MOUSEMOVE, _this.canvasMoveListener);

            _this.surface.on(_this.surfaceCanvas, MOUSEOUT, _this.canvasMouseOutListener);
          }
        },
        stop: function stop(p) {
          _this.surface.off(_this.surfaceCanvas, MOUSEMOVE, _this.canvasMoveListener);

          _this.surface.off(_this.surfaceCanvas, MOUSEOUT, _this.canvasMouseOutListener);

          _this._cleanupClasses();

          var canvasPosition = _this.surface.fromPageLocation(_this.viewportPosition.x, _this.viewportPosition.y);

          if (_this.candidate) {
            if (_this.candidate.edge && _this.onEdgeDrop) {
              _this.onEdgeDrop(_this.candidateData, _this.candidate.edge, p.el, p.e, p.pos, canvasPosition);
            } else if (_this.onDrop) {
              var _targetLocation;

              var _locationOnTarget;

              var obj = _this.surface.toolkitInstance.getNode(_this.candidate.id) || _this.surface.toolkitInstance.getGroup(_this.candidate.id); //(<any>this.candidate.el).jtk.group || (<any>this.candidate.el).jtk.node


              if (obj.objectType === GROUP_TYPE) {
                var uiGroup = _this.surface.jsplumb.getGroup(obj.id);

                _targetLocation = _this.surface.jsplumb.getOffset(_this.surface.jsplumb.getGroupContentArea(uiGroup));
              } else {
                _targetLocation = _this.surface.jsplumb.getOffset(_this.surface.getRenderedElement(_this.candidate.id));
              }

              _locationOnTarget = {
                x: canvasPosition.x - _targetLocation.x,
                y: canvasPosition.y - _targetLocation.y
              };

              _this.onDrop(_this.candidateData, obj, p.el, p.e, p.pos, canvasPosition, _targetLocation, _locationOnTarget);
            }
          } else if (_this.canDropOnCanvas && _this.isCurrentlyOnCanvasElement && _this.viewportPosition != null && _this.onCanvasDrop) {
            _this.onCanvasDrop(_this.candidateData, canvasPosition, p.el, p.e, p.pos);
          }

          _this.isCurrentlyOnCanvasElement = false;
        },
        drag: function drag(p) {
          _this._cleanupClasses(true);

          var pos = {
            x: p.pos.x - _this._translateX,
            y: p.pos.y - _this._translateY
          };
          _this.viewportPosition = pos;
          _this.candidate = null;

          var mappedLoc = _this.surface.fromPageLocation(pos.x, pos.y);

          if (_this.onDrop) {
            // previous way, we'd look for intersecting nodes on every drag
            // let intersectingNodes = this.surface.findIntersectingVertices(pos, p.drag._size, false)
            // this.candidate = intersectingNodes.filter((n: IntersectingVertex<Vertex>) => {
            //     return this.currentNodeList.findIndex((cn: CurrentNodeOrGroup) => {
            //         return cn.vertex.id === n.id
            //     }) > -1
            // })[0]
            // now we've figured out the locations at drag start (adjusted to page locations, for zoom and surface offset etc),
            // so its just a case of matching `pos` and `p.drag._size`, which are in page coordinates.
            var rect = extend(pos, p.drag._size);

            var c = _this.currentNodeList.filter(function (c) {
              return intersects(c.apparentBounds, rect);
            })[0];

            if (c != null) {
              _this.candidate = {
                r: c.apparentBounds,
                id: c.vertex.id,
                element: c.element
              };
            }
          }

          if (!_this.candidate && _this.onEdgeDrop) {
            var zoom = _this.surface.getZoom();

            var baseRect = {
              x: mappedLoc.x,
              y: mappedLoc.y,
              w: p.drag._size.w / zoom,
              h: p.drag._size.h / zoom
            };

            for (var i = 0; i < _this.currentEdgeList.length; i++) {
              var deets = _this.currentEdgeList[i],
                  cBounds = deets.r,
                  connector = deets.connector;

              if (intersects(baseRect, cBounds)) {
                // the drag object is over the canvas, but is it over the connector?
                var intersections = connector.boundingBoxIntersection({
                  x: baseRect.x - cBounds.x,
                  y: baseRect.y - cBounds.y,
                  w: baseRect.w,
                  h: baseRect.h
                });

                if (intersections.length > 0) {
                  _this.candidate = deets;
                  break;
                }
              }
            }
          }

          if (_this.candidate) {
            _this.surface.addClass(_this.candidate.element, _this.dragHoverClass);
          } else {
            if (_this.canDropOnCanvas) {
              _this.isCurrentlyOnCanvasElement = _this.isEffectivelyOnCanvas(p.e);

              if (_this.isCurrentlyOnCanvasElement && _this.surface.isInViewport(pos.x, pos.y)) {
                _this.viewportPosition = pos;

                _this.surface.addClass(_this.surfaceCanvas, _this.dragHoverClass);
              } else {
                _this.surface.addClass(_this.surface.getContainer(), _this.dragActiveClass);
              }
            }
          }

          _this.onDrag && _this.onDrag(_this.candidateData, p.e, pos, mappedLoc);
        },
        selector: this.selector,
        dragInit: function dragInit(el) {}
      });
    }
    /**
     * sets whether or not dragging is currently enabled.
     * @param e
     */


    _createClass$6(DropManager, [{
      key: "setEnabled",
      value: function setEnabled(e) {
        this.enabled = e;
      }
      /**
       * Sets the current surface. Not for public use.
       * @param surface
       * @internal
       */

    }, {
      key: "setSurface",
      value: function setSurface(surface) {
        this.surface = surface;
        this.surfaceCanvas = surface.getContainer();
      }
    }, {
      key: "isEffectivelyOnCanvas",
      value: function isEffectivelyOnCanvas(e) {
        var isOnCanvasElement = this.isCurrentlyOnCanvasElement;

        if (!isOnCanvasElement && e.type === TOUCHMOVE) {
          isOnCanvasElement = true;
        }

        return isOnCanvasElement;
      }
    }, {
      key: "getAllNodesAndGroups",
      value: function getAllNodesAndGroups() {
        var nodesAndGroups = [];
        Array.prototype.push.apply(nodesAndGroups, this.surface.toolkitInstance.getNodes());
        Array.prototype.push.apply(nodesAndGroups, this.surface.toolkitInstance.getGroups());
        return nodesAndGroups;
      }
    }, {
      key: "_adjustForTransformations",
      value: function _adjustForTransformations() {
        var dx = 0,
            dy = 0,
            _one = function _one(el) {
          if (el != null && el !== document.body) {
            var matrix = window.getComputedStyle(el)[STYLE_TRANSFORM].match(/(-?[0-9\.]+)/g);

            if (matrix) {
              dx += parseInt(matrix[4], 10);
              dy += parseInt(matrix[5], 10);
            }

            _one(el.parentNode);
          }
        };

        _one(this.surface.jsplumb.getContainer().parentElement);

        this._translateX = dx;
        this._translateY = dy;
      }
    }, {
      key: "getAllConnectors",
      value:
      /**
       * Find all the connectors in the canvas, computing their position in page coords (taking into account the viewport
       * position of the surface and its current zoom). We return [ connection, connector, bounding rect ] for each connector.
       * @internal
       */
      function getAllConnectors(data) {
        var _this2 = this;

        var edges = [];
        var jp = this.surface.jsplumb;
        jp.select().each(function (connection) {
          if (connection.edge && _this2.edgeDropFilter(data, connection.edge)) {
            var connector = connection.connector;
            var element = connector.canvas;
            var bounds = {
              x: parseInt(element.style.left, 10),
              y: parseInt(element.style.top, 10),
              w: parseInt(element.getAttribute(WIDTH), 10),
              h: parseInt(element.getAttribute(HEIGHT), 10)
            };
            edges.push({
              connection: connection,
              connector: connector,
              element: element,
              r: bounds,
              id: connection.edge.id,
              edge: connection.edge
            });

            _this2.surface.addClass(element, _this2.dragActiveClass);
          }
        });
        return edges;
      }
    }, {
      key: "_cleanupClasses",
      value: function _cleanupClasses(onlyHover) {
        var _this3 = this;

        this.currentNodeList.forEach(function (e) {
          if (!onlyHover) {
            _this3.surface.removeClass(e.element, _this3.dragActiveClass);
          }

          _this3.surface.removeClass(e.element, _this3.dragHoverClass);
        });
        this.currentEdgeList.forEach(function (e) {
          if (!onlyHover) {
            _this3.surface.removeClass(e.element, _this3.dragActiveClass);
          }

          _this3.surface.removeClass(e.element, _this3.dragHoverClass);
        });
        this.surface.removeClass(this.surfaceCanvas, this.dragActiveClass);
        this.surface.removeClass(this.surfaceCanvas, this.dragHoverClass);
      }
    }]);

    return DropManager;
  }();
  /**
   * Options for the SurfaceDropManager.
   */

  var SurfaceDropManager = /*#__PURE__*/function () {
    function SurfaceDropManager(options) {
      var _this4 = this;

      _classCallCheck$6(this, SurfaceDropManager);

      _defineProperty$6(this, "surface", void 0);

      _defineProperty$6(this, "dropManager", void 0);

      _defineProperty$6(this, "toolkit", void 0);

      _defineProperty$6(this, "typeGenerator", void 0);

      _defineProperty$6(this, "groupIdentifier", void 0);

      _defineProperty$6(this, "modelPositionAttributes", void 0);

      _defineProperty$6(this, "magnetize", void 0);

      _defineProperty$6(this, "ignoreGrid", void 0);

      _defineProperty$6(this, "grid", void 0);

      _defineProperty$6(this, "allowDropOnEdge", void 0);

      _defineProperty$6(this, "allowDropOnGroup", void 0);

      _defineProperty$6(this, "allowDropOnCanvas", void 0);

      _defineProperty$6(this, "allowDropOnNode", void 0);

      _defineProperty$6(this, "onVertexAdded", void 0);

      this.surface = options.surface;
      this.toolkit = this.surface.toolkitInstance;
      this.modelPositionAttributes = this.surface.getModelPositionAttributes();

      this.typeGenerator = options.typeGenerator || function (d) {
        return d.type;
      };

      this.groupIdentifier = options.groupIdentifier || function (d, el) {
        return el.getAttribute(ATTR_IS_GROUP) === TRUE$1;
      };

      this.allowDropOnEdge = options.allowDropOnEdge !== false;
      this.allowDropOnGroup = options.allowDropOnGroup !== false;
      this.allowDropOnNode = options.allowDropOnNode === true;
      this.allowDropOnCanvas = options.allowDropOnCanvas !== false;
      this.magnetize = options.magnetize !== false;
      this.grid = this.surface.getGrid();
      this.ignoreGrid = options.ignoreGrid === true;
      this.onVertexAdded = options.onVertexAdded;
      var dropManagerOptions = {
        surface: this.surface,
        ignoreGrid: this.ignoreGrid,
        onCanvasDrop: this.allowDropOnCanvas ? function (data, canvasPosition, draggedElement, e, position) {
          _this4.addNewVertexToCanvas(data, canvasPosition, draggedElement, e, position);
        } : null,
        onDrop: function onDrop(data, target, draggedElement, e, position, canvasPosition, targetLocation, locationOnTarget) {
          if (_this4.allowDropOnGroup && isGroup(target)) {
            var groupDragged = _this4.groupIdentifier(data, draggedElement);

            var type = _this4.typeGenerator(data);

            var objData = _this4._mapToPositionAttributes({
              group: target.id,
              left: locationOnTarget.x,
              top: locationOnTarget.y
            }, data);

            var callback = function callback(node) {
              _this4.surface.setPosition(node, locationOnTarget.x, locationOnTarget.y);

              _this4.surface._relayoutGroup(target);
            };

            if (groupDragged) {
              _this4.toolkit.addFactoryGroup(type, objData, callback);
            } else {
              _this4.toolkit.addFactoryNode(type, objData, callback);
            }
          } else if (_this4.allowDropOnNode && isNode(target)) {
            _this4.addNewVertexToCanvas(data, canvasPosition, draggedElement, e, position);
          }
        },
        onEdgeDrop: this.allowDropOnEdge ? function (data, edge, draggedElement, e, position, canvasLocation) {
          var type = _this4.typeGenerator(data);

          var objData = _this4._mapToPositionAttributes({
            x: canvasLocation.x,
            y: canvasLocation.y
          }, data);

          var groupDragged = _this4.groupIdentifier(data, draggedElement);

          var afterAdd = function afterAdd(newObj) {
            var currentSource = edge.source; // the current source node

            var currentTarget = edge.target; // the target node

            _this4.toolkit.removeEdge(edge); // TODO can/should the edge factory be invoked here?


            _this4.toolkit.addEdge({
              source: currentSource,
              target: newObj
            });

            _this4.toolkit.addEdge({
              source: newObj,
              target: currentTarget
            });

            if (_this4.magnetize !== false) {
              _this4.surface.setMagnetizedPosition(newObj, canvasLocation.x, canvasLocation.y, true);
            } else {
              _this4.surface.setPosition(newObj, canvasLocation.x, canvasLocation.y);
            }
          };

          if (groupDragged) {
            _this4.toolkit.addFactoryGroup(type, objData, afterAdd);
          } else {
            _this4.toolkit.addFactoryNode(type, objData, afterAdd);
          }
        } : null,
        source: options.source,
        selector: options.selector,
        dataGenerator: options.dataGenerator,
        canvasSelector: options.canvasSelector
      };
      this.dropManager = new DropManager(dropManagerOptions);
    }

    _createClass$6(SurfaceDropManager, [{
      key: "_mapToPositionAttributes",
      value: function _mapToPositionAttributes(d, data) {
        var out = {};

        for (var i in d) {
          if (i === LEFT) {
            out[this.modelPositionAttributes[0]] = d[i];
          } else if (i === TOP) {
            out[this.modelPositionAttributes[1]] = d[i];
          } else {
            out[i] = d[i];
          }
        }

        extend(out, data);
        return out;
      }
    }, {
      key: "addNewVertexToCanvas",
      value: function addNewVertexToCanvas(data, canvasPosition, draggedElement, e, position) {
        var _this5 = this;

        var type = this.typeGenerator(data);
        var groupDragged = this.groupIdentifier(data, draggedElement);

        var objData = this._mapToPositionAttributes({
          left: canvasPosition.x,
          top: canvasPosition.y
        }, data);

        if (groupDragged) {
          this.toolkit.addFactoryGroup(type, objData, function (group) {
            var x = group.data[_this5.toolkit.modelLeftAttribute] == null ? canvasPosition.x : group.data[_this5.toolkit.modelLeftAttribute];
            var y = group.data[_this5.toolkit.modelTopAttribute] == null ? canvasPosition.y : group.data[_this5.toolkit.modelTopAttribute];

            _this5.surface.setPosition(group, x, y);

            if (_this5.onVertexAdded) {
              _this5.onVertexAdded(_this5.toolkit.getGroup(group.id));
            }
          });
        } else {
          this.toolkit.addFactoryNode(type, objData, function (node) {
            var x = node.data[_this5.toolkit.modelLeftAttribute] == null ? canvasPosition.x : node.data[_this5.toolkit.modelLeftAttribute];
            var y = node.data[_this5.toolkit.modelTopAttribute] == null ? canvasPosition.y : node.data[_this5.toolkit.modelTopAttribute];

            _this5.surface.setPosition(node, x, y);

            if (_this5.onVertexAdded) {
              _this5.onVertexAdded(_this5.toolkit.getNode(node.id));
            }
          });
        }
      }
    }, {
      key: "setEnabled",
      value: function setEnabled(e) {
        this.dropManager.setEnabled(e);
      }
    }, {
      key: "setSurface",
      value: function setSurface(s) {
        this.surface = s;
        this.toolkit = this.surface.toolkitInstance;
        this.modelPositionAttributes = this.surface.getModelPositionAttributes();
        this.dropManager.setSurface(s);
      }
    }]);

    return SurfaceDropManager;
  }();

  function createSurfaceManager(options) {
    return new SurfaceDropManager(options);
  }

  function _classCallCheck$5(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$5(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$5(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$5(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$5(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty$5(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  var PIXELS_PER_INCH = 96.0;
  var PIXELS_PER_CENTIMETRE = PIXELS_PER_INCH / 2.54;
  var EmptyMargins = [0, 0, 0, 0];
  var Units = {
    INCHES: "INCHES",
    CENTIMETERS: "CENTIMETERS"
  };
  var PAGE_DIMENSIONS = {
    LETTER: [21.59, 27.94],
    A5: [14.8, 21],
    A4: [21.0, 29.7],
    A3: [29.7, 42.0],
    A2: [42.0, 59.4],
    A1: [59.4, 84.1],
    A0: [84.1, 118.9]
  };

  function convertToPixels(values, units) {
    var multiplier = units === Units.INCHES ? PIXELS_PER_INCH : PIXELS_PER_CENTIMETRE;
    return values.map(function (v) {
      return v * multiplier;
    });
  }

  function convertToUnits(values, units) {
    var divider = units === Units.INCHES ? PIXELS_PER_INCH : PIXELS_PER_CENTIMETRE;
    return values.map(function (v) {
      return v / divider;
    });
  }

  var CANVAS_ELEMENTS_SELECTOR = ".jtk-overlay,.jtk-node,.jtk-endpoint,.jtk-group,.jtk-connector";

  function findSurfaceBounds(surface) {
    var _this = this;

    surface.relayout(null);
    var xmin = [];
    var xmax = [];
    var ymin = [];
    var ymax = [];
    var els = surface.jsplumb.getContainer().querySelectorAll(CANVAS_ELEMENTS_SELECTOR);

    var _p = function _p(l, list) {
      if (!isNaN(l)) {
        list.push(l);
      }
    };

    els.forEach(function (el) {
      var b = _this.findElementBounds(el);

      _p(b.l, xmin);

      _p(b.t, ymin);

      _p(b.l1, xmax);

      _p(b.t1, ymax);
    });
    var x = Math.min.apply(null, xmin);
    var xm = Math.max.apply(null, xmax);
    var y = Math.min.apply(null, ymin);
    var ym = Math.max.apply(null, ymax);
    return {
      x: x,
      y: y,
      w: xm - x,
      h: ym - y,
      padding: null,
      vw: xm + (x < 0 ? -x : 0),
      vh: ym + (y < 0 ? -y : 0),
      z: null,
      zoom: null
    };
  }
  // Print handler for a given Surface. Instantiate one of these in your code and provide an id to look it up by later. if you
  // dont provide an id, one will be assigned. But remember you need the id to invoke operations on the handler from the global
  // context, ie. when printing via dev tools.
  //


  var PrintHandler = /*#__PURE__*/function () {
    function PrintHandler(surface, id) {
      _classCallCheck$5(this, PrintHandler);

      this.surface = surface;

      _defineProperty$5(this, "id", void 0);

      this.id = id || uuid();
    }

    _createClass$5(PrintHandler, [{
      key: "scaleToBounds",
      value: function scaleToBounds(wh) {
        var margins = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EmptyMargins;
        var surfaceBounds = findSurfaceBounds(this.surface);
        var width = wh[0] - margins[3] - margins[1];
        var height = wh[1] - margins[0] - margins[2];
        var z = Math.min(width / surfaceBounds.w, height / surfaceBounds.h); // get current clamp value and set to false

        var isClamping = this.surface.isClamping();
        this.surface.setClamping(false); // adjust zoom

        this.surface.setZoom(z); // adjust pan

        this.surface.setPan(-surfaceBounds.x * z, -surfaceBounds.y * z); // reset clamping to original value.

        this.surface.setClamping(isClamping);
        return z;
      }
    }, {
      key: "scaleToPageDimensions",
      value: function scaleToPageDimensions(dimensions) {
        var margins = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EmptyMargins;
        var units = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "CENTIMETERS";
        return this.scaleToBounds(convertToPixels(dimensions, units), convertToPixels(margins, units));
      }
    }, {
      key: "scaleToPageSize",
      value: function scaleToPageSize(size) {
        var margins = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EmptyMargins;
        var units = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "CENTIMETERS";

        if (size === "FULL") {
          return this.scaleToFullPage(margins, units);
        }

        var dimensions = PAGE_DIMENSIONS[size];

        if (dimensions) {
          // note here we use CENTIMETERS for converting the page dimensions, as that is how we specify them. but we use the user's
          // preference for units for converting the margin.
          var pageBounds = convertToPixels(dimensions, Units.CENTIMETERS);
          convertToPixels(margins, units); //const zoom = this.scaleToBounds(pageBounds, marginsInPixels);

          return convertToUnits(pageBounds, units);
        } else {
          throw new Error("Unknown page size " + size);
        }
      }
    }, {
      key: "scaleToFullPage",
      value: function scaleToFullPage() {
        var margins = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : EmptyMargins;
        var units = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "CENTIMETERS";
        var surfaceBounds = findSurfaceBounds(this.surface); // we use the content bounds - pixels - as the page size.

        var pageBounds = [surfaceBounds.w + 5, surfaceBounds.h + 5];
        var marginsInPixels = convertToPixels(margins, units);
        var pageDimensions = convertToUnits([pageBounds[0] + marginsInPixels[1] + marginsInPixels[3], pageBounds[1] + marginsInPixels[0] + marginsInPixels[2]], units);
        var isClamping = this.surface.isClamping();
        this.surface.setClamping(false); // adjust zoom

        this.surface.setZoom(1); // adjust pan

        this.surface.setPan(-surfaceBounds.x, -surfaceBounds.y); // reset clamping to original value.

        this.surface.setClamping(isClamping);
        return pageDimensions;
      }
    }, {
      key: "isReadyToPrint",
      value: function isReadyToPrint() {
        var els = this.surface.jsplumb.getContainer().querySelectorAll("img");

        for (var i = 0; i < els.length; i++) {
          if (!els[i].complete) {
            return false;
          }
        }

        return true;
      }
    }]);

    return PrintHandler;
  }();

  var printHandlers = {};
  /**
   * Register a print handler for the given surface, optionally with the given id. An id will be generated if not
   * provided.
   * @param surface
   * @param id
   */

  function registerHandler(surface, id) {
    var handler = new PrintHandler(surface, id);
    printHandlers[handler.id] = handler;
    return handler;
  }

  function _classCallCheck$4(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$4(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$4(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$4(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$4(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty$4(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  var DEFAULT_MINIMUM_WIDTH = 30;
  var DEFAULT_MINIMUM_HEIGHT = 30;
  var DIV = "div";
  var DASH = "-";
  var TOP_LEFT = "tl";
  var TOP_RIGHT = "tr";
  var BOTTOM_LEFT = "bl";
  var BOTTOM_RIGHT = "br";
  var CLASS_DRAW_SKELETON = "jtk-draw-skeleton";
  var CLASS_DRAW_HANDLE = "jtk-draw-handle";
  var CLASS_DRAW_DRAG = "jtk-draw-drag";
  var CLASS_DRAW_HANDLE_TL = [CLASS_DRAW_HANDLE, TOP_LEFT].join(DASH);
  var CLASS_DRAW_HANDLE_BL = [CLASS_DRAW_HANDLE, BOTTOM_LEFT].join(DASH);
  var CLASS_DRAW_HANDLE_TR = [CLASS_DRAW_HANDLE, TOP_RIGHT].join(DASH);
  var CLASS_DRAW_HANDLE_BR = [CLASS_DRAW_HANDLE, BOTTOM_RIGHT].join(DASH);
  var ATT_JTK_X_RESIZE = "jtk-x-resize";
  var ATT_JTK_Y_RESIZE = "jtk-y-resize";
  var ATT_DATA_DIR = "data-dir";
  var ATT_DATA_NODE_ID = "data-node-id";
  var DrawingToolsPlugin = /*#__PURE__*/function () {
    function DrawingToolsPlugin() {
      var _this = this;

      _classCallCheck$4(this, DrawingToolsPlugin);

      _defineProperty$4(this, "surface", void 0);

      _defineProperty$4(this, "toolkit", void 0);

      _defineProperty$4(this, "jsp", void 0);

      _defineProperty$4(this, "widthAtt", void 0);

      _defineProperty$4(this, "heightAtt", void 0);

      _defineProperty$4(this, "leftAtt", void 0);

      _defineProperty$4(this, "topAtt", void 0);

      _defineProperty$4(this, "xAxis", void 0);

      _defineProperty$4(this, "yAxis", void 0);

      _defineProperty$4(this, "onEdit", void 0);

      _defineProperty$4(this, "onDemand", void 0);

      _defineProperty$4(this, "skeletons", void 0);

      _defineProperty$4(this, "downAt", void 0);

      _defineProperty$4(this, "handler", void 0);

      _defineProperty$4(this, "toolkitDragObject", void 0);

      _defineProperty$4(this, "x1", void 0);

      _defineProperty$4(this, "x2", void 0);

      _defineProperty$4(this, "y1", void 0);

      _defineProperty$4(this, "y2", void 0);

      _defineProperty$4(this, "minimumHeight", void 0);

      _defineProperty$4(this, "minimumWidth", void 0);

      _defineProperty$4(this, "ignoreGrid", void 0);

      _defineProperty$4(this, "grid", void 0);

      _defineProperty$4(this, "_moving", false);

      _defineProperty$4(this, "_dragHandlers", {
        "tl": function tl(dx, dy) {
          var x = _this.x1 + dx,
              y = _this.y1 + dy,
              w = _this.x2 - x,
              h = _this.y2 - y;

          if (x > _this.x2 - _this._minWidth()) {
            x = _this.x2 - _this._minWidth();
            w = _this._minWidth();
          }

          if (y > _this.y2 - _this._minHeight()) {
            y = _this.y2 - _this._minHeight();
            h = _this._minHeight();
          }

          return _this._dim(x, y, w, h);
        },
        "tr": function tr(dx, dy) {
          var w = _this.x2 - _this.x1 + dx,
              y = _this.y1 + dy,
              h = _this.y2 - y,
              x = _this.x1;

          if (w < _this._minWidth()) {
            w = _this._minWidth();
          }

          if (y > _this.y2 - _this._minHeight()) {
            y = _this.y2 - _this._minHeight();
            h = _this._minHeight();
          }

          return _this._dim(x, y, w, h);
        },
        "bl": function bl(dx, dy) {
          var x = _this.x1 + dx,
              h = _this.y2 - _this.y1 + dy,
              w = _this.x2 - x,
              y = _this.y1;

          if (x > _this.x2 - _this._minWidth()) {
            x = _this.x2 - _this._minWidth();
            w = _this._minWidth();
          }

          if (h < _this._minHeight()) {
            h = _this._minHeight();
          }

          return _this._dim(x, y, w, h);
        },
        "br": function br(dx, dy) {
          var w = _this.x2 - _this.x1 + dx,
              h = _this.y2 - _this.y1 + dy,
              x = _this.x1,
              y = _this.y1;

          if (w < _this._minWidth()) {
            w = _this._minWidth();
          }

          if (h < _this._minHeight()) {
            h = _this._minHeight();
          }

          return _this._dim(x, y, w, h);
        }
      });
    }

    _createClass$4(DrawingToolsPlugin, [{
      key: "destroy",
      value: function destroy() {}
    }, {
      key: "initialise",
      value: function initialise(surface, options) {
        var _this2 = this;

        this.surface = surface;
        this.toolkit = surface.toolkitInstance;
        this.jsp = surface.jsplumb;
        this.skeletons = {};
        this.widthAtt = options.widthAttribute || "w";
        this.heightAtt = options.heightAttribute || "h";
        this.leftAtt = options.leftAttribute || "left";
        this.topAtt = options.topAttribute || "top";

        this.onEdit = options.onEdit || function () {};

        this.onDemand = options.onDemand === true;
        this.minimumWidth = options.minimumWidth != null && options.minimumWidth > 0 ? options.minimumWidth : DEFAULT_MINIMUM_WIDTH;
        this.minimumHeight = options.minimumHeight != null && options.minimumHeight > 0 ? options.minimumHeight : DEFAULT_MINIMUM_HEIGHT;
        this.grid = this.surface.getGrid();
        this.ignoreGrid = options.ignoreGrid === true;
        this.toolkit.bind(EVENT_SELECTION_CLEARED, function () {
          _this2.reset();
        }); // - on select, add drawing primitives

        this.toolkit.bind(EVENT_SELECT, function (params) {
          if (_this2.onDemand !== true) {
            _this2._select(params.obj);
          }
        }); // - on deselect, remove drawing primitives.

        this.toolkit.bind(EVENT_DESELECT, function (params) {
          if (_this2.onDemand !== true) {
            _this2._deselect(params.obj);
          }
        });

        var moveListener = function moveListener(e) {
          if (!_this2._moving) {
            _this2.toolkit.openTransaction();
          }

          _this2._moving = true;
          consume(e);

          var p = _this2.surface.mapEventLocation(e),
              editingDx = p.x - _this2.downAt.x,
              editingDy = p.y - _this2.downAt.y;

          if (_this2.grid && !_this2.ignoreGrid) {
            editingDx = (editingDx < 0 ? Math.ceil(editingDx / _this2.grid.w) : Math.floor(editingDx / _this2.grid.w)) * _this2.grid.w;
            editingDy = (editingDy < 0 ? Math.ceil(editingDy / _this2.grid.h) : Math.floor(editingDy / _this2.grid.h)) * _this2.grid.h;
          }

          var newCoords = _this2.handler(editingDx, editingDy, "");

          _this2.toolkit.update(_this2.toolkitDragObject, newCoords);

          _this2.surface.setPosition(_this2.toolkitDragObject, newCoords[_this2.leftAtt], newCoords[_this2.topAtt]);
        };

        var upListener = function upListener(e) {
          _this2._moving = false;

          _this2.surface.storePositionInModel(_this2.toolkitDragObject.id);

          _this2.jsp.removeClass(document.body, CLASS_DRAG_SELECT_DEFEAT);

          _this2.jsp.off(document, EVENT_MOUSEMOVE, moveListener);

          _this2.jsp.off(document, EVENT_MOUSEUP, upListener);

          consume(e);

          _this2.onEdit(_this2.toolkitDragObject);

          _this2.toolkit.commitTransaction();
        }; // - delegate bind to drag handles


        this.jsp.on(this.jsp.getContainer(), EVENT_MOUSEDOWN, cls(CLASS_DRAW_HANDLE), function (e) {
          consume(e);
          var dir = e.target.getAttribute(ATT_DATA_DIR),
              nodeId = e.target.getAttribute(ATT_DATA_NODE_ID);
          _this2.toolkitDragObject = _this2.toolkit.getNode(nodeId) || _this2.toolkit.getGroup(nodeId);
          _this2.xAxis = _this2.skeletons[nodeId][1];
          _this2.yAxis = _this2.skeletons[nodeId][2];
          _this2.downAt = _this2.surface.mapEventLocation(e); // get the location and size of the element

          var c = _this2.getCoordinates(_this2.toolkitDragObject);

          _this2.x1 = c.x;
          _this2.y1 = c.y;
          _this2.x2 = _this2.x1 + c.w;
          _this2.y2 = _this2.y1 + c.h;
          _this2.handler = _this2._dragHandlers[dir];

          _this2.jsp.addClass(document.body, CLASS_DRAG_SELECT_DEFEAT);

          _this2.jsp.on(document, EVENT_MOUSEMOVE, moveListener);

          _this2.jsp.on(document, EVENT_MOUSEUP, upListener);
        });
        return false;
      }
      /**
       * Gets the origin and size of an element that is being managed by the Surface.
       * @param el Vertex id, element, or Vertex to get position for.
       * @returns A RectangleXY if element was found, otherwise null.
       */

    }, {
      key: "getCoordinates",
      value: function getCoordinates(el) {
        if (this.surface._layout) {
          var info = this.surface.getObjectInfo(el);

          if (info.obj) {
            var s = this.surface.jsplumb.getSize(info.el);
            var layout = isNodeInsideAGroup(info.obj) || isNestedGroup(info.obj) ? this.surface._layoutMap.get(info.obj.group.id) : this.surface._layout;
            var p = layout.getPosition(info.id);
            return {
              x: p.x,
              y: p.y,
              w: s.w,
              h: s.h
            };
          } else {
            return {
              x: 0,
              y: 0,
              w: 0,
              h: 0
            };
          }
        }
      }
    }, {
      key: "reset",
      value: function reset() {
        for (var id in this.skeletons) {
          var s = this.skeletons[id];

          if (s[0] && s[0].parentNode) {
            s[0].parentNode.removeChild(s[0]);
          }

          delete this.skeletons[id];
        }
      }
    }, {
      key: "_minWidth",
      value: function _minWidth() {
        return this.grid != null && !this.ignoreGrid ? this.grid.w : this.minimumWidth;
      }
    }, {
      key: "_minHeight",
      value: function _minHeight() {
        return this.grid != null && !this.ignoreGrid ? this.grid.h : this.minimumHeight;
      }
    }, {
      key: "_create",
      value: function _create(t, classes, p, a) {
        var s = document.createElement(t);
        var c = classes.join(" ");
        s.className = c;

        if (p) {
          p.appendChild(s);
        }

        if (a) {
          for (var i in a) {
            s.setAttribute(i, a[i]);
          }
        }

        return s;
      }
    }, {
      key: "_remove",
      value: function _remove(id) {
        var s = this.skeletons[id];

        if (s && s[0] && s[0].parentNode) {
          s[0].parentNode.removeChild(s[0]);
        }

        delete this.skeletons[id];
      }
    }, {
      key: "_deselect",
      value: function _deselect(obj) {
        var el = this.surface.getRenderedVertex(obj.id);

        this._remove(obj.id);

        return el;
      }
    }, {
      key: "_select",
      value: function _select(obj) {
        var el = this._deselect(obj);

        if (el != null) {
          var s = this._create(DIV, [CLASS_DRAW_SKELETON], el),
              x = el.getAttribute(ATT_JTK_X_RESIZE),
              y = el.getAttribute(ATT_JTK_Y_RESIZE);

          this._create(DIV, [CLASS_DRAW_DRAG], s);

          this._create(DIV, [CLASS_DRAW_HANDLE, CLASS_DRAW_HANDLE_TL], s, {
            "data-dir": "tl",
            "data-node-id": obj.id
          });

          this._create(DIV, [CLASS_DRAW_HANDLE, CLASS_DRAW_HANDLE_TR], s, {
            "data-dir": "tr",
            "data-node-id": obj.id
          });

          this._create(DIV, [CLASS_DRAW_HANDLE, CLASS_DRAW_HANDLE_BL], s, {
            "data-dir": "bl",
            "data-node-id": obj.id
          });

          this._create(DIV, [CLASS_DRAW_HANDLE, CLASS_DRAW_HANDLE_BR], s, {
            "data-dir": "br",
            "data-node-id": obj.id
          });

          this.skeletons[obj.id] = [s, x !== FALSE$1, y !== FALSE$1];
        }
      }
    }, {
      key: "_dim",
      value: function _dim(x, y, w, h) {
        var out = {};
        out[this.widthAtt] = this.xAxis ? w : this.x2 - this.x1;
        out[this.heightAtt] = this.yAxis ? h : this.y2 - this.y1;
        out[this.leftAtt] = this.xAxis ? x : this.x1;
        out[this.topAtt] = this.yAxis ? y : this.y1;

        if (out[this.widthAtt] < 0) {
          out[this.widthAtt] = this._minWidth();
        }

        if (out[this.heightAtt] < 0) {
          out[this.heightAtt] = this._minHeight();
        }

        return out;
      }
    }, {
      key: "edit",
      value: function edit(obj) {
        this._select(obj);
      }
    }]);

    return DrawingToolsPlugin;
  }();

  _defineProperty$4(DrawingToolsPlugin, "type", "drawingTools");

  SurfacePlugins.register(DrawingToolsPlugin.type, DrawingToolsPlugin);

  function _classCallCheck$3(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$3(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$3(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$3(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$3(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty$3(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _inherits$2(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf$2(subClass, superClass);
  }

  function _getPrototypeOf$2(o) {
    _getPrototypeOf$2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$2(o);
  }

  function _setPrototypeOf$2(o, p) {
    _setPrototypeOf$2 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$2(o, p);
  }

  function _isNativeReflectConstruct$2() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _assertThisInitialized$2(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn$2(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }

    return _assertThisInitialized$2(self);
  }

  function _createSuper$2(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$2();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf$2(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$2(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn$2(this, result);
    };
  }

  var ATTRIBUTE_JTK_MINIVIEW_TYPE = "jtk-miniview-type";
  /**
   * Miniview plugin for Surface. In previous versions of jsplumb this was embedded in the Surface.
   */

  var MiniviewPlugin = /*#__PURE__*/function (_OptimisticEventGener) {
    _inherits$2(MiniviewPlugin, _OptimisticEventGener);

    var _super = _createSuper$2(MiniviewPlugin);

    function MiniviewPlugin() {
      var _this;

      _classCallCheck$3(this, MiniviewPlugin);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));

      _defineProperty$3(_assertThisInitialized$2(_this), "surface", void 0);

      _defineProperty$3(_assertThisInitialized$2(_this), "panzoom", void 0);

      _defineProperty$3(_assertThisInitialized$2(_this), "containerElement", void 0);

      _defineProperty$3(_assertThisInitialized$2(_this), "canvasElement", void 0);

      _defineProperty$3(_assertThisInitialized$2(_this), "pannerElement", void 0);

      _defineProperty$3(_assertThisInitialized$2(_this), "surfaceBounds", void 0);

      _defineProperty$3(_assertThisInitialized$2(_this), "suspended", void 0);

      _defineProperty$3(_assertThisInitialized$2(_this), "_collapsible", void 0);

      _defineProperty$3(_assertThisInitialized$2(_this), "typeFunction", void 0);

      _defineProperty$3(_assertThisInitialized$2(_this), "_collapser", void 0);

      _defineProperty$3(_assertThisInitialized$2(_this), "_collapsed", void 0);

      _defineProperty$3(_assertThisInitialized$2(_this), "wheelSensitivity", void 0);

      _defineProperty$3(_assertThisInitialized$2(_this), "wheelReverse", void 0);

      _defineProperty$3(_assertThisInitialized$2(_this), "panning", false);

      _defineProperty$3(_assertThisInitialized$2(_this), "downAt", null);

      _defineProperty$3(_assertThisInitialized$2(_this), "pannerAtMouseDown", null);

      _defineProperty$3(_assertThisInitialized$2(_this), "zoomingWithWheel", false);

      _defineProperty$3(_assertThisInitialized$2(_this), "elementFilter", void 0);

      _defineProperty$3(_assertThisInitialized$2(_this), "visible", true);

      _defineProperty$3(_assertThisInitialized$2(_this), "pannerPos", void 0);

      _defineProperty$3(_assertThisInitialized$2(_this), "vertexMap", {});

      _defineProperty$3(_assertThisInitialized$2(_this), "enableWheelZoom", void 0);

      _defineProperty$3(_assertThisInitialized$2(_this), "eventManager", void 0);

      _defineProperty$3(_assertThisInitialized$2(_this), "_zoomToFit", void 0);

      _defineProperty$3(_assertThisInitialized$2(_this), "surfaceBindings", []);

      _defineProperty$3(_assertThisInitialized$2(_this), "_doToggleCollapse", void 0);

      _defineProperty$3(_assertThisInitialized$2(_this), "viewport", void 0);

      _defineProperty$3(_assertThisInitialized$2(_this), "_doWheelZoom", void 0);

      _defineProperty$3(_assertThisInitialized$2(_this), "_downListener", void 0);

      _defineProperty$3(_assertThisInitialized$2(_this), "_moveListener", void 0);

      _defineProperty$3(_assertThisInitialized$2(_this), "_upListener", void 0);

      return _this;
    }

    _createClass$3(MiniviewPlugin, [{
      key: "destroy",
      value: function destroy() {
        var _this2 = this;

        this.panzoom.destroy();
        this.eventManager.off(this.pannerElement, EVENT_MOUSEDOWN, this._downListener);
        this.canvasElement.parentNode.removeChild(this.canvasElement);
        this.pannerElement.parentNode.removeChild(this.pannerElement);
        this.surface.removeClass(this.containerElement, CLASS_MINIVIEW);
        this.surface.removeClass(this.containerElement, CLASS_MINIVIEW_COLLAPSED);

        if (this._collapsible) {
          this.eventManager.off(this._collapser, EVENT_CLICK, this._doToggleCollapse);

          this._collapser.parentNode.removeChild(this._collapser);
        }

        this.surfaceBindings.forEach(function (sb) {
          return _this2.surface.unbind(sb[0], sb[1]);
        });
        this.surface.toolkitInstance.unbind(EVENT_DATA_LOAD_END, this._zoomToFit);

        if (this._doWheelZoom) {
          removeWheelListener(this.containerElement, this._doWheelZoom);
        }
      }
    }, {
      key: "bindToSurface",
      value: function bindToSurface(evtName, handler) {
        var f = handler.bind(this);
        this.surfaceBindings.push([evtName, f]);
        this.surface.bind(evtName, f);
      }
    }, {
      key: "initialise",
      value: function initialise(surface, options) {
        var _this3 = this;

        this.surface = surface;
        this.wheelReverse = this.wheelReverse || this.surface.wheelReverse === true;
        this._downListener = this.downListener.bind(this);
        this._moveListener = this.moveListener.bind(this);
        this._upListener = this.upListener.bind(this);
        this.containerElement = options.container;
        this.canvasElement = this.surface._createElement({
          position: Constants.relative,
          width: Constants.nominalSize,
          height: Constants.nominalSize,
          left: 0,
          top: 0,
          clazz: CLASS_MINIVIEW_CANVAS
        }, this.containerElement);
        this.pannerElement = this.surface._createElement({
          position: Constants.absolute,
          width: Constants.nominalSize,
          height: Constants.nominalSize,
          left: 0,
          top: 0,
          clazz: CLASS_MINIVIEW_PANNER
        }, this.containerElement);
        this.surfaceBounds = options.bounds;
        this.suspended = options.suspended === true;
        this._collapsible = options.collapsible !== false;
        this.typeFunction = options.typeFunction;
        this._collapser = null;
        this._collapsed = false;
        this.enableWheelZoom = options.enableWheelZoom !== false;
        this.wheelSensitivity = options.wheelSensitivity || 10;

        this.elementFilter = options.elementFilter || function (v) {
          return true;
        };

        this.visible = options.visible !== false;
        this.eventManager = new EventManager();
        addClass(this.containerElement, CLASS_MINIVIEW);
        this._doToggleCollapse = this._toggleCollapsed.bind(this);

        if (this._collapsible) {
          this._collapser = this.surface._createElement({
            type: "div"
          });
          this._collapser.className = CLASS_MINIVIEW_COLLAPSE;
          this.containerElement.appendChild(this._collapser);
          this.surface.on(this._collapser, Constants.click, this._doToggleCollapse);
        }

        this.viewport = this.surface.viewport;
        this.panzoom = new PanZoom(this.surface, {
          viewport: this.viewport,
          viewportElement: this.containerElement,
          canvasElement: this.canvasElement,
          wheel: {
            zoom: false
          },
          enablePan: false,
          enableAnimation: false,
          idFunction: function idFunction(el) {
            return el.getAttribute("id");
          },
          events: {
            pan: function pan() {
              _this3._updateSurface();
            },
            mousedown: function mousedown() {
              addClass(_this3.pannerElement, CLASS_MINIVIEW_PANNING);
            },
            mouseup: function mouseup() {
              removeClass(_this3.pannerElement, CLASS_MINIVIEW_PANNING);
            }
          },
          zoomRange: [-Infinity, Infinity]
        });
        this.eventManager.on(window, EVENT_RESIZE, debounce(function () {
          _this3._updatePanner();
        }, 100)); // bind mousewheel

        if (this.enableWheelZoom !== false) {
          this._doWheelZoom = this.wheelZoom.bind(this);
          addWheelListener(this.containerElement, this._doWheelZoom);
        } // panzoom offers a helper method to do this for us.


        this.pannerElement.style.transformOrigin = "0 0"; // add jtk-miniview class to container

        this.surface.addClass(this.containerElement, CLASS_MINIVIEW); // configure pannerElement

        this.eventManager.on(this.pannerElement, EVENT_MOUSEDOWN, this._downListener);

        this._zoomToFit = function () {
          return _this3.zoomToFit();
        };

        this.surface.toolkitInstance.bind(EVENT_DATA_LOAD_END, this._zoomToFit);
        this.setVisible(this.visible); // subscribe to the Zoom, Pan and nodeDragEnd events from the Surface.

        this.bindToSurface(EVENT_PAN, this._updatePanner);
        this.bindToSurface(EVENT_ZOOM, this._updatePanner);
        this.bindToSurface(EVENT_NODE_MOVE_END, this._vertexMoved);
        this.bindToSurface(EVENT_NODE_REMOVED, this._nodeRemoved);
        this.bindToSurface(EVENT_NODE_ADDED, this._nodeAdded);
        this.bindToSurface(EVENT_NODE_RENDERED, this._nodeAdded);
        this.bindToSurface(EVENT_GROUP_RELAYOUT, this._groupRelayout);
        this.bindToSurface(EVENT_RELAYOUT, this._afterRelayout);
        this.bindToSurface(EVENT_GROUP_ADDED$1, this._onGroupAdded);
        this.bindToSurface(EVENT_GROUP_MOVE_END, this._vertexMoved);
        this.bindToSurface(EVENT_GROUP_REMOVED$1, this._groupRemoved);
        this.bindToSurface(EVENT_GROUP_MEMBER_ADDED$1, this._onGroupMemberAdded);
        this.bindToSurface(EVENT_GROUP_MEMBER_REMOVED$1, this._onGroupMemberRemoved);
        this.bindToSurface(EVENT_GROUP_COLLAPSE, this._onGroupCollapse);
        this.bindToSurface(EVENT_GROUP_EXPAND, this._onGroupExpand);
        this.bindToSurface(EVENT_GROUP_RESIZE, this._onGroupResize);
        this.bindToSurface(EVENT_ROTATE, this._objectRotated);

        var refreshOrRelayout = function refreshOrRelayout(params) {
          _this3.surfaceBounds = params.bounds;
          params.positions.forEach(function (value, key) {
            var miniviewElement = _this3.vertexMap[key];

            if (miniviewElement) {
              setAbsolutePosition(miniviewElement, value.x, value.y);
            }
          });

          _this3.zoomToFit(true);
        };

        this.bindToSurface(EVENT_RELAYOUT, refreshOrRelayout);
        this.bindToSurface(EVENT_AFTER_LAYOUT_REFRESH, refreshOrRelayout);
        this.bindToSurface(EVENT_OBJECT_REPAINTED, this._objectRepainted);
        this.bindToSurface(EVENT_STATE_RESTORED, this._updatePanner);
        this.bindToSurface(EVENT_NODE_VISIBILITY, this._nodeVisibility);
        return true;
      }
    }, {
      key: "reset",
      value: function reset() {
        this._removeAllNodes();
      }
    }, {
      key: "_onGroupAdded",
      value: function _onGroupAdded(p) {
        this._nodeAdded(p, CLASS_MINIVIEW_GROUP_ELEMENT);
      }
    }, {
      key: "_onGroupCollapse",
      value: function _onGroupCollapse(p) {
        this._showGroupMembers(p.group, false);

        this._objectRepainted({
          id: p.group.id
        });
      }
    }, {
      key: "_onGroupExpand",
      value: function _onGroupExpand(p) {
        this._showGroupMembers(p.group, true);

        this._objectRepainted({
          id: p.group.id
        });
      }
    }, {
      key: "_onGroupMemberRemoved",
      value: function _onGroupMemberRemoved(p) {
        var vertexEl = this.vertexMap[p.vertex.id];

        if (vertexEl) {
          this.canvasElement.appendChild(vertexEl);

          if (p.pos) {
            setAbsolutePosition(vertexEl, p.pos.x, p.pos.y);
          }
        }
      }
    }, {
      key: "_onGroupResize",
      value: function _onGroupResize(p) {
        this._objectRepainted({
          id: p.group.id
        });
      }
    }, {
      key: "_onGroupMemberAdded",
      value: function _onGroupMemberAdded(p) {
        var groupEl = this.vertexMap[p.group.id],
            vertexEl = this.vertexMap[p.vertex.id];

        if (groupEl && vertexEl) {
          groupEl.appendChild(vertexEl);

          if (p.pos) {
            setAbsolutePosition(vertexEl, p.pos.x, p.pos.y);
          }
        }
      }
    }, {
      key: "_objectRotated",
      value: function _objectRotated(payload) {
        var el = this.vertexMap[payload.obj.id];

        if (el != null) {
          el.style.transform = "rotate(" + payload.rotation + "deg)";
          el.style.transformOrigin = "50% 50%";
        }
      }
    }, {
      key: "downListener",
      value: function downListener(e) {
        this.panning = true;
        this.downAt = pageLocation(e);
        this.pannerAtMouseDown = getAbsolutePosition(this.pannerElement);
        this.eventManager.on(document, EVENT_MOUSEUP, this._upListener);
        this.eventManager.on(document, EVENT_MOUSEMOVE, this._moveListener);
        consume(e);
      }
    }, {
      key: "moveListener",
      value: function moveListener(e) {
        this.zoomingWithWheel = false;

        if (this.panning) {
          var loc = pageLocation(e),
              dx = loc.x - this.downAt.x,
              dy = loc.y - this.downAt.y,
              newPannerPos = {
            x: this.pannerAtMouseDown.x + dx,
            y: this.pannerAtMouseDown.y + dy
          };

          this._updateSurface(newPannerPos);

          setAbsolutePosition(this.pannerElement, newPannerPos.x, newPannerPos.y);
        }
      }
    }, {
      key: "upListener",
      value: function upListener(e) {
        this.panning = false;
        this.downAt = null;
        this.eventManager.off(document, EVENT_MOUSEUP, this._upListener);
        this.eventManager.off(document, EVENT_MOUSEMOVE, this._moveListener);
      }
    }, {
      key: "wheelZoom",
      value: function wheelZoom(e) {
        consume(e);
        this.surface.nudgeWheelZoom(e.normalizedWheelDelta * this.wheelSensitivity * (this.wheelReverse ? -1 : 1), e);
      }
    }, {
      key: "_toggleCollapsed",
      value: function _toggleCollapsed(e) {
        this._collapsed = !this._collapsed;
        this.surface[this._collapsed ? "addClass" : "removeClass"](this.containerElement, CLASS_MINIVIEW_COLLAPSED);
        this.zoomToFit(true);
      }
    }, {
      key: "zoomToFit",
      value: function zoomToFit(doNotFirePanEvent) {
        this.panzoom.zoomToFit({
          onComplete: this._updatePanner,
          doNotFirePanEvent: doNotFirePanEvent
        });
      }
    }, {
      key: "_vertexMoved",
      value: function _vertexMoved(params) {
        var obj = params.vertex;
        if (obj && this.elementFilter(obj) === false) return;
        var miniviewElement = this.vertexMap[obj.id] || params.el;
        setAbsolutePosition(miniviewElement, params.pos.x, params.pos.y);
        this.zoomToFit(true);
      }
    }, {
      key: "_groupRelayout",
      value: function _groupRelayout(params) {
        var _this4 = this;

        var nodes = params.group.getMembers(),
            p,
            groupEl = this.vertexMap[params.group.id];
        nodes.forEach(function (node, i) {
          p = params.layout.getPosition(node.id);
          var miniviewElement = _this4.vertexMap[node.id];

          if (p != null && miniviewElement != null) {
            setAbsolutePosition(miniviewElement, p.x, p.y);
          }
        });
        var s = this.surface.jsplumb.getSize(params.el);
        groupEl.style.width = s.w + Constants.px;
        groupEl.style.height = s.h + Constants.px;

        this._updatePanner();
      }
    }, {
      key: "_afterRelayout",
      value: function _afterRelayout(params) {
        var _this5 = this;

        this.surfaceBounds = params.bounds;
        params.positions.forEach(function (pos, id) {
          var miniviewElement = _this5.vertexMap[id];

          if (miniviewElement) {
            setAbsolutePosition(miniviewElement, pos.x, pos.y);
          }
        });
        this.zoomToFit(true);
      }
    }, {
      key: "_migrateGroupMembers",
      value: function _migrateGroupMembers(group, groupEl) {
        var n = group.getMembers();

        for (var i = 0; i < n.length; i++) {
          var nodeEl = this.vertexMap[n[i].id];

          if (nodeEl) {
            groupEl.appendChild(nodeEl);
          }
        }
      }
    }, {
      key: "_nodeAdded",
      value: function _nodeAdded(params, extraClasses) {
        if (this.elementFilter(params.vertex) === false) {
          return;
        }

        var obj = params.vertex;
        var objId = obj.id;

        if (this.vertexMap[objId] != null) {
          return; // if already rendered, return.
        }

        var pos = params.pos || {
          x: 0,
          y: 0
        };

        var s = this.surface.jsplumb.getSize(params.el),
            n = this.surface._createElement({
          position: Constants.absolute,
          width: s.w + Constants.px,
          height: s.h + Constants.px,
          left: pos.x,
          top: pos.y,
          clazz: CLASS_MINIVIEW_ELEMENT + (extraClasses ? " " + extraClasses : "")
        });

        if (this.typeFunction) {
          n.setAttribute(ATTRIBUTE_MINIVIEW_TYPE, this.typeFunction(params.vertex));
        }

        n.relatedElement = params.el;
        this.surfaceBounds = this.surface.getBoundsInfo();
        n.setAttribute(ATTRIBUTE_JTK_NODE_ID, objId);
        this.canvasElement.appendChild(n);
        this.panzoom.add(n);
        this.vertexMap[objId] = n;

        if (obj.data.rotation != null) {
          n.style.transform = "rotate(" + obj.data.rotation + "deg)";
          n.style.transformOrigin = "50% 50%";
        }

        if (params.vertex.type === Group.objectType) {
          this._migrateGroupMembers(params.vertex, n);
        } else if (params.vertex.group) {
          var groupEl = this.vertexMap[params.vertex.group.id];

          if (groupEl) {
            groupEl.appendChild(n);
            this.panzoom.suspend(params.el);
          }
        }

        this._updatePanner();
      }
    }, {
      key: "registerNode",
      value: function registerNode(params) {
        this._nodeAdded(params, params.group ? CLASS_MINIVIEW_GROUP_ELEMENT : "");

        this._vertexMoved(params);
      }
      /**
       * Sets whether or not the miniview is visible. Strictly speaking you don't need to use this method
       * you can just control the miniview's container via your own CSS or whatever. But the Surface uses this
       * occasionally, and there is also the concept of having the miniview initially invisible until the
       * related surface contains some data.
       */

    }, {
      key: "setVisible",
      value: function setVisible(v) {
        this.visible = v;
        this.containerElement.style.display = v ? Constants.block : Constants.none;
      }
    }, {
      key: "getPan",
      value: function getPan() {
        return this.panzoom.getPan();
      }
    }, {
      key: "_showGroupMembers",
      value: function _showGroupMembers(group, state) {
        var n = group.getMembers();

        for (var i = 0; i < n.length; i++) {
          this.vertexMap[n[i].id].style.display = state ? "block" : "none";
        }
      }
    }, {
      key: "_objectRepainted",
      value: function _objectRepainted(info) {
        var n = this.vertexMap[info.id];

        if (n) {
          var s = this.surface.jsplumb.getSize(n.relatedElement);
          n.style.width = s.w + Constants.px;
          n.style.height = s.h + Constants.px;

          this._updatePanner();

          if (this.typeFunction) {
            var _v = info.obj || this.surface.toolkitInstance.getVertex(info.id);

            if (_v) {
              n.setAttribute(ATTRIBUTE_JTK_MINIVIEW_TYPE, this.typeFunction(_v));
            }
          }
        }
      }
    }, {
      key: "invalidate",
      value: function invalidate(id) {
        if (id) {
          this._objectRepainted({
            id: id
          });
        } else {
          for (var i in this.vertexMap) {
            this._objectRepainted({
              id: i
            });
          }
        }
      }
    }, {
      key: "setSuspended",
      value: function setSuspended(s, updateAfterwards) {
        this.suspended = s;
        updateAfterwards && this._updatePanner();
      }
    }, {
      key: "_vertexRemoved",
      value: function _vertexRemoved(params) {
        var id = params.vertex.id,
            el = this.vertexMap[id];

        if (el) {
          this.panzoom.remove(el);
          delete this.vertexMap[id];
          el.parentNode.removeChild(el);
          this.zoomToFit(true);
        } // what else?
        // if (!params.dontUpdatePanner) {
        //     this._updatePanner()
        // }

      }
    }, {
      key: "_groupRemoved",
      value: function _groupRemoved(params) {
        var id = params.vertex.id,
            el = this.vertexMap[id];

        if (el) {
          // a group removal.
          var n, ne, pos;

          if (params.childrenRemoved !== true) {
            for (var i = 0; i < params.children.length; i++) {
              n = params.children[i];
              ne = this.vertexMap[n.id];

              if (ne) {
                pos = params.childPositions[n.id];

                if (pos) {
                  setAbsolutePosition(ne, pos.x, pos.y);
                }

                this.canvasElement.appendChild(ne);
              }
            }
          }
        }

        this._vertexRemoved(params);
      }
    }, {
      key: "_nodeRemoved",
      value: function _nodeRemoved(params) {
        this._vertexRemoved(params);
      }
    }, {
      key: "_removeAllNodes",
      value: function _removeAllNodes() {
        var el;

        for (var id in this.vertexMap) {
          el = this.vertexMap[id];
          this.panzoom.remove(el);
          delete this.vertexMap[id];
          el.parentNode.removeChild(el);
        }

        this._updatePanner();
      }
    }, {
      key: "_nodeVisibility",
      value: function _nodeVisibility(params) {
        var id = (params.node || params.group).id,
            el = this.vertexMap[id];

        if (el) {
          el.style.display = params.state ? "block" : "none";
        }
      }
    }, {
      key: "_updatePanner",
      value: function _updatePanner() {
        if (this.surface && this.panzoom && !this.suspended) {
          this.surfaceBounds = this.surface.getBoundsInfo();
          var scl = this.surface.getApparentCanvasLocation(),
              ocl = this.panzoom.getApparentCanvasLocation(),
              pz = this.panzoom.getZoom(),
              pannerZoom = pz / this.surfaceBounds.zoom; // size panner to the size of the viewport. we will subsequently scale it.

          this.pannerElement.style.width = this.surfaceBounds.vw + Constants.px;
          this.pannerElement.style.height = this.surfaceBounds.vh + Constants.px; // scale it

          this.pannerElement.style.transform = "scale(" + pannerZoom + ")"; // move it

          var originMappedToPanner = {
            x: scl.x * pannerZoom,
            y: scl.y * pannerZoom
          };
          this.pannerPos = {
            x: ocl.x - originMappedToPanner.x,
            y: ocl.y - originMappedToPanner.y
          }; // then show the pannerElement in the appropriate location

          setAbsolutePosition(this.pannerElement, this.pannerPos.x, this.pannerPos.y);
        }
      }
    }, {
      key: "_updateSurface",
      value: function _updateSurface(pannerPos) {
        if (this.panzoom != null) {
          this.surfaceBounds = this.surface.getBoundsInfo();
          pannerPos = pannerPos || getAbsolutePosition(this.pannerElement);
          var ocl = this.panzoom.getApparentCanvasLocation(),
              pz = this.panzoom.getZoom(),
              pannerZoom = pz / this.surfaceBounds.zoom,
              sx = (ocl.x - pannerPos.x) / pannerZoom,
              sy = (ocl.y - pannerPos.y) / pannerZoom;
          var clamped = this.surface.setApparentCanvasLocation(sx, sy);
          return {
            x: ocl.x - clamped.x * pannerZoom,
            y: ocl.y - clamped.y * pannerZoom
          };
        }
      }
    }, {
      key: "getRenderedVertex",
      value: function getRenderedVertex(vertexId) {
        return this.vertexMap[vertexId];
      } // getPosition(nodeId:string):PointXY {
      //     return this.surface.getPosition(nodeId)
      // }

    }]);

    return MiniviewPlugin;
  }(OptimisticEventGenerator);

  _defineProperty$3(MiniviewPlugin, "type", "miniview");

  SurfacePlugins.register(MiniviewPlugin.type, MiniviewPlugin);

  function _classCallCheck$2(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$2(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$2(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$2(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$2(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty$2(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _inherits$1(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf$1(subClass, superClass);
  }

  function _getPrototypeOf$1(o) {
    _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$1(o);
  }

  function _setPrototypeOf$1(o, p) {
    _setPrototypeOf$1 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$1(o, p);
  }

  function _isNativeReflectConstruct$1() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _assertThisInitialized$1(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn$1(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }

    return _assertThisInitialized$1(self);
  }

  function _createSuper$1(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf$1(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$1(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn$1(this, result);
    };
  }

  /**
   * @internal
   */

  var VERTICAL$1 = "v";
  /**
   * @internal
   */

  var HORIZONTAL = "h";
  /**
   * @internal
   */

  var NEGATIVE = -1;
  var X = "x";
  var Y = "y";
  var H = "h";
  var W = "w";
  /**
   * @internal
   */

  function transformFromAbsolute(segments) {
    var sx = segments[0].ax1,
        sy = segments[0].ay1,
        tx = segments[segments.length - 1].ax2,
        ty = segments[segments.length - 1].ay2,
        dx = tx >= sx ? sx : tx,
        dy = ty >= sy ? sy : ty;
    segments.forEach(function (segment) {
      segment.x1 = segment.ax1 - dx;
      segment.y1 = segment.ay1 - dy;
      segment.x2 = segment.ax2 - dx;
      segment.y2 = segment.ay2 - dy;

      if (segment.o == null || segment.o.length === 0) {
        segment.o = segment.ax1 === segment.ax2 ? VERTICAL$1 : HORIZONTAL;
      }
    });
    return segments;
  }

  function findSegment(segments, dir, axis, segment) {
    var candidate = null,
        start;

    if (segment != null) {
      start = segments.indexOf(segment); // if segment not found, return null

      if (start === -1) {
        return null;
      } else {
        // otherwise shift one in the appropriate direction to find the first segment to test
        start += dir;
      }
    } else {
      start = dir === NEGATIVE ? segments.length - 2 : 1;
    }

    for (var i = start; i > 0 && i < segments.length - 1; i += dir) {
      if (segments[i].o === axis) {
        candidate = [segments[i], i];
        break;
      }
    }

    return candidate;
  }
  /**
   * @internal
   */


  function orthogonalSegmentLength(s) {
    return Math.sqrt(Math.pow(s.ax2 - s.ax1, 2) + Math.pow(s.ay2 - s.ay1, 2));
  } // function sgn (n:number):number {
  //     return n < 0 ? -1 : n === 0 ? 0 : 1
  // }

  function segmentDirections(segment) {
    return [sgn(segment.x2 - segment.x1), sgn(segment.y2 - segment.y1)];
  }

  function commonStubCalculator(paintInfo, alwaysRespectStubs) {
    return [paintInfo.startStubX, paintInfo.startStubY, paintInfo.endStubX, paintInfo.endStubY];
  }

  var ORIENTATION_PERPENDICULAR = "perpendicular";
  var ORIENTATION_ORTHOGONAL = "orthogonal";
  var ORIENTATION_OPPOSITE = "opposite"; //
  // DO NOT refactor to provide the values in the map's constructor. IE11 will choke.
  //

  var stubCalculators = new Map();
  stubCalculators.set(ORIENTATION_PERPENDICULAR, commonStubCalculator);
  stubCalculators.set(ORIENTATION_ORTHOGONAL, commonStubCalculator);
  stubCalculators.set(ORIENTATION_OPPOSITE, function (paintInfo, alwaysRespectStubs) {
    var _areInProximity;

    var pi = paintInfo,
        idx = pi.sourceAxis === X ? 0 : 1,
        areInProximity = (_areInProximity = {}, _defineProperty$2(_areInProximity, X, function () {
      return pi.so[idx] === 1 && (pi.startStubX > pi.endStubX && pi.tx > pi.startStubX || pi.sx > pi.endStubX && pi.tx > pi.sx) || pi.so[idx] === -1 && (pi.startStubX < pi.endStubX && pi.tx < pi.startStubX || pi.sx < pi.endStubX && pi.tx < pi.sx);
    }), _defineProperty$2(_areInProximity, Y, function () {
      return pi.so[idx] === 1 && (pi.startStubY > pi.endStubY && pi.ty > pi.startStubY || pi.sy > pi.endStubY && pi.ty > pi.sy) || pi.so[idx] === -1 && (pi.startStubY < pi.endStubY && pi.ty < pi.startStubY || pi.sy < pi.endStubY && pi.ty < pi.sy);
    }), _areInProximity);

    if (!alwaysRespectStubs && areInProximity[pi.sourceAxis]()) {
      var _X$Y$pi$sourceAxis;

      return (_X$Y$pi$sourceAxis = {}, _defineProperty$2(_X$Y$pi$sourceAxis, X, [(paintInfo.sx + paintInfo.tx) / 2, paintInfo.startStubY, (paintInfo.sx + paintInfo.tx) / 2, paintInfo.endStubY]), _defineProperty$2(_X$Y$pi$sourceAxis, Y, [paintInfo.startStubX, (paintInfo.sy + paintInfo.ty) / 2, paintInfo.endStubX, (paintInfo.sy + paintInfo.ty) / 2]), _X$Y$pi$sourceAxis)[pi.sourceAxis];
    } else {
      return [paintInfo.startStubX, paintInfo.startStubY, paintInfo.endStubX, paintInfo.endStubY];
    }
  });
  var orientations = {
    x: [0, 1],
    y: [1, 0]
  };
  var lineCalculators = new Map();
  lineCalculators.set(ORIENTATION_PERPENDICULAR, function (connector, pi, params, axis, startStub, otherStartStub, endStub, otherEndStub, midx, midy, idx) {
    var sis = {
      x: [[[1, 2, 3, 4], null, [2, 1, 4, 3]], null, [[4, 3, 2, 1], null, [3, 4, 1, 2]]],
      y: [[[3, 2, 1, 4], null, [2, 3, 4, 1]], null, [[4, 1, 2, 3], null, [1, 4, 3, 2]]]
    },
        stubs = {
      x: [[pi.startStubX, pi.endStubX], null, [pi.endStubX, pi.startStubX]],
      y: [[pi.startStubY, pi.endStubY], null, [pi.endStubY, pi.startStubY]]
    },
        midLines = {
      x: [[midx, pi.startStubY], [midx, pi.endStubY]],
      y: [[pi.startStubX, midy], [pi.endStubX, midy]]
    },
        linesToEnd = {
      x: [[pi.endStubX, pi.startStubY]],
      y: [[pi.startStubX, pi.endStubY]]
    },
        startToEnd = {
      x: [[pi.startStubX, pi.endStubY], [pi.endStubX, pi.endStubY]],
      y: [[pi.endStubX, pi.startStubY], [pi.endStubX, pi.endStubY]]
    },
        startToMidToEnd = {
      x: [[pi.startStubX, midy], [pi.endStubX, midy], [pi.endStubX, pi.endStubY]],
      y: [[midx, pi.startStubY], [midx, pi.endStubY], [pi.endStubX, pi.endStubY]]
    },
        otherStubs = {
      x: [pi.startStubY, pi.endStubY],
      y: [pi.startStubX, pi.endStubX]
    },
        soIdx = orientations[axis][0],
        toIdx = orientations[axis][1],
        _so = pi.so[soIdx] + 1,
        _to = pi.to[toIdx] + 1,
        otherFlipped = pi.to[toIdx] === -1 && otherStubs[axis][1] < otherStubs[axis][0] || pi.to[toIdx] === 1 && otherStubs[axis][1] > otherStubs[axis][0],
        stub1 = stubs[axis][_so][0],
        stub2 = stubs[axis][_so][1],
        segmentIndexes = sis[axis][_so][_to];

    if (pi.segment === segmentIndexes[3] || pi.segment === segmentIndexes[2] && otherFlipped) {
      return midLines[axis];
    } else if (pi.segment === segmentIndexes[2] && stub2 < stub1) {
      return linesToEnd[axis];
    } else if (pi.segment === segmentIndexes[2] && stub2 >= stub1 || pi.segment === segmentIndexes[1] && !otherFlipped) {
      return startToMidToEnd[axis];
    } else if (pi.segment === segmentIndexes[0] || pi.segment === segmentIndexes[1] && otherFlipped) {
      return startToEnd[axis];
    }
  });
  lineCalculators.set(ORIENTATION_ORTHOGONAL, function (connector, pi, params, axis, startStub, otherStartStub, endStub, otherEndStub, midx, midy, idx) {
    var _X$Y$axis, _X$Y$axis2;

    var extent = (_X$Y$axis = {}, _defineProperty$2(_X$Y$axis, X, pi.so[0] === -1 ? Math.min(startStub, endStub) : Math.max(startStub, endStub)), _defineProperty$2(_X$Y$axis, Y, pi.so[1] === -1 ? Math.min(startStub, endStub) : Math.max(startStub, endStub)), _X$Y$axis)[axis];
    return (_X$Y$axis2 = {}, _defineProperty$2(_X$Y$axis2, X, [[extent, otherStartStub], [extent, otherEndStub], [endStub, otherEndStub]]), _defineProperty$2(_X$Y$axis2, Y, [[otherStartStub, extent], [otherEndStub, extent], [otherEndStub, endStub]]), _X$Y$axis2)[axis];
  });
  lineCalculators.set(ORIENTATION_OPPOSITE, function (connector, pi, params, axis, startStub, otherStartStub, endStub, otherEndStub, midx, midy, idx) {
    var _X$Y$axis3;

    var otherAxis = (_X$Y$axis3 = {}, _defineProperty$2(_X$Y$axis3, X, Y), _defineProperty$2(_X$Y$axis3, Y, X), _X$Y$axis3)[axis],
        //dim = {[X]: HEIGHT, [Y]: WIDTH}[axis],
    comparator = pi["is" + axis.toUpperCase() + "GreaterThanStubTimes2"];

    if (params.sourceEndpoint.elementId === params.targetEndpoint.elementId) {
      var _X$Y$axis4, _X$Y$axis5;

      //let _val = otherStartStub + ((1 - params.sourceEndpoint._anchor[otherAxis]) * params.sourceInfo[dim]) + connector.maxStub
      var dim = (_X$Y$axis4 = {}, _defineProperty$2(_X$Y$axis4, X, H), _defineProperty$2(_X$Y$axis4, Y, W), _X$Y$axis4)[axis];

      var _val = otherStartStub + (1 - params.sourceEndpoint._anchor.computedPosition[otherAxis]) * params.sourceInfo[dim] + connector.maxStub;

      return (_X$Y$axis5 = {}, _defineProperty$2(_X$Y$axis5, X, [[startStub, _val], [endStub, _val]]), _defineProperty$2(_X$Y$axis5, Y, [[_val, startStub], [_val, endStub]]), _X$Y$axis5)[axis];
    } else if (!comparator || pi.so[idx] === 1 && startStub > endStub || pi.so[idx] === -1 && startStub < endStub) {
      var _X$Y$axis6;

      return (_X$Y$axis6 = {}, _defineProperty$2(_X$Y$axis6, X, [[startStub, midy], [endStub, midy]]), _defineProperty$2(_X$Y$axis6, Y, [[midx, startStub], [midx, endStub]]), _X$Y$axis6)[axis];
    } else if (pi.so[idx] === 1 && startStub < endStub || pi.so[idx] === -1 && startStub > endStub) {
      var _X$Y$axis7;

      return (_X$Y$axis7 = {}, _defineProperty$2(_X$Y$axis7, X, [[midx, pi.sy], [midx, pi.ty]]), _defineProperty$2(_X$Y$axis7, Y, [[pi.sx, midy], [pi.tx, midy]]), _X$Y$axis7)[axis];
    }
  });

  function _cloneSegment(a) {
    return extend({}, a);
  }

  function positionEquals(p1, p2) {
    return p1.curX === p2.curX && p1.curY === p2.curY;
  }

  function addSegment(connector, x, y, paintInfo, dx, dy) {
    if (connector.lastx === x && connector.lasty === y) {
      return;
    }

    var lx = connector.lastx == null ? paintInfo.sx : connector.lastx,
        ly = connector.lasty == null ? paintInfo.sy : connector.lasty,
        o = lx === x ? VERTICAL$1 : HORIZONTAL;
    connector.lastx = x;
    connector.lasty = y; // we store the x,y relative to the canvas origin as well as the absolute location

    var s = {
      x1: lx,
      y1: ly,
      x2: x,
      y2: y,
      o: o,
      ax1: lx + dx,
      ay1: ly + dy,
      ax2: x + dx,
      ay2: y + dy
    };
    connector.orthogonalSegments.push(s);
  }
  /**
   * Options for an orthogonal connector.
   */


  /**
   * An orthogonal connector. In the Community edition this connector was/is known as the Flowchart connector. The Orthogonal connector
   * behaves like the Flowchart connector but is editable, ie. it is possible to supply the segments for the connector's path, and also
   * to edit the path interactively with the mouse via the `OrthogonalConnectorEditor`.
   */
  var OrthogonalConnector = /*#__PURE__*/function (_AbstractConnector) {
    _inherits$1(OrthogonalConnector, _AbstractConnector);

    var _super = _createSuper$1(OrthogonalConnector);

    function OrthogonalConnector(connection, params) {
      var _this;

      _classCallCheck$2(this, OrthogonalConnector);

      _this = _super.call(this, connection, params);
      _this.connection = connection;

      _defineProperty$2(_assertThisInitialized$1(_this), "type", void 0);

      _defineProperty$2(_assertThisInitialized$1(_this), "midpoint", void 0);

      _defineProperty$2(_assertThisInitialized$1(_this), "alwaysRespectStubs", void 0);

      _defineProperty$2(_assertThisInitialized$1(_this), "lastx", void 0);

      _defineProperty$2(_assertThisInitialized$1(_this), "lasty", void 0);

      _defineProperty$2(_assertThisInitialized$1(_this), "lastOrientation", void 0);

      _defineProperty$2(_assertThisInitialized$1(_this), "cornerRadius", void 0);

      _defineProperty$2(_assertThisInitialized$1(_this), "loopbackRadius", void 0);

      _defineProperty$2(_assertThisInitialized$1(_this), "isLoopbackCurrently", void 0);

      _defineProperty$2(_assertThisInitialized$1(_this), "geometry", void 0);

      _defineProperty$2(_assertThisInitialized$1(_this), "slightlyWonky", false);

      _defineProperty$2(_assertThisInitialized$1(_this), "orthogonalSegments", []);

      params = params || {};
      params.stub = params.stub == null ? 30 : params.stub;
      _this.type = "Orthogonal";
      _this.midpoint = params.midpoint == null ? 0.5 : params.midpoint;
      _this.alwaysRespectStubs = params.alwaysRespectStubs === true;
      _this.lastx = null;
      _this.lasty = null;
      _this.lastOrientation = null;
      _this.cornerRadius = params.cornerRadius != null ? params.cornerRadius : 0;
      _this.slightlyWonky = params.slightlyWonky === true;
      _this.loopbackRadius = params.loopbackRadius || 25;
      _this.isLoopbackCurrently = false;
      return _this;
    }

    _createClass$2(OrthogonalConnector, [{
      key: "getDefaultStubs",
      value: function getDefaultStubs() {
        return [30, 30];
      }
    }, {
      key: "setAndTransformGeometry",
      value: function setAndTransformGeometry(g) {
        g.segments = transformFromAbsolute(g.segments);
        this.setGeometry(g, false);
      }
    }, {
      key: "setAndTransformSegments",
      value: function setAndTransformSegments(s) {
        if (this.geometry != null) {
          this.geometry.segments = transformFromAbsolute(s);
        }
      }
      /**
       * This connector exports the source/target points as `source` and `target` respectively, as well as an array labelled
       * `segments`, which is the list of corner points.  There are, therefore, n+1 segments in a geometry
       * whose segments array contains n entries.
       * @public
       */

    }, {
      key: "exportGeometry",
      value: function exportGeometry() {
        if (this.geometry == null) {
          return null;
        } else {
          this.geometry.segments.length;
          var segs = this.geometry.segments.slice(1).map(function (seg) {
            return {
              x: seg.ax1,
              y: seg.ay1
            };
          });
          return {
            segments: segs,
            source: this.geometry.source,
            target: this.geometry.target
          };
        }
      }
    }, {
      key: "transformSegments",
      value: function transformSegments(segments, dx, dy) {
        return segments.map(function (s) {
          return {
            x1: s.x1 + dx,
            y1: s.y1 + dy,
            x2: s.x2 + dx,
            y2: s.y2 + dy,
            o: s.o,
            ax1: s.ax1 + dx,
            ay1: s.ay1 + dy,
            ax2: s.ax2 + dx,
            ay2: s.ay2 + dy
          };
        });
      }
    }, {
      key: "transformGeometry",
      value: function transformGeometry(g, dx, dy) {
        return {
          source: this.transformAnchorPlacement(g.source, dx, dy),
          target: this.transformAnchorPlacement(g.target, dx, dy),
          segments: g.segments.map(function (s) {
            return {
              x: s.x + dx,
              y: s.y + dy
            };
          })
        };
      }
      /**
       * Sets the location for the anchor
       * @param loc
       * @param connection
       * @param endpointIndex
       * @internal
       */

    }, {
      key: "_setAnchorLocation",
      value: function _setAnchorLocation(loc, connection, endpointIndex) {
        var a = connection.endpoints[endpointIndex]._anchor;

        if (isContinuous(a)) {
          var face = TOP$2;

          if (loc.x === 0) {
            face = LEFT$2;
          } else if (loc.x === 1) {
            face = RIGHT$1;
          } else if (loc.y === 1) {
            face = BOTTOM$1;
          }

          a.currentFace = face;
        } else if (a.isDynamic) {
          // ?
          connection.instance.router.selectAnchorLocation(a, {
            x: loc.x,
            y: loc.y
          });
        } else {
          a.locations[0].x = loc.x;
          a.locations[0].y = loc.y;
          a.locations[0].ox = loc.ox;
          a.locations[0].oy = loc.oy;
          a.locations[0].iox = loc.ox;
          a.locations[0].ioy = loc.oy;
        }

        this.connection.instance.router.lock(a);
      }
    }, {
      key: "importGeometry",
      value: function importGeometry(geometry) {
        if (geometry != null && geometry.segments != null && geometry.source != null && geometry.target != null) {
          var segments = geometry.segments;

          if (segments != null && segments.length >= 2) {
            var s = [],
                cx = geometry.source.curX,
                cy = geometry.source.curY;

            for (var i = 0; i < segments.length; i++) {
              // if not in X or Y axis, abort.
              if (segments[i].x - cx === 0 || segments[i].y - cy === 0) {
                s.push({
                  x1: 0,
                  y1: 0,
                  x2: 0,
                  y2: 0,
                  o: null,
                  ax1: cx,
                  ay1: cy,
                  ax2: segments[i].x,
                  ay2: segments[i].y
                });
                cx = segments[i].x;
                cy = segments[i].y;
              } else {
                log("Invalid path segment: ".concat(cx, ", ").concat(cy, ", ").concat(segments[i].x, ", ").concat(segments[i].y, ", not in X or Y axis"));
                return false;
              }
            }

            s.push({
              x1: 0,
              y1: 0,
              x2: 0,
              y2: 0,
              o: null,
              ax1: cx,
              ay1: cy,
              ax2: geometry.target.curX,
              ay2: geometry.target.curY
            });
            this.setAndTransformGeometry({
              segments: s,
              source: geometry.source,
              target: geometry.target
            });

            this._setAnchorLocation(geometry.source, this.connection, 0);

            this._setAnchorLocation(geometry.target, this.connection, 1);

            return true;
          }
        }

        return false;
      }
    }, {
      key: "writeSegments",
      value: function writeSegments(segments, paintInfo) {
        this.paintInfo = paintInfo;
        var current = null,
            next,
            currentDirection,
            nextDirection;

        for (var i = 0; i < segments.length - 1; i++) {
          current = current || _cloneSegment(segments[i]);
          next = _cloneSegment(segments[i + 1]);
          currentDirection = segmentDirections(current);
          nextDirection = segmentDirections(next);

          if (this.cornerRadius > 0 && current.o !== next.o) {
            var minSegLength = Math.min(orthogonalSegmentLength(current), orthogonalSegmentLength(next));
            var radiusToUse = Math.min(this.cornerRadius, minSegLength / 2);
            current.x2 -= currentDirection[0] * radiusToUse;
            current.y2 -= currentDirection[1] * radiusToUse;
            next.x1 += nextDirection[0] * radiusToUse;
            next.y1 += nextDirection[1] * radiusToUse;
            var ac = currentDirection[1] === nextDirection[0] && nextDirection[0] === 1 || currentDirection[1] === nextDirection[0] && nextDirection[0] === 0 && currentDirection[0] !== nextDirection[1] || currentDirection[1] === nextDirection[0] && nextDirection[0] === -1,
                sgny = next.y1 > current.y2 ? 1 : -1,
                sgnx = next.x1 > current.x2 ? 1 : -1,
                sgnEqual = sgny === sgnx,
                cx = sgnEqual && ac || !sgnEqual && !ac ? next.x1 : current.x2,
                cy = sgnEqual && ac || !sgnEqual && !ac ? current.y2 : next.y1;

            this._addSegment(StraightSegment, extend({}, current));

            if (!this.slightlyWonky) {
              this._addSegment(ArcSegment, {
                r: radiusToUse,
                x1: current.x2,
                y1: current.y2,
                x2: next.x1,
                y2: next.y1,
                cx: cx,
                cy: cy,
                ac: ac
              });
            } else {
              // this gives a slight hand-drawn effect to the lines, a kind of subtle wonkiness.
              this._addSegment(ArcSegment, extend({
                r: radiusToUse,
                cx: cx,
                cy: cy,
                ac: ac
              }, current));
            }
          } else {
            this._addSegment(StraightSegment, extend({}, current));
          }

          current = next;
        }

        if (next != null) {
          // last segment
          this._addSegment(StraightSegment, extend({}, current));
        }
      }
    }, {
      key: "_compute",
      value: function _compute(paintInfo, params) {
        this.lastx = null;
        this.lasty = null;
        this.lastOrientation = null;
        var sp = params.sourcePos,
            tp = params.targetPos;
        var geometry = this.geometry;

        if (this.edited && geometry != null && geometry.segments != null && geometry.segments.length > 0) {
          this.orthogonalSegments = geometry.segments;
          var sourceMoved = !positionEquals(sp, geometry.source),
              targetMoved = !positionEquals(tp, geometry.target);

          if (targetMoved) {
            var ls = this.orthogonalSegments[this.orthogonalSegments.length - 1];
            var lastSegmentVertical = findSegment(this.orthogonalSegments, -1, VERTICAL$1);
            var lastSegmentHorizontal = findSegment(this.orthogonalSegments, -1, HORIZONTAL);
            ls.ax1 = params.targetPos.curX + paintInfo.stubs[1] * paintInfo.to[0];
            ls.ay1 = params.targetPos.curY + paintInfo.stubs[1] * paintInfo.to[1];
            ls.ax2 = params.targetPos.curX;
            ls.ay2 = params.targetPos.curY; //ls[4] = params.targetPos.oy === 0 ? HORIZONTAL : VERTICAL

            ls.o = params.targetPos.oy === 0 ? HORIZONTAL : VERTICAL$1;

            if (lastSegmentVertical != null && lastSegmentHorizontal != null) {
              if (lastSegmentVertical[1] > lastSegmentHorizontal[1]) {
                // if the vertical segment came after the horizontal, set its X values to the end of the horizontal and dont move the horizontal
                lastSegmentVertical[0].ax1 = ls.ax1;
                lastSegmentVertical[0].ax2 = ls.ax1;
                lastSegmentVertical[0].ay2 = ls.ay1;
                lastSegmentHorizontal[0].ax2 = ls.ax1;
              } else {
                // otherwise set the horizontal's vertical values
                lastSegmentHorizontal[0].ay1 = ls.ay1;
                lastSegmentHorizontal[0].ay2 = ls.ay1;
                lastSegmentHorizontal[0].ax2 = ls.ax1;
                lastSegmentVertical[0].ay2 = ls.ay1;
              }
            } else if (lastSegmentHorizontal != null) {
              // this was a straight horizontal line originally
              // if there is a vertical delta...
              var dy = geometry.target.curY - params.targetPos.curY;

              if (dy !== 0) {
                // lastTargetHorizontal now needs to become a vertical segment, whose target Y value is
                // the new target position
                lastSegmentHorizontal[0].o = VERTICAL$1;
                lastSegmentHorizontal[0].ax2 = lastSegmentHorizontal[0].ax1;
                lastSegmentHorizontal[0].ay2 = params.targetPos.curY; // and then a new, horizontal, segment has to be inserted after it

                var newSegment = {
                  x1: 0,
                  y1: 0,
                  x2: 0,
                  y2: 0,
                  o: HORIZONTAL,
                  ax1: lastSegmentHorizontal[0].ax2,
                  ay1: lastSegmentHorizontal[0].ay2,
                  ax2: ls.ax1,
                  ay2: ls.ay1
                };
                this.orthogonalSegments.splice(lastSegmentHorizontal[1] + 1, 0, newSegment);
              }
            } else if (lastSegmentVertical != null) {
              // this was a straight vertical line originally
              // if there is a horizontal delta...
              var dx = geometry.target.curX - params.targetPos.curX; //[0];

              if (dx !== 0) {
                // lastTargetVertical now needs to become a horizontal segment, whose target X value is
                // the new target position
                // and then a new, vertical, segment has to be inserted after it
                lastSegmentVertical[0].o = HORIZONTAL;
                lastSegmentVertical[0].ay2 = lastSegmentHorizontal[0].ay1;
                lastSegmentVertical[0].ax2 = params.targetPos.curX; // and then a new, vertical, segment has to be inserted after it

                var _newSegment = {
                  x1: 0,
                  y1: 0,
                  x2: 0,
                  y2: 0,
                  o: VERTICAL$1,
                  ax1: lastSegmentVertical[0].ax2,
                  ay1: lastSegmentVertical[0].ay2,
                  ax2: ls.ax1,
                  ay2: ls.ay1
                };
                this.orthogonalSegments.splice(lastSegmentVertical[1] + 1, 0, _newSegment);
              }
            }

            this.orthogonalSegments = transformFromAbsolute(this.orthogonalSegments);
          }

          if (sourceMoved) {
            var ls2 = this.orthogonalSegments[0];
            var firstSegmentVertical = findSegment(this.orthogonalSegments, 1, VERTICAL$1);
            var firstSegmentHorizontal = findSegment(this.orthogonalSegments, 1, HORIZONTAL);
            ls2.ax1 = params.sourcePos.curX;
            ls2.ay1 = params.sourcePos.curY;
            ls2.ax2 = params.sourcePos.curX + paintInfo.stubs[0] * paintInfo.so[0];
            ls2.ay2 = params.sourcePos.curY + paintInfo.stubs[0] * paintInfo.so[1];
            ls2.o = params.sourcePos.oy === 0 ? HORIZONTAL : VERTICAL$1; // if we have both a vertical and horizontal segment in this path...

            if (firstSegmentVertical != null && firstSegmentHorizontal != null) {
              // if the first vertical segment occurs after the first horizontal segment...
              if (firstSegmentVertical[1] > firstSegmentHorizontal[1]) {
                // set the first horizontal segment's y value to be y2 for the start stub.
                firstSegmentHorizontal[0].ay1 = ls2.ay2;
                firstSegmentHorizontal[0].ay2 = ls2.ay2;
                firstSegmentHorizontal[0].ax1 = ls2.ax2;
                firstSegmentVertical[0].ay1 = ls2.ay2;
              } else {
                // if the first vertical segment comes before the horizontal segment,
                // set its start point to be the end of the start stub.
                firstSegmentVertical[0].ax1 = ls2.ax2;
                firstSegmentVertical[0].ax2 = ls2.ax2;
                firstSegmentVertical[0].ay1 = ls2.ay2;
                firstSegmentHorizontal[0].ax1 = ls2.ax2;
              }
            } else if (firstSegmentHorizontal != null) {
              // this was a straight horizontal line originally
              // if there is a vertical delta...
              var _dy = geometry.target.curY - params.targetPos.curY;

              if (_dy !== 0) {
                // firstSegmentHorizontal remains unchanged. We splice in a new vertical segment before it, with
                // x values corresponding to the start of fsh, and y1 = targetPos.curY, and y2 = fsh y value
                // and then a new, horizontal, segment has to be inserted after it
                var _newSegment2 = {
                  x1: 0,
                  y1: 0,
                  x2: 0,
                  y2: 0,
                  o: VERTICAL$1,
                  ax1: firstSegmentHorizontal[0].ax1,
                  ay1: params.targetPos.curY,
                  ax2: firstSegmentHorizontal[0].ax1,
                  ay2: firstSegmentHorizontal[0].ay1
                };
                this.orthogonalSegments.splice(firstSegmentHorizontal[1] - 1, 0, _newSegment2);
              }
            } else if (firstSegmentVertical != null) {
              // this was a straight vertical line originally
              // if there is a horizontal delta...
              var _dx = geometry.target.curX - params.targetPos.curX;

              if (_dx !== 0) {
                // firstSegmentVertical remains unchanged. We splice in a new horizontal segment before it, with
                // y values corresponding to the start of fsh, and x1 = targetPos.curX, and x2 = fsh x value
                // and then a new, horizontal, segment has to be inserted after it
                var _newSegment3 = {
                  x1: 0,
                  y1: 0,
                  x2: 0,
                  y2: 0,
                  o: HORIZONTAL,
                  ax1: params.targetPos.curX,
                  ay1: firstSegmentVertical[0].ay1,
                  ax2: firstSegmentVertical[0].ax1,
                  ay2: firstSegmentVertical[0].ay1
                };
                this.orthogonalSegments.splice(firstSegmentVertical[1] - 1, 0, _newSegment3);
              }
            }

            this.orthogonalSegments = transformFromAbsolute(this.orthogonalSegments);
          }

          this.setGeometry({
            segments: this.orthogonalSegments,
            source: params.sourcePos,
            target: params.targetPos,
            quadrant: paintInfo.segment
          }, false);
        } else {
          this.orthogonalSegments.length = 0;

          var _dx2 = tp.curX >= sp.curX ? sp.curX : tp.curX,
              _dy2 = tp.curY >= sp.curY ? sp.curY : tp.curY; // calculate Stubs.


          var stubs = stubCalculators.get(paintInfo.anchorOrientation)(paintInfo, this.alwaysRespectStubs),
              _idx = paintInfo.sourceAxis === "x" ? 0 : 1,
              oidx = paintInfo.sourceAxis === "x" ? 1 : 0,
              ss = stubs[_idx],
              oss = stubs[oidx],
              es = stubs[_idx + 2],
              oes = stubs[oidx + 2]; // add the start stub segment. use stubs for loopback as it will look better, with the loop spaced
          // away from the element.


          addSegment(this, stubs[0], stubs[1], paintInfo, _dx2, _dy2); // if its a loopback and we should treat it differently.
          // if (false &&params.sourcePos[0] === params.targetPos.curX && params.sourcePos[1] === params.targetPos.curY){//[1]) {
          //
          //     // we use loopbackRadius here, as statemachine connectors do.
          //     // so we go radius to the left from stubs[0], then upwards by 2*radius, to the right by 2*radius,
          //     // down by 2*radius, left by radius.
          //     addSegment(this, stubs[0] - this.loopbackRadius, stubs[1], paintInfo)
          //     addSegment(this, stubs[0] - this.loopbackRadius, stubs[1] - (2 * this.loopbackRadius), paintInfo)
          //     addSegment(this, stubs[0] + this.loopbackRadius, stubs[1] - (2 * this.loopbackRadius), paintInfo)
          //     addSegment(this, stubs[0] + this.loopbackRadius, stubs[1], paintInfo)
          //     addSegment(this, stubs[0], stubs[1], paintInfo)
          //
          // }
          // else {

          var _midx = paintInfo.startStubX + (paintInfo.endStubX - paintInfo.startStubX) * this.midpoint,
              _midy = paintInfo.startStubY + (paintInfo.endStubY - paintInfo.startStubY) * this.midpoint; // compute the rest of the line


          var lineCalculator = lineCalculators.get(paintInfo.anchorOrientation);

          var _p = lineCalculator(this, paintInfo, params, paintInfo.sourceAxis, ss, oss, es, oes, _midx, _midy, _idx);

          if (_p) {
            for (var i = 0; i < _p.length; i++) {
              addSegment(this, _p[i][0], _p[i][1], paintInfo, _dx2, _dy2);
            }
          } // line to end stub


          addSegment(this, stubs[2], stubs[3], paintInfo, _dx2, _dy2); // end stub to end (common)

          addSegment(this, paintInfo.tx, paintInfo.ty, paintInfo, _dx2, _dy2);
          this.setGeometry({
            segments: this.orthogonalSegments,
            source: params.sourcePos,
            target: params.targetPos,
            quadrant: paintInfo.segment
          }, true);
        } // write out the segments.


        this.writeSegments(this.orthogonalSegments, paintInfo);
      }
      /**
       * For a given segment, find it - and its index - inside our current list.
       * @param segment The segment to locate
       * @param findRelatives If true, look also for segments with the same orientation in both forwards and backwards directions. These latter are used when
       * trying to decide of a segment can be deleted.
       * @returns If found, a context object containing the segment, its index, its previous/next segments (if defined),
       * and optionally (if requested) segments with the same orientation in both forwards and backwards directions. These latter are used when
       * trying to decide of a segment can be deleted.
       * @internal
       */

    }, {
      key: "_locateSegment",
      value: function _locateSegment(segment, findRelatives) {
        var idx = this.orthogonalSegments.findIndex(function (g) {
          return g.ax1 === segment.ax1 && g.ay1 === segment.ay1 && g.ax2 === segment.ax2 && g.ay2 === segment.ay2;
        });

        if (idx > -1) {
          var o = this.orthogonalSegments[idx].o,
              s = this.orthogonalSegments[idx];
          return {
            segment: s,
            index: idx,
            orientation: o,
            prev: idx > 1 ? this.orthogonalSegments[idx - 1] : null,
            next: idx < this.orthogonalSegments.length - 2 ? this.orthogonalSegments[idx + 1] : null,
            left: findRelatives ? findSegment(this.orthogonalSegments, -1, o, s) : null,
            right: findRelatives ? findSegment(this.orthogonalSegments, 1, o, s) : null
          };
        } else {
          return null;
        }
      }
    }, {
      key: "setSegmentPosition",
      value: function setSegmentPosition(segment, pos) {
        var ctx = this._locateSegment(segment);

        if (ctx != null) {
          if (ctx.orientation === VERTICAL$1) {
            ctx.segment.ax1 = ctx.segment.ax2 = pos[0];
          } else {
            ctx.segment.ay1 = ctx.segment.ay2 = pos[1];
          }

          var currentVertical = ctx.orientation === VERTICAL$1;
          var _idx2 = ctx.index;
          var originalIndex = ctx.index; // go back through the segment list to the first segment, adjusting end positions as we go, starting at the
          // segment before this one. we ignore the stubs. if, when adjusting a previous segment, it is discovered to now be
          // of length 0, it is removed.

          var previous = _idx2 > 1 ? this.orthogonalSegments[_idx2 - 1] : null,
              current = ctx.segment;

          while (previous != null) {
            if (previous.o === current.o) {
              if (currentVertical) {
                previous.ax1 = current.ax1;
                previous.ax2 = current.ax2;
              } else {
                previous.ay1 = current.ay1;
                previous.ay2 = current.ay2;
              }
            } else {
              previous.ax2 = current.ax1;
              previous.ay2 = current.ay1;
            }

            current = previous;
            _idx2--;
            previous = _idx2 > 1 ? this.orthogonalSegments[_idx2 - 1] : null;
          }

          if (current.ax1 !== this.orthogonalSegments[0].ax2) {
            var newSegment = {
              x1: null,
              y1: null,
              x2: null,
              y2: null,
              o: HORIZONTAL,
              ax1: this.orthogonalSegments[0].ax2,
              ay1: this.orthogonalSegments[0].ay2,
              ax2: current.ax1,
              ay2: current.ay1
            };
            this.orthogonalSegments.splice(1, 0, newSegment);
            originalIndex++;
          } else if (current.ay1 !== this.orthogonalSegments[0].ay2) {
            var _newSegment4 = {
              x1: null,
              y1: null,
              x2: null,
              y2: null,
              o: VERTICAL$1,
              ax1: this.orthogonalSegments[0].ax2,
              ay1: this.orthogonalSegments[0].ay2,
              ax2: current.ax1,
              ay2: current.ay1
            };
            this.orthogonalSegments.splice(1, 0, _newSegment4);
            originalIndex++;
          }

          current = ctx.segment;
          _idx2 = ctx.index;
          var next = _idx2 < this.orthogonalSegments.length - 2 ? this.orthogonalSegments[_idx2 + 1] : null;

          while (next != null) {
            if (next.o === current.o) {
              if (currentVertical) {
                next.ax1 = current.ax1;
                next.ax2 = current.ax2;
              } else {
                next.ay1 = current.ay1;
                next.ay2 = current.ay2;
              }
            } else {
              next.ax1 = current.ax2;
              next.ay1 = current.ay2;
            }

            current = next;
            _idx2++;
            next = _idx2 < this.orthogonalSegments.length - 2 ? this.orthogonalSegments[_idx2 + 1] : null;
          }

          var _endStub = this.orthogonalSegments[this.orthogonalSegments.length - 1];

          if (current.ax2 !== _endStub.ax1) {
            var _newSegment5 = {
              x1: null,
              y1: null,
              x2: null,
              y2: null,
              o: HORIZONTAL,
              ax1: current.ax2,
              ay1: current.ay2,
              ax2: _endStub.ax1,
              ay2: _endStub.ay1
            };
            this.orthogonalSegments.splice(this.orthogonalSegments.length - 1, 0, _newSegment5);
          } else if (current.ay2 !== _endStub.ay1) {
            var _newSegment6 = {
              x1: null,
              y1: null,
              x2: null,
              y2: null,
              o: VERTICAL$1,
              ax1: current.ax2,
              ay1: current.ay2,
              ax2: _endStub.ax1,
              ay2: _endStub.ay1
            };
            this.orthogonalSegments.splice(this.orthogonalSegments.length - 1, 0, _newSegment6);
          }

          this.orthogonalSegments = transformFromAbsolute(this.orthogonalSegments);
          this.edited = true;
          return {
            ctx: ctx,
            segments: this.orthogonalSegments,
            index: originalIndex
          };
        } else {
          return null;
        }
      }
      /**
       * Searches through the path coalescing consecutive segments in the same axis. Currently this ignores both the start segment and
       * the end segment, but increasingly it's looking like this method could be improved, because it's possible to drag an
       * element around and end up with the segment after the start segment either tracing over the start segment, or jutting
       * out from the middle of the start segment (and a similar situation with the end segment).
       * @internal
       */

    }, {
      key: "trim",
      value: function trim() {
        // keep the first and last segments and filter anything in between
        var out = [clone(this.orthogonalSegments[0])];

        var _final = clone(this.orthogonalSegments[this.orthogonalSegments.length - 1]);

        var s2 = this.orthogonalSegments.slice(1, this.orthogonalSegments.length - 1).filter(function (s) {
          return orthogonalSegmentLength(s) > 0;
        }).map(clone);
        var prev = null;
        var prevOrientation = null;

        for (var i = 0; i < s2.length; i++) {
          if (prev == null || prevOrientation == null) {
            prev = s2[i];
            prevOrientation = s2[i].o;
          } else {
            if (s2[i].o === prevOrientation) {
              prev.y2 = s2[i].y2;
              prev.x2 = s2[i].x2;
              prev.ay2 = s2[i].ay2;
              prev.ax2 = s2[i].ax2;
            } else {
              out.push(prev);
              prev = s2[i];
              prevOrientation = s2[i].o;
            }
          }
        }

        out.push(prev);
        out.push(_final); // if only 3 segments, put placeholder empty segments in, to preserve the stubs.

        if (out.length === 3) {
          var midSegment = out[1],
              mido = midSegment.o;
          var ns1 = clone(midSegment),
              ns2 = clone(midSegment),
              ns3 = clone(midSegment);
          ns2.o = mido === HORIZONTAL ? VERTICAL$1 : HORIZONTAL;
          ns2.x1 = ns1.x1;
          ns2.y1 = ns1.y1;
          ns2.x2 = ns1.x1;
          ns2.y2 = ns1.y1;
          ns2.ax1 = ns1.ax1;
          ns2.ay1 = ns1.ay1;
          ns2.ax2 = ns1.ax1;
          ns2.ay2 = ns1.ay1;
          ns3.o = mido === HORIZONTAL ? VERTICAL$1 : HORIZONTAL;
          ns3.x1 = ns1.x2;
          ns3.y1 = ns1.y2;
          ns3.x2 = ns1.x2;
          ns3.y2 = ns1.y2;
          ns3.ax1 = ns1.ax2;
          ns3.ay1 = ns1.ay2;
          ns3.ax2 = ns1.ax2;
          ns3.ay2 = ns1.ay2;
          out = [out[0], ns2, ns1, ns3, out[2]];
        }

        this.setAndTransformSegments(out);
      }
    }, {
      key: "setAnchorOrientation",
      value: function setAnchorOrientation(idx, orientation) {
        if (this.orthogonalSegments.length >= 2) {
          var segment = idx === 0 ? this.orthogonalSegments[0] : this.orthogonalSegments[this.orthogonalSegments.length - 1];
          var o = orientation[0] === 0 ? VERTICAL$1 : HORIZONTAL;
          segment.o = o;
          this.edited = true;
        }
      }
    }]);

    return OrthogonalConnector;
  }(AbstractConnector);

  _defineProperty$2(OrthogonalConnector, "type", "Orthogonal");

  Connectors.register(OrthogonalConnector.type, OrthogonalConnector);

  function _classCallCheck$1(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$1(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$1(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$1(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty$1(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }

    return _assertThisInitialized(self);
  }

  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn(this, result);
    };
  }

  var FLOWCHART_HANDLE_CLASS = "jtk-orthogonal-handle";
  var SEGMENT_DRAG_HANDLE = "jtk-orthogonal-segment-drag";
  var SEGMENT_DRAG_HANDLE_VERTICAL_CLASS = "jtk-orthogonal-segment-drag-ns";
  var SEGMENT_DRAG_HANDLE_HORIZONTAL_CLASS = "jtk-orthogonal-segment-drag-ew";
  var VERTICAL = "v";
  var OrthogonalEditor = /*#__PURE__*/function (_EditorBase) {
    _inherits(OrthogonalEditor, _EditorBase);

    var _super = _createSuper(OrthogonalEditor);

    function OrthogonalEditor(surface, params) {
      var _this;

      _classCallCheck$1(this, OrthogonalEditor);

      _this = _super.call(this, surface, params);

      _defineProperty$1(_assertThisInitialized(_this), "current", void 0);

      _defineProperty$1(_assertThisInitialized(_this), "segments", void 0);

      _defineProperty$1(_assertThisInitialized(_this), "segmentHandles", void 0);

      _defineProperty$1(_assertThisInitialized(_this), "geometry", void 0);

      _this.segments = [];
      _this.segmentHandles = [];
      /**
       * Attaches a delegated drag listener for segment handles. When dragged,
       * a handle is constrained to move in the perpendicular axis to that of the segment,
       * and each time it moves the underlying editable flowchart connector is informed.
       * It is the connector itself that decides what happens to the path; it returns the
       * new full list of segments from the `setSegmentPosition` method. This drag handler
       * then stores the new geometry for the segment being dragged, and calls
       * `repaintConnection`, which is a method on the superclass. We pass in the current
       * segment to this method, which itself calls `repaint` on the Connection, passing in
       * any parameters we gave it.
       *
       * This method - or at least the behaviour of this method - is
       * specific to the flowchart editor. the bezier editor also
       * support handle dragging, but it does different stuff.
       */

      _this._addDragHandler({
        selector: "." + SEGMENT_DRAG_HANDLE,
        drag: function drag(dp) {
          var segmentInfo = dp.drag.getDragElement()._jsPlumbDragHandle;

          var s = _this.jsplumb.getSize(segmentInfo.el);

          var p = [Math.floor(dp.pos.x + s.w / 2), Math.floor(dp.pos.y + s.h / 2)];

          var moveResult = _this.currentConnector.setSegmentPosition(segmentInfo.geometry, p);

          if (moveResult != null) {
            // the move result contains the new set of segments, plus the index of the segment that was moved; this index
            // might have changed because of a segment being added or deleted. so we stash the new list of segments,
            // and we also update the geometry of the current moving segment with the updated value from the connector.
            _this.segments.length = 0;
            _this.geometry.segments = moveResult.segments;
            Array.prototype.push.apply(_this.segments, _this.geometry.segments);
            segmentInfo.geometry = _this.geometry.segments[moveResult.index]; // now we need to redraw everything except the current segment.

            _this.repaintConnection({
              segmentInfo: segmentInfo,
              segmentIndex: moveResult.index
            });
          }
        },
        constrainFunction: function constrainFunction(desiredLoc, dragEl, dim, dragElSize) {
          var segmentInfo = dragEl._jsPlumbDragHandle;
          var vertical = segmentInfo.geometry.ax1 === segmentInfo.geometry.ax2;

          if (vertical) {
            return {
              x: desiredLoc.x,
              y: (segmentInfo.geometry.ay1 + segmentInfo.geometry.ay2) / 2 - dragElSize.h / 2
            };
          } else {
            return {
              x: (segmentInfo.geometry.ax1 + segmentInfo.geometry.ax2) / 2 - dragElSize.w / 2,
              y: desiredLoc.y
            };
          }
        },
        stop: function stop(p) {
          _this._trimConnection();

          _this.fireConnectionEditEvent();
        }
      });

      return _this;
    }

    _createClass$1(OrthogonalEditor, [{
      key: "_setHandlePosition",
      value: function _setHandlePosition(segmentInfo, mid) {
        segmentInfo.el.style.visibility = "visible";

        this._setElementPosition(segmentInfo.el, mid[0], mid[1]);
      }
      /**
       * Repaint the editor. This may or may not have come
       * about as the result of a call by this class to `repaintConnection` - if
       * `internalEditorRepaint` and/or `args` is set, then that is the case.
       * @override
       * @param args
       * @internal
       */

    }, {
      key: "_repaint",
      value: function _repaint(args) {
        // update the connector info. args may optionally contain
        // a segment to exclude from the update, if this method
        // was called via repaintConnection in a handle drag.
        this._update(args); // update segment handles on screen and also their underlying geometry.


        for (var i = 0; i < this.segmentHandles.length; i++) {
          this.segmentHandles[i].geometry = this.geometry.segments[i + 1]; // NOTE here the +1 - we ignore the source stub segment.

          if (orthogonalSegmentLength(this.segmentHandles[i].geometry) > 0) {
            var mid = [(this.segmentHandles[i].geometry.ax1 + this.segmentHandles[i].geometry.ax2) / 2, (this.segmentHandles[i].geometry.ay1 + this.segmentHandles[i].geometry.ay2) / 2];

            this._setHandlePosition(this.segmentHandles[i], mid);
          } else {
            this.segmentHandles[i].el.style.visibility = "hidden";
          }
        }
      }
      /**
       * clear all handles, except, optionally, the one provided.
       * @param excludeHandle
       * @override
       */

    }, {
      key: "_clearHandles",
      value: function _clearHandles(excludeHandle) {
        for (var i = 0; i < this.segmentHandles.length; i++) {
          if (this.segmentHandles[i].el !== excludeHandle) {
            this.jsplumb._removeElement(this.segmentHandles[i].el);
          }
        }
      }
      /**
       * Activates the editor, on the given connection.
       * @override
       * @param conn
       * @internal
       */

    }, {
      key: "_activate",
      value: function _activate(conn, params) {
        this._update();
      }
    }, {
      key: "_elementDragged",
      value: function _elementDragged(p) {
        this._trimConnection();
      }
    }, {
      key: "_elementDragging",
      value: function _elementDragging(p) {
        this._repaint();
      }
      /**
       * updates the current origin of the connector's SVG element (the location of its to left corner wrt
       * the origin of the jsplumb instance's container). Then updates the offset of the source and target points
       * from the origin of the SVG element. Finally, extracts the control point information from the connection,
       * either as geometry (if previously edited or set) or from the computed control points.
       * @override
       */

    }, {
      key: "_update",
      value: function _update(args) {
        args = args || {};
        var excludeSegment = args.segmentInfo,
            excludeIndex = args.segmentIndex;
        this.geometry = this.current.connector.geometry;

        if (this.geometry && this.geometry.segments) {
          this._clearHandles(excludeSegment ? excludeSegment.el : null);

          this.segmentHandles.length = 0;
          this.segments.length = 0;
          Array.prototype.push.apply(this.segments, this.geometry.segments);

          for (var i = 1; i < this.segments.length - 1; i++) {
            if (excludeSegment == null || i !== excludeIndex) {
              var mid = [(this.segments[i].ax1 + this.segments[i].ax2) / 2, (this.segments[i].ay1 + this.segments[i].ay2) / 2],
                  handleLeft = mid[0],
                  handleTop = mid[1],
                  vertical = this.segments[i].o === VERTICAL,
                  handle = _makeAndAppendHandle(handleLeft, handleTop, this.jsplumb, [FLOWCHART_HANDLE_CLASS, SEGMENT_DRAG_HANDLE, vertical ? SEGMENT_DRAG_HANDLE_HORIZONTAL_CLASS : SEGMENT_DRAG_HANDLE_VERTICAL_CLASS].join(" "), true);

              var segmentInfo = {
                left: handleLeft,
                top: handleTop,
                el: handle,
                geometry: this.segments[i],
                vertical: vertical
              };
              handle._jsPlumbDragHandle = segmentInfo;
              this.segmentHandles.push(segmentInfo);

              this._setHandlePosition(segmentInfo, mid);
            } else if (i === excludeIndex) {
              this.segmentHandles.push(excludeSegment);
            }
          }
        }
      }
      /**
       * Trims any segments that are now of length zero, then
       * concatenates subsequent segments that are in the same axis.
       * then instructs the superclass to repaint (which will
       * result in this class redrawing all its handles)
       * @internal
       */

    }, {
      key: "_trimConnection",
      value: function _trimConnection() {
        if (this.current) {
          this.currentConnector.trim();
          this.repaintConnection();
        }
      }
    }]);

    return OrthogonalEditor;
  }(EditorBase);

  _defineProperty$1(OrthogonalEditor, "type", "Orthogonal");

  editors.set(OrthogonalEditor.type, OrthogonalEditor);
  /**
   * Register the orthogonal editor with the connector editors modules. In
   * certain setups, for instance a React app, you need to do this in order to
   * ensure the orthogonal editor code is included.
   */

  function initialize() {
    editors.set(OrthogonalEditor.type, OrthogonalEditor);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  var isTouchDevice = ('ontouchstart' in document.documentElement);
  var downEvent = isTouchDevice ? "touchstart" : "mousedown";
  var upEvent = isTouchDevice ? "touchend" : "mouseup";
  var moveEvent = isTouchDevice ? "touchmove" : "mousemove";
  var isIE11 = !!window.MSInputMethodContext && !!document.documentMode;

  function devnull() {}

  function createEl(classNames) {
    var e = document.createElement("div");
    addClass(e, classNames.join(" "));
    document.body.appendChild(e);
    return e;
  }

  var Lasso = /*#__PURE__*/function () {
    function Lasso(options) {
      _classCallCheck(this, Lasso);

      _defineProperty(this, "el", void 0);

      _defineProperty(this, "masks", {});

      _defineProperty(this, "origin", {
        x: 0,
        y: 0
      });

      _defineProperty(this, "onStart", void 0);

      _defineProperty(this, "onEnd", void 0);

      _defineProperty(this, "onSelect", void 0);

      _defineProperty(this, "down", false);

      _defineProperty(this, "moving", false);

      _defineProperty(this, "invert", void 0);

      _defineProperty(this, "surface", void 0);

      _defineProperty(this, "_filter", void 0);

      _defineProperty(this, "eventManager", void 0);

      _defineProperty(this, "downListener", void 0);

      _defineProperty(this, "upListener", void 0);

      _defineProperty(this, "moveListener", void 0);

      _defineProperty(this, "enabled", false);

      this.surface = options.surface;
      this.onStart = options.onStart || devnull;
      this.onEnd = options.onEnd || devnull;
      this.onSelect = options.onSelect || devnull;
      this.invert = options.invert === true;
      this.downListener = this._downListener.bind(this);
      this.upListener = this._upListener.bind(this);
      this.moveListener = this._moveListener.bind(this);
      this.eventManager = new EventManager();
      this._filter = options.filter ? function (e) {
        var t = e.srcElement || e.target;
        return matchesSelector$1(t, options.filter);
      } : function () {
        return false;
      };

      if (!this.invert) {
        this.el = createEl([CLASS_LASSO]);
      } else {
        this._createMasks();
      }

      this.eventManager.on(this.surface.jsplumb.getContainer().parentNode, downEvent, this.downListener);
    }

    _createClass(Lasso, [{
      key: "_position",
      value: function _position(origin, size) {
        if (!this.invert) {
          setBoundingRect(this.el, origin, size);
        } else {
          var ww = isIE11 ? (window.innerWidth + document.body.clientWidth) / 2 : window.innerWidth,
              wh = window.innerHeight,
              wsx = window.pageXOffset,
              wsy = window.pageYOffset,
              t = wh - origin.y + wsy,
              b = wh - t + size.h,
              l = ww - origin.x + wsx,
              r = ww - l + size.w;
          this.masks.top.style.bottom = t + "px";
          this.masks.bottom.style.top = b + "px";
          this.masks.left.style.right = l + "px";
          this.masks.right.style.left = r + "px";
          this.masks.top.style.left = ww - l + "px";
          this.masks.top.style.right = ww - r + "px";
          this.masks.bottom.style.left = ww - l + "px";
          this.masks.bottom.style.right = ww - r + "px";
        }
      }
    }, {
      key: "_setVisible",
      value: function _setVisible(state) {
        var d = state ? Constants.block : Constants.none;

        if (!this.invert) {
          this.el.style.display = d;
        } else {
          this.masks.top.style.display = d;
          this.masks.left.style.display = d;
          this.masks.right.style.display = d;
          this.masks.bottom.style.display = d;
        }

        if (state) {
          this.surface.addClass(document.body, CLASS_SELECT_DEFEAT);
        } else {
          this.surface.removeClass(document.body, CLASS_SELECT_DEFEAT);
        }
      }
    }, {
      key: "_downListener",
      value: function _downListener(e) {
        if (this.enabled && !this._filter(e)) {
          consume(e);
          this.down = true;
          this.eventManager.on(document, upEvent, this.upListener);
          this.eventManager.on(document, moveEvent, this.moveListener);
          this.origin = pageLocation(e);

          this._position(this.origin, {
            w: 1,
            h: 1
          });

          this.onStart(this.origin, e.shiftKey);
        }
      }
    }, {
      key: "_moveListener",
      value: function _moveListener(e) {
        if (this.down) {
          if (!this.moving) {
            this._setVisible(true);

            this.moving = true;
          }

          consume(e);
          var pl = pageLocation(e),
              s = {
            w: Math.abs(pl.x - this.origin.x),
            h: Math.abs(pl.y - this.origin.y)
          },
              o = {
            x: Math.min(this.origin.x, pl.x),
            y: Math.min(this.origin.y, pl.y)
          };

          this._position(o, s);

          this.onSelect(o, s, [this.origin.x < pl.x, this.origin.y < pl.y], e.shiftKey);
        }
      }
    }, {
      key: "_upListener",
      value: function _upListener(e) {
        if (this.down) {
          this.down = false;
          this.moving = false;
          consume(e);
          this.eventManager.off(document, upEvent, this.upListener);
          this.eventManager.off(document, moveEvent, this.moveListener);

          this._setVisible(false);

          this.onEnd();
        }
      }
    }, {
      key: "_createMasks",
      value: function _createMasks() {
        this.masks.top = createEl([CLASS_LASSO_MASK, CLASS_LASSO_MASK_TOP]);
        this.masks.bottom = createEl([CLASS_LASSO_MASK, CLASS_LASSO_MASK_BOTTOM]);
        this.masks.left = createEl([CLASS_LASSO_MASK, CLASS_LASSO_MASK_LEFT]);
        this.masks.right = createEl([CLASS_LASSO_MASK, CLASS_LASSO_MASK_RIGHT]);
      }
      /**
       * Returns whether or not the lasso is active.
            * @returns true if active, false otherwise.
       */

    }, {
      key: "isActive",
      value: function isActive() {
        return this.down;
      }
      /**
       * Sets whether or not the lasso responds to mouse events.
            * @param e Enabled state.
       */

    }, {
      key: "setEnabled",
      value: function setEnabled(e) {
        this.enabled = e;
      }
    }]);

    return Lasso;
  }();

  /**
   * @public
   */

  /**
   * A plugin that allows the user to select multiple elements with the mouse.
   * @public
   */
  var LassoPlugin = /*#__PURE__*/function () {
    function LassoPlugin() {
      _classCallCheck(this, LassoPlugin);

      _defineProperty(this, "surface", void 0);

      _defineProperty(this, "lasso", void 0);

      _defineProperty(this, "onStart", void 0);

      _defineProperty(this, "onEnd", void 0);

      _defineProperty(this, "onSelect", void 0);

      _defineProperty(this, "selectionFilter", void 0);

      _defineProperty(this, "lassoSelections", []);
    }

    _createClass(LassoPlugin, [{
      key: "destroy",
      value: function destroy() {}
    }, {
      key: "initialise",
      value: function initialise(surface, options) {
        var _this = this;

        surface.bind(EVENT_SURFACE_MODE_CHANGED, function (m) {
          _this.lasso.enabled = m === Constants.select;
        });
        this.selectionFilter = options.selectionFilter;
        this.onStart = options.onStart;
        this.onSelect = options.onSelect;
        this.onEnd = options.onEnd;
        this.lasso = new Lasso({
          surface: surface,
          invert: options.invert,
          canvas: surface.containerElement,
          onStart: function onStart() {
            surface.setHoverSuspended(true);
            _this.lassoSelections.length = 0;
            _this.onStart && _this.onStart();
          },
          onSelect: function onSelect(origin, size, directions, shiftDown) {
            surface.jsplumb.clearDragSelection && surface.jsplumb.clearDragSelection();
            surface.toolkitInstance.clearSelection();

            if (shiftDown && _this.lassoSelections.length > 0) {
              // clear last lasso selections if shift down.
              surface.toolkitInstance.removeFromSelection(_this.lassoSelections);
            }

            var n = [],
                i,
                nodes = surface.findIntersectingVertices(origin, size, !directions[0]),
                nodeCount = nodes.length,
                _objMap = {};

            for (i = 0; i < nodeCount; i++) {
              if (_this.selectionFilter == null || _this.selectionFilter(nodes[i].v) !== false) {
                n.push(nodes[i].v);
                _objMap[nodes[i].id] = true;
                surface.jsplumb.addToDragSelection(nodes[i].el);
              }
            }

            _this.lassoSelections = n;
            nodeCount = n.length;

            if (options.includeEdges) {
              var _eMap = {};

              for (i = 0; i < nodeCount; i++) {
                var te = [],
                    eid = void 0;
                Array.prototype.push.apply(te, n[i].getAllEdges());

                for (var j = 0; j < te.length; j++) {
                  eid = te[j].getId();

                  if (!_eMap[eid]) {
                    var sourceNodeId = te[j].source.objectType === Port.objectType ? te[j].source.getParent().id : te[j].source.id,
                        targetNodeId = te[j].target.objectType === Port.objectType ? te[j].target.getParent().id : te[j].target.id;

                    if (_objMap[sourceNodeId] && _objMap[targetNodeId]) {
                      n.push(te[j]);
                    }

                    _eMap[eid] = true;
                  }
                }
              }
            } // the JS code used to pass in `shiftDown` but in fact it was ignored by
            // the addToSelection method on the Toolkit.


            surface.toolkitInstance.addToSelection(n);
            _this.onSelect && _this.onSelect(n);
          },
          onEnd: function onEnd() {
            surface.setHoverSuspended(false);

            if (surface.autoExitSelectMode && surface.mode !== SurfaceMode.DISABLED) {
              surface.setMode(SurfaceMode.PAN);
            }

            surface.fire(EVENT_LASSO_END);
            _this.onEnd && _this.onEnd();
          },
          filter: options.filter
        });
        return false;
      }
    }, {
      key: "reset",
      value: function reset() {}
    }, {
      key: "activated",
      value: function activated() {
        this.lasso.enabled = true;
      }
    }, {
      key: "deactivated",
      value: function deactivated() {
        this.lasso.enabled = false;
      }
    }]);

    return LassoPlugin;
  }();

  _defineProperty(LassoPlugin, "type", "lasso");

  SurfacePlugins.register(LassoPlugin.type, LassoPlugin);

  initialize();
  var SELECTABLE = "selectable";
  var RESPONSE = "response";
  var SOURCE = "source";
  var TARGET = "target";
  var CONDITION = "condition";
  var BRANCH = "branch";
  var TARIFF = "tariff";
  var CAIR_TARIFF = "cairTariff";
  var PRICING_PRODUCT = "pricingProduct";
  var JOUNAL_NODE = "journalNode";
  var jsToolkit;
  var jsRenderer;
  var copiedNodes = [];
  var isPasting = false;
  var lastCtrlVTime = 0; // Initialize a variable to store the last execution time
  // Cair Tooltip handling

  var cairTooltip;
  var grossCoverageTitle;
  var beslTitle;
  var rateTitle;
  var formulaTitle;
  var descriptionTitle;
  var noFormulaTitle;
  var isTooltipEnabled;

  function callDOMReady(canEdit) {
    var _nodes, _edges, _ports;

    var isLoading = true;
    var ignoreFirstLoadCall = true;
    cairTooltip = document.getElementById('cairTooltipGraphView');
    grossCoverageTitle = document.getElementById('grossCoverageTitleGraphView');
    beslTitle = document.getElementById('beslTitleGraphView');
    rateTitle = document.getElementById('rateTitleGraphView');
    formulaTitle = document.getElementById('formulaTitleGraphView');
    descriptionTitle = document.getElementById('descriptionTitleGraphView');
    noFormulaTitle = document.getElementById('noFormulaTitleGraphView');
    isTooltipEnabled = document.getElementById('isTooltipEnabledGraphView');
    console.log("Inside initJsPlumb. CanEdit is ", canEdit); // ------------------------- dialogs -------------------------------------
    // ------------------------- / dialogs ----------------------------------
    // get the various dom elements

    var mainElement = document.querySelector("#jtk-graphview-flowchart"),
        canvasElement = mainElement.querySelector(".jtk-graphview-canvas"),
        miniviewElement = mainElement.querySelector(".miniview"),
        nodePalette = mainElement.querySelector(".node-palette"),
        controls = mainElement.querySelector(".controls"); // Declare an instance of the Toolkit and supply a nodeFactory, used when adding new nodes, and a beforeConnect interceptor, used
    // to control what can be connected to what.

    var toolkit = newInstance({
      nodeFactory: function nodeFactory(type, data, continueCallback, abortCallback) {
        if (data.type === CONDITION) {
          data.id = uuid();
          continueCallback(data);
          openEditConditionDialog([{
            name: "conditionDialogNodeId",
            value: data.id
          }]);
          return true;
        }

        if (data.type === PRICING_PRODUCT) {
          createProductNodeWithCallback(function (nodeId, text) {
            data.id = nodeId;
            data.text = text;
            continueCallback(data);
          });
          return true;
        }

        if (data.type === BRANCH) {
          data.id = uuid();
          continueCallback(data);
          createNewBranchDialog([{
            name: "branchNodeId",
            value: data.id
          }]);
          return true;
        }

        if (data.type === TARIFF) {
          createTariffNodeWithCallback(function (nodeId, text) {
            data.id = nodeId;
            data.text = text;
            continueCallback(data);
          });
          return true;
        }

        if (data.type === CAIR_TARIFF) {
          createTariffNodeWithCallback(function (nodeId, text, ruleNumber) {
            data.id = nodeId;
            data.text = text;
            data.ruleNumber = ruleNumber;
            continueCallback(data);
          });
          return true;
        }

        if (data.type === JOUNAL_NODE) {
          data.id = uuid();
          continueCallback(data);
          createJournalNode([{
            name: "journalNodeId",
            value: data.id
          }]);
          return true;
        }
      },
      edgeFactory: function edgeFactory(type, data, continueCallback, abortCallback) {
        continueCallback(data);
        return true;
      },
      beforeConnect: function beforeConnect(source, target, edgeType) {
        var hasEdges = false; // Eliminate connections to self and circular conections between 2 nodes

        toolkit.getAllEdgesFor(target).forEach(function (e) {
          if (e.target === target || e.target === source) {
            hasEdges = true;
          }
        });

        if (hasEdges) {
          return false;
        }

        if (source.data.type === CONDITION && target.data.type === BRANCH) {
          return true;
        }

        if (source.data.type === BRANCH && (target.data.type === TARIFF || target.data.type === CAIR_TARIFF)) {
          return true;
        }

        if (source.data.type === BRANCH && target.data.type === PRICING_PRODUCT) {
          return true;
        }

        if (source.data.type === BRANCH && target.data.type === JOUNAL_NODE) {
          return true;
        }

        if (source.data.type === BRANCH && target.data.type === CONDITION) {
          return true;
        }

        return false;
      },
      doNotUpdateOriginalData: false,
      autoSave: true,
      autoSaveHandler: function autoSaveHandler(toolkitInstance) {
        if (!isLoading) {
          console.log("Autosave called");
          var exportData = JSON.stringify(toolkitInstance.exportData());
          transferGraphData([{
            name: "exportData",
            value: exportData
          }, {
            name: "lastConnectedNodeId",
            value: null
          }]);
        }
      }
    });
    window.toolkit = toolkit;
    jsToolkit = toolkit; // ------------------------ / toolkit setup ------------------------------------
    // ------------------------ rendering ------------------------------------
    // Instruct the toolkit to render to the 'canvas' element. We pass in a view of nodes, edges and ports, which
    // together define the look and feel and behaviour of this renderer.  Note that we can have 0 - N renderers
    // assigned to one instance of the Toolkit..

    var renderer = toolkit.render(canvasElement, {
      view: {
        nodes: (_nodes = {}, _defineProperty$h(_nodes, SELECTABLE, {
          events: {
            tap: function tap(params) {//toolkit.toggleSelection(params.obj);
            }
          }
        }), _defineProperty$h(_nodes, CONDITION, {
          parent: SELECTABLE,
          templateId: "tmplCondition",
          events: {
            dblclick: function dblclick(params) {
              openEditConditionDialog([{
                name: "conditionDialogNodeId",
                value: params.obj.data.id
              }]);
            }
          }
        }), _defineProperty$h(_nodes, BRANCH, {
          parent: SELECTABLE,
          templateId: "tmplBranch",
          events: {
            dblclick: function dblclick(params) {
              openEditBranchView([{
                name: "branchNodeId",
                value: params.obj.data.id
              }]);
            }
          }
        }), _defineProperty$h(_nodes, TARIFF, {
          parent: SELECTABLE,
          templateId: "tmplTariff",
          events: {
            dblclick: function dblclick(params) {
              openEditTariffView([{
                name: "tariffNodeId",
                value: params.obj.data.id
              }]);
            }
          }
        }), _defineProperty$h(_nodes, CAIR_TARIFF, {
          parent: SELECTABLE,
          templateId: "tmplCairTariff",
          events: {
            dblclick: function dblclick(params) {
              openEditTariffView([{
                name: "tariffNodeId",
                value: params.obj.data.id
              }]);
            }
          }
        }), _defineProperty$h(_nodes, PRICING_PRODUCT, {
          parent: SELECTABLE,
          templateId: "tmplPricingProduct",
          events: {
            dblclick: function dblclick(params) {
              openEditPricingProductView([{
                name: "pricingProductNodeId",
                value: params.obj.data.id
              }]);
            }
          }
        }), _defineProperty$h(_nodes, JOUNAL_NODE, {
          parent: SELECTABLE,
          templateId: "tmplJournal",
          events: {
            dblclick: function dblclick(params) {
              openEditJournalView([{
                name: "journalNodeId",
                value: params.obj.data.id
              }]);
            }
          }
        }), _nodes),
        // There are two edge types defined - 'yes' and 'no', sharing a common
        // parent.
        edges: (_edges = {}, _defineProperty$h(_edges, DEFAULT$1, {
          anchor: AnchorLocations.ContinuousTopBottom,
          endpoint: BlankEndpoint.type,
          connector: {
            type: OrthogonalConnector.type,
            options: {
              cornerRadius: 3,
              alwaysRespectStubs: true,
              stub: [30, 30]
            }
          },
          paintStyle: {
            strokeWidth: 2,
            stroke: "rgb(132, 172, 179)",
            outlineWidth: 3,
            outlineStroke: "transparent"
          },
          //	paint style for this edge type.
          hoverPaintStyle: {
            strokeWidth: 2,
            stroke: "rgb(67,67,67)"
          },
          // hover paint style for this edge type.
          events: {
            click: function click(p) {
              toolkit.clearSelection();
              toolkit.addToSelection(p.edge);

              if (canEdit) {
                edgeEditor.startEditing(p.edge, {
                  deleteButton: true,
                  onMaybeDelete: function onMaybeDelete(edge, connection, doDelete) {
                    showGraphViewConfirmEdgeDeleteDialog(edge);
                  }
                });
              }
            }
          },
          overlays: [{
            type: ArrowOverlay.type,
            options: {
              location: 1,
              width: 10,
              length: 10
            }
          }]
        }), _defineProperty$h(_edges, RESPONSE, {
          parent: DEFAULT$1
        }), _edges),
        ports: (_ports = {}, _defineProperty$h(_ports, SOURCE, {
          maxConnections: -1,
          edgeType: RESPONSE
        }), _defineProperty$h(_ports, TARGET, {
          maxConnections: -1,
          isTarget: true
        }), _ports)
      },
      // Layout the nodes using an Hierarchical layout
      layout: {
        type: HierarchicalLayout.type,
        options: {
          orientation: "horizontal",
          padding: {
            x: 60,
            y: 60
          },
          absoluteBacked: true,
          magnetize: true
        }
      },
      refreshLayoutOnEdgeConnect: false,
      refreshAutomatically: false,
      elementsDraggable: true,
      grid: {
        size: {
          w: 20,
          h: 20
        }
      },
      events: _defineProperty$h({}, EVENT_CANVAS_CLICK, function (e) {
        toolkit.clearSelection();
        edgeEditor.stopEditing();
      }),
      consumeRightClick: false,
      dragOptions: {
        filter: ".jtk-draw-handle, .node-action, .node-action i"
      },
      plugins: [{
        type: MiniviewPlugin.type,
        options: {
          container: miniviewElement,
          typeFunction: function typeFunction(obj) {
            switch (obj.data.type) {
              case CONDITION:
                {
                  return "condition";
                }

              case BRANCH:
                {
                  return "branch";
                }

              default:
                {
                  return "tariff";
                }
            }
          }
        }
      }, DrawingToolsPlugin.type, {
        type: LassoPlugin.type,
        options: {
          lassoInvert: true,
          lassoEdges: true
        }
      }],
      magnetize: {
        afterDrag: true
      }
    });
    var edgeEditor = new EdgePathEditor(renderer);
    toolkit.bind(EVENT_UNDOREDO_UPDATE, function (state) {
      controls.setAttribute("can-undo", state.undoCount > 0 ? "true" : "false");
      controls.setAttribute("can-redo", state.redoCount > 0 ? "true" : "false");
    });
    toolkit.bind(EVENT_EDGE_ADDED, function (edgeParams) {
      if (edgeParams.edge.target.data.type === BRANCH) {
        edgeParams.edge.target.data.parentCondition = edgeParams.edge.source.data.dimensionName;
        edgeParams.edge.target.data.conditionNodeId = edgeParams.edge.source.data.id;
      }

      if (edgeParams.edge.target.data.type === TARIFF || edgeParams.edge.target.data.type === CAIR_TARIFF || edgeParams.edge.target.data.type === PRICING_PRODUCT) {
        edgeParams.edge.source.data.resultId = edgeParams.edge.target.data.id;
      }

      var lastConnectedNodeId = null;

      if (edgeParams.addedByMouse) {
        lastConnectedNodeId = edgeParams.edge.target.data.id;
      }

      if (!isLoading) {
        var _exportData = JSON.stringify(toolkit.exportData());

        transferGraphData([{
          name: "exportData",
          value: _exportData
        }, {
          name: "lastConnectedNodeId",
          value: lastConnectedNodeId
        }]);
      }
    });
    toolkit.bind(EVENT_EDGE_REMOVED, function (edgeParams) {
      if (edgeParams.edge.target.data.type === BRANCH) {
        edgeParams.edge.target.data.parentCondition = null;
        edgeParams.edge.target.data.conditionNodeId = null;
      }

      if (edgeParams.edge.source.data.type === BRANCH) {
        edgeParams.edge.source.data.resultId = null;
      }

      var exportData = JSON.stringify(toolkit.exportData());
      transferGraphData([{
        name: "exportData",
        value: exportData
      }, {
        name: "lastConnectedNodeId",
        value: null
      }]);
    });
    toolkit.bind(EVENT_DATA_LOAD_END, function () {
      if (ignoreFirstLoadCall) {
        ignoreFirstLoadCall = false;
      } else {
        adjustFontSizeOnAllNodes(true);
        console.log("Load finished " + new Date().toLocaleString());
        isLoading = false;
      }
    }); // Define a function to handle node updates

    function onNodeUpdate(params) {
      var updatedNodeId = params.originalId;
      adjustFontSize(updatedNodeId, true);
    } // Listen for the dataUpdated event on the toolkit


    toolkit.bind(EVENT_NODE_UPDATED, onNodeUpdate);
    toolkit.bind(EVENT_NODE_ADDED, function (params) {
      var node = params.node;
      var nodeElement = renderer.getRenderedElement(node.id); // Attach click handler to the node element

      nodeElement.addEventListener("click", function (event) {
        handleNodeClick(node, event);
      });

      if (node.type === CAIR_TARIFF && isTooltipEnabled && isTooltipEnabled.textContent === "true") {
        nodeElement.addEventListener("mouseover", function (event) {
          showCairTariffTooltip(event, node);
        });
        nodeElement.addEventListener("mousemove", function (event) {
          showCairTariffTooltip(event, node);
        });
        nodeElement.addEventListener("mouseout", function (node) {
          hideTariffTooltip();
        });
      }
    });

    function showCairTariffTooltip(event, node) {
      if (cairTooltip && node) {
        var htmlContent = "<table>";
        htmlContent += "<tr>";
        htmlContent += '<td colspan="4" style="border: 2px white solid">';
        htmlContent += '<span style="color: white; font-weight: bold; padding-left: 5px">';
        htmlContent += "".concat(grossCoverageTitle.textContent, " </span>: <span style=\"color:white\"> ").concat(node.data.grossCoverageAmount, "% </span></td>");
        htmlContent += "</tr>";

        if (node.data.noFormula) {
          htmlContent += "<tr>";
          htmlContent += '<td colspan="4" style="border: 2px white solid"><span style="color: white; font-weight: bold; padding-left: 5px>"';
          htmlContent += "".concat(noFormulaTitle.textContent, " </td>");
          htmlContent += "</tr>";
        } else {
          htmlContent += "<tr>";
          htmlContent += '<td style="text-align:left; border: 2px solid white">';
          htmlContent += '<span style="color:white; font-weight:bold;padding-left: 5px;padding-right: 5px">';
          htmlContent += "".concat(rateTitle.textContent);
          htmlContent += "</span></td>";
          htmlContent += '<td style="text-align:left; border: 2px solid white">';
          htmlContent += '<span style="color:white; font-weight:bold;padding-left: 5px;padding-right: 5px">';
          htmlContent += "".concat(beslTitle.textContent);
          htmlContent += "</span></td>";
          htmlContent += '<td style="text-align:left; border: 2px solid white">';
          htmlContent += '<span style="color:white; font-weight:bold;padding-left: 5px;padding-right: 5px">';
          htmlContent += "".concat(descriptionTitle.textContent);
          htmlContent += "</span></td>";
          htmlContent += '<td style="text-align:left; border: 2px solid white">';
          htmlContent += '<span style="color:white; font-weight:bold;padding-left: 5px;padding-right: 5px">';
          htmlContent += "".concat(formulaTitle.textContent);
          htmlContent += "</span></td>";
          htmlContent += "</tr>";
        }

        if (node.data.tariffDetails) {
          node.data.tariffDetails.forEach(function (detail) {
            htmlContent += "<tr>";
            htmlContent += '<td style="text-align: left; border: 2px solid white">';
            htmlContent += '<span style="color: white; text-align: left; padding-left: 5px; padding-right: 5 px">';
            htmlContent += "".concat(detail.rate);
            htmlContent += "</span></td>";
            htmlContent += '<td style="text-align: left; border: 2px solid white">';
            htmlContent += '<span style="color: white; text-align: left; padding-left: 5px; padding-right: 5 px">';
            htmlContent += "".concat(detail.besl);
            htmlContent += "</span></td>";
            htmlContent += '<td style="text-align: left; border: 2px solid white">';
            htmlContent += '<span style="color: white; text-align: left; padding-left: 5px; padding-right: 5 px">';
            htmlContent += "".concat(detail.description);
            htmlContent += "</span></td>";
            htmlContent += '<td style="text-align: left; border: 2px solid white">';
            htmlContent += '<span style="color: white; text-align: left; padding-left: 5px; padding-right: 5 px">';
            htmlContent += "".concat(detail.formula);
            htmlContent += "</span></td>";
            htmlContent += "</tr>";
          });
        }

        htmlContent += "</table>";
        cairTooltip.innerHTML = htmlContent;
        cairTooltip.style.left = "".concat(event.pageX + 10, "px");
        cairTooltip.style.top = "".concat(event.pageY - 10, "px");
        cairTooltip.style.display = "block";
      }
    }

    function hideTariffTooltip(node) {
      cairTooltip.style.display = 'none';
    }

    renderer.on(controls, EVENT_TAP, "[undo]", function () {
      toolkit.undo();
    });
    renderer.on(controls, EVENT_TAP, "[layout]", function () {
      renderer.relayout();
      renderer.repaintEverything();
    });
    renderer.on(controls, EVENT_TAP, "[redo]", function () {
      toolkit.redo();
    }); // Load the data.

    toolkit.load({
      data: loadGraphData(),
      onload: function onload() {
        toolkit.clear();
        toolkit.setDoNotUpdateOriginalData(false);
        renderer.zoomToFit();
        console.log("Load started " + new Date().toLocaleString());
      }
    }); // listener for mode change on renderer.

    renderer.bind(EVENT_SURFACE_MODE_CHANGED, function (mode) {
      forEach(controls.querySelectorAll("[mode]"), function (e) {
        renderer.removeClass(e, "selected-mode");
      });
      renderer.addClass(controls.querySelector("[mode='" + mode + "']"), "selected-mode");
    }); // pan mode/select mode

    renderer.on(controls, EVENT_TAP, "[mode]", function (e, eventTarget) {
      renderer.setMode(eventTarget.getAttribute("mode"));
    });
    window.renderer = renderer;
    jsRenderer = renderer; // on home button click, zoom content to fit.

    renderer.on(controls, EVENT_TAP, "[reset]", function (e, eventTarget) {
      toolkit.clearSelection();
      renderer.zoomToFit();
    }); // on clear button, perhaps clear the Toolkit

    renderer.on(controls, EVENT_TAP, "[clear]", function (e, eventTarget) {
      if (toolkit.getNodeCount() === 0 || confirm("Clear flowchart?")) {
        toolkit.clear();
      }
    });

    if (canEdit) {
      /*  console.log("CanEdit is now ", canEdit); */
      renderer.bindModelEvent(EVENT_TAP, ".node-delete", function (event, eventTarget, info) {
        showGraphViewConfirmDialog(info.obj);
      }); //
      // change a question or action's label
      //
      // bindModelEvent is a new method in 4.x that attaches a delegated event listener to the container element, and when a matching event
      // occurs, it passes back the event, the event target, and the associated model object. Events occur on DOM elements that are children of the element
      // representing a model object, and this method abstracts out the decoding of the appropriate model object for you.
      //

      renderer.bindModelEvent(EVENT_TAP, ".node-edit", function (event, eventTarget, info) {
        if (info.obj.data.type === CONDITION) {
          openEditConditionDialog([{
            name: "conditionDialogNodeId",
            value: info.obj.data.id
          }]);
        }

        if (info.obj.data.type === PRICING_PRODUCT) {
          openEditPricingProductView([{
            name: "pricingProductNodeId",
            value: info.obj.data.id
          }]);
        }

        if (info.obj.data.type === BRANCH) {
          openEditBranchView([{
            name: "branchNodeId",
            value: info.obj.data.id
          }]);
        }

        if (info.obj.data.type === TARIFF || info.obj.data.type === CAIR_TARIFF) {
          openEditTariffView([{
            name: "tariffNodeId",
            value: info.obj.data.id
          }]);
        }

        if (info.obj.data.type === JOUNAL_NODE) {
          openEditJournalView([{
            name: "journalNodeId",
            value: info.obj.data.id
          }]);
        }
      });
    } // ------------------------ / rendering ------------------------------------
    // ------------------------ drag and drop new nodes -----------------
    //
    // Here, we are registering elements that we will want to drop onto the workspace and have
    // the toolkit recognise them as new nodes. From 1.14.7 onwards we're using the SurfaceDropManager for this,
    // which offers the simplest way to configure node/group drop, including dropping onto an edge.
    // For more information, search for SurfaceDropManager in the docs.
    //
    //  source: the element containing draggable nodes
    //  selector: css3 selector identifying elements inside `source` that ae draggable
    //  dataGenerator: this function takes a DOM element and returns some default data for a node of the type represented by the element.


    createSurfaceManager({
      source: nodePalette,
      selector: "div",
      dataGenerator: function dataGenerator(el) {
        return {
          w: parseInt(el.getAttribute("data-width"), 10),
          h: parseInt(el.getAttribute("data-height"), 10),
          type: el.getAttribute("data-node-type")
        };
      },
      surface: renderer
    }); // ------------------------ / drag and drop new nodes -----------------
    // -------------------- printing --------------------------
    // register a handler in the client side. the server will look for the handler with this ID.

    registerHandler(renderer, "graphview-print");

    function adjustFontSizeOnAllNodes(resetFont) {
      var nodes = toolkit.getNodes();
      nodes.forEach(function (node) {
        adjustFontSize(node.id, resetFont);
      });
    }

    function adjustFontSize(nodeId, resetFont) {
      var nodeElement = renderer.getRenderedElement(nodeId);

      if (nodeElement) {
        // Function to check if text overflows
        var isOverflowing = function isOverflowing(textElement, expressionElement) {
          if (textElement && expressionElement) {
            return textElement.scrollHeight + expressionElement.scrollHeight > textElement.parentElement.clientHeight - 15 || Math.max(textElement.scrollWidth, expressionElement.scrollWidth) > textElement.parentElement.clientWidth;
          } else if (textElement) {
            return textElement.scrollHeight > textElement.parentElement.clientHeight - 15 || textElement.scrollWidth > textElement.parentElement.clientWidth;
          }

          return false;
        }; // Adjust font size until both elements fit within the node


        var resizeText = function resizeText() {
          while (fontSize > 6) {
            var textToBig = false;

            if (isOverflowing(textSpan, expressionSpan) && fontSize > 6) {
              fontSize--;
              textSpan.style.fontSize = fontSize + "px";

              if (expressionSpan) {
                expressionSpan.style.fontSize = fontSize + "px";
              }

              textToBig = true;
            }

            if (!textToBig) {
              break;
            }
          }
        };

        var expressionSpan = nodeElement.querySelector(".node-expression");
        var textSpan = nodeElement.querySelector(".node-text");
        var fontSize = 16; // Initial font size

        if (textSpan) {
          if (!resetFont) {
            fontSize = Number(textSpan.style.fontSize);
          } else {
            textSpan.style.fontSize = fontSize + "px";
          }
        }

        if (expressionSpan) {
          if (!resetFont) {
            fontSize = Number(expressionSpan.style.fontSize);
          } else {
            expressionSpan.style.fontSize = fontSize + "px";
          }
        }

        resizeText();
      }
    } // Assuming jsToolkit is your jsPlumbToolkit instance and jsRenderer is the renderer instance


    jsRenderer.bind("canvasClick", function (event) {
      // Clear selection on canvas click
      jsToolkit.clearSelection();
    }); // Function to handle node click

    function handleNodeClick(node, event) {
      if (!event.ctrlKey && !event.shiftKey || jsToolkit.getSelection().getEdges().length > 0) {
        jsToolkit.clearSelection();
        edgeEditor.stopEditing();
      }

      jsToolkit.addToSelection(node);
    }
  }

  function initJsPlumb(canEdit) {
    ready(function () {
      callDOMReady(canEdit);
      addCopyPasteListeners(canEdit);
    });
  }
  function jsPlumbUuid() {
    return uuid();
  }

  function addCopyPasteListeners(canEdit) {
    if (canEdit) {
      document.addEventListener("keydown", function (event) {
        var dialogBranch = document.getElementById("breadCrumbAndDialogForm:graphViewBranchNodeDialog_modal");
        var dialogCondition = document.getElementById("breadCrumbAndDialogForm:editConditionNodeDialog_modal");
        var dialogJournal = document.getElementById("breadCrumbAndDialogForm:editJournalNodeDialog_modal"); // Check if the pressed key is the delete key (keyCode 46) or (key 8 for backspace)

        if ((event.key === "Backspace" || event.key === "Delete") && !(dialogBranch || dialogCondition || dialogJournal)) {
          if (jsToolkit.getSelection().getNodes().length === 1 && jsToolkit.getSelection().getEdges().length === 0) {
            showGraphViewConfirmDialog(jsToolkit.getSelection().getNodeAt(0));
          }

          if (jsToolkit.getSelection().getNodes().length === 0 && jsToolkit.getSelection().getEdges().length === 1) {
            showGraphViewConfirmEdgeDeleteDialog(jsToolkit.getSelection().getEdgeAt(0));
          }
        }

        if (event.ctrlKey && event.code === "KeyC") {
          // Custom logic for CTRL+C
          // Clear the clipboard if nodes selected
          if (jsToolkit.getSelection().getNodes().length > 0) {
            copiedNodes = [];
          } // Deep copy nodes data to clipboard


          jsToolkit.getSelection().getNodes().forEach(function (node) {
            var nodeData = Object.assign({}, node.data);
            copiedNodes.push(nodeData);
          });
        }

        if (event.ctrlKey && event.code === "KeyV") {
          // Custom logic for CTRL+V
          var currentTime = new Date().getTime(); // Get the current time in milliseconds

          if (currentTime - lastCtrlVTime < 1000) {
            // If the last execution was less than 1 second ago, prevent execution
            return;
          } // Update the last execution time


          lastCtrlVTime = currentTime;
          var dialogBranch = document.getElementById("breadCrumbAndDialogForm:graphViewBranchNodeDialog_modal");
          var dialogCondition = document.getElementById("breadCrumbAndDialogForm:editConditionNodeDialog_modal");
          var dialogJournal = document.getElementById("breadCrumbAndDialogForm:editJournalNodeDialog_modal");

          if (!(dialogBranch || dialogCondition || dialogJournal)) {
            copySelectedNodes(copiedNodes, isPasting).then(function () {
              var exportData = JSON.stringify(jsToolkit.exportData());
              transferGraphData([{
                name: "exportData",
                value: exportData
              }, {
                name: "lastConnectedNodeId",
                value: null
              }]);
              isPasting = false;
              jsToolkit.getSelection().clear();
            });
          }
        }
      });
    }
  }

  exports.initJsPlumb = initJsPlumb;
  exports.jsPlumbUuid = jsPlumbUuid;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
